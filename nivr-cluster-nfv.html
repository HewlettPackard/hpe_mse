<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>MSE VNF MSE 2 nodes: ems and Pgsql database, refresh one node</title>
<style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"><style>{font-family: arial; font-size: small}body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}h1, {color: #FF8D6D;}h2, h3, h4, h5 {color: #C6C9CA;}input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}.buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.buildButton:hover { background-color: #4CAF50; color: white;}.helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}.helpButton:hover { background-color: blue; color: white;}a:link, a:visited { text-decoration: none; color: #80746E;}</style><link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==" rel="icon" type="image/x-icon"></head>
<body>
<table width="100%" border="0">
<tbody><tr><td align="left" valign="top">
<h1>MSE Descriptor</h1>
<p><a title="Click to view version history" id="vnfDescriptorWizardVersion" style="color: #01a982; text-decoration: underline;" onclick="versionHistory()" href="#endOfUserArea">2018-08-02 Version 2.36</a></p>
<p><a title="Click to view the MSE automated deployer compatibility matrix" id="compatibilityMatrix" style="color: #01a982; text-decoration: underline;" onclick="compatibilityMatrix()" href="#">Compatibility Matrix</a></p>
<p>
<label for="quickDescription">Description :</label>
<input name="quickDescription" id="quickDescription" size="150" placeholder="One line VNF description" value="MSE 2 nodes: ems and Pgsql database, refresh one node">
</p>
</td>
<td align="right" valign="top">
<img id="HPElogo" alt="logo.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAU0AAACBCAYAAABErei/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABo/SURBVHhe7Z0JuFVV+YcXIgpqqDjhVGZqZWamleX0hAaBlg2PkuY8JIQpfzUnxKkcM6KQHMqhIjON1JzIoUwrMzKVnCg0ckYlJUVEAfd/veusb7POZp97z773XOVyf+/zfPfss9bae6+99tm/++019vJkTgghRFMsFz+FEEI0gURTCCEqINEUQogKSDSFEKICEk0hhKiARFMIISog0RRCiApINIUQogISTSGEqIBEUwghKiDRFEKICkg0hRCiAhJNIYSogERTCCEqINEUQogKSDSFEKICEk0hhKiARFMIISog0RRCiApINIUQogISTSGEqIBEUwghKiDRFEKICkg0hRCiAhJNIYSogERTCCEqINEUQogK9PJkcVt0lqyHFGWvXnFDiJ6HRLNVIJgr9nFuhRWce+utGLiM0du/mMx9vXZ9Ek7RQ5FotoJQgv7PAUNddtSeXljmh+BljlVXdr0OOde5qY9KNEWPRaLZCkw0hw9y2YjdnXttGRbN0ROce+AxiabosUg0W4GJ5p5eNEcmornSis4t183b2hYtcu71N2vbiOb/ne/c/TMkmqLHItFsBdYAtM9glx20q3PzvGhS/3fZzc694QWnVzcVTgRz4IDwz8AtWFgTzVHjnXt4pkRT9Fgkmq2g6GnOe8O5Pr1dr2HHLRbU7sq6a7ps0pjaNcnTFEL9NFtKUUf6rVD7RGC6o0HfeA1GT+lWJUQDJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJZlcyP3YKp8W5OxrQz1QIkaN+mq0glKD/kw6jpHP7xGtqwtldRwXRuX2dNZw7aKhzb8bO7RpGKXo4Es1WUCaasHLf7iuYBsJJx3aQaAoh0WwJjURzWUOiKYREsyWYaO5vU8O9HoKXORDNQ5kabrpEU/RYJJqtwERz5X4u67/SMjwJcW/Xa/acWv2mRFP0UCSarcKEsycgwRQ9GImmEEJUQP00hRCiAhJNIYSogERTCCEqINEUQogKSDSFEKICEk0hhKiAuhy1kMxmBkrw5Ru3FtNsureLYn7eybwUKSurIm9nfpe2e1dGozJb2vLZXfHlKNFsBfxQ+/Xr51ZaaSX31ltvueWWW87997//DXHpj5V0q6yyiltxxRXDNmnnzJkT4t6JHzV56N+/v1t++eXD90WLFrn//e9/S8UDZg//Rz7yEffmm/VT1JG/xx57rDS8q7D8bLLJJm6FFVYI93j27Nlu1qxZS0V5geVxs802C/eUPL7wwgvBYGnJZ7fGF2Im65z5Ygw2fvx4/5tdzIABA0J4Me3kyZNjiizzopl5oV0i3dtlnHfq1KkxN1nmhb7TeWH/1NqKM0vTpGn5bI8ZM2ZkW2+9dZvHaoXZ8b1QxjNn2VVXXdXl561i5KNv376Z/2cSc5hlEyZMWKry2N1NdZot5JVXXolbNRYuXBi36jHPEp5//vng3b2TvPTSS3HLuRdffDFudQz/jLqJEye6G264wd10003u5JNPzr0fPv2Pzl1xxRXuN7/5jbvlllvcV77ylTyujEbhKXh+f//7393YsWPD92b26Qz2BgHFe740wO8pvY9z586NW6IVSDRFy/n85z/vPve5z7ldd93VDRo0KIbWQND23HNPt/vuu7shQ4a4LbfcMsY0x7x584JopUJvfPvb33bbbbdd/CZE1yDRXApBWNqyRmmMZsMtzj4BT7BIcZ+iGbadejavvvpq+EzTvfbaa3FrcTykaRoxatQot+aaa7o11lgj5PXYY4+NMTXGjBkTPi1vbVmRsjSptUfZPs1aSll80Rqlg3f6zWVZx//uQj2I6AT2Y8XTsVdEWHXVVcPrWypEpL388svdgQceGL4/99xzbqONNgoNGqSzY332s591++67b4i777773D333OOuvPLKEAcf+9jHgsf2xhtvBO9r/PjxYRve9773uREjRoTqgbvvvtvdeOONIRz233//vJFgypQp7s4773S33nqrGzx4cIh/9NFH3eabb57n2fJD49Vhhx3mhg0bFs5DfngFnzZtWogHvMctttjCHXXUUUHYgMaaH/3oR27llVcOjV4c98QTTwwNYfCHP/whnL9v377uzDPPzMsB7Nz2CaNHj3YTJkyoK6u//vWv7hOf+ETYfuaZZ9wGG2wQ4rlOXv+5HsqRuIceeiiU4/Tp00P64rkADxiPdfvttw+i/sADD7gLL7wwf+X95z//GY4NXBtlDVzD0UcfHa6td+/e4d6PGzcuiNj6668fvO9PfepTYV+O+/DDD7vrrrvO3XXXXWF/uya873322SeUM+nOO++8kBfuHQ1PJ510UkgP6667bvjdUe78lrgnv/zlL8OxuWY4++yz838mdr2iE/hCLK3slDVvvhiDnXXWWf43vxgLL9pFF10UU2SZf5AzL2B18f6HH2Pr+fOf/5z1798/pNlhhx1iaI0PfvCD+f7nnHNODM0yL1p5uH+YM+/lxZgsGz58eAj/3e9+F0Oy7MEHHwxh6bV5QcpmzZoVU9Rz2mmn5cefNGlSDO0Y73rXu5Y4N5Zy5JFH5mks/qabboqxNQjbe++947dyvPDk+9uxaED54x//GFPUM3/+/LzBzotmDM0yL6b5cYrXf/jhh4fwD3zgAzGkHM5px8AOOuigGJOFcvf/ZOK3LPNCmqf75Cc/GUPr8SKfvfDCC/FbFn6Xto+VrazjJtFsgdkPsiia3mvL/H/87JFHHsntH//4RzZnzpyYIsueffbZOtH805/+FGNqFMWKlmJL+5///CeGZkEoLZw0Bg/ZeuutF8K32WabGJpl3oPJ0zcSTT69JxNjaixYsCB76aWX4rcaI0eODGm9BxdDOob9QyiWa4oJUWr8YzAQDMJI1x7ek8+PgWB6zzDGlGOiXiaaqdDBKaeckh+bfzrt4d8+8vTey4yhtfuXMnfu3JBm4403jiHtI9FsralOswvxHkZ4NfReYG4f/vCHw2t7GXvssUd4DYOXX37ZbbvttuG1jtbhp59+OoSzzas70AJtfOELXwifG264YdjHoD+h90jCNq/7xh133BG3yvHPWvikpdugtdsLh1tnnXXc1772tRjq3Lnnnhs+eQX80Ic+5J544onwHf7yl7+EMuC1lOvhtff11xcvB8LrLf0wue5mWnnXXnttt9Zaa7n3vOc94VjeSwvVEQbfgSoL/8/Abb311qGqYPXVV3df/OIX8yoM4FXa+OEPfxiuzfBevfv4xz8e7pkXRPfvf/879HksQv0s5X3ZZZfFEOfuv/9+961vfSt+q5Ul1RDcI/K+2mqrhTJ56qmnYgoX8lb2u+D+gf9n66655prQSwDSaiD4/e9/73beeedQ7UOViOhCypRUVs18MQYreprNkHqa/sGKoVl2/PHH58fFTj755BiTZf6BDGGp5+iFKPMPXTZs2LAYspiJEyeG9NOnT48hWfblL385P3aZp4mtssoqMTTLFi5cmHlxyOOwRYsWxdgs69evXx6OR23ceOONdftgeEtG8TrLyrVZvFBmXhzrjod5Ic8222yzsH3GGWfE1FnmRSucxwtTDKlBNUjxGJgXzfCZepoXX3xx5oUsfqvdh7SaId0fw0PcYostwnZ6/8D/IwjhqacJl156ad0xsJT0nmH8DtIylqfZWpOn2YUcfPDBbvjw4W6vvfbKjcYAq/g3/O86fOKFGv51O4SbpZ4LjUCA92FeHY0QO+ywQ2iMgfnz5+eeDOfFuzGPjMYFPJP2wEszaNjA203zlHpe1hADaTj7gf+xhU9It/v06RM+CUvDq4InSAMKHjrQGEQ5k08af2i8YTttRMGLw/BYU0444YTwaXmyfNGQVYTGMSsnjo9nSvkWrwVPlPjHH3/ceZEL2/fee2/4NKwsihx33HHhs1H50DAGFo/HbuUgWo9EswuZNGmS+9WvfuWuuuqq3OjwXXx94mHk4W300BQZMGBA+FywYEFo/TZ222230DcSbrvttvz1ne45++23Xz5UkpbvtIN9I6z1tRnWW2+9uNW10EcT4eGfBeLzs5/9LLw+8w/ByhXRRpB23HHH8B1olU8FCvhO2VtLvlEmOI0EKxVS0livAY5t5+NekEeDfWz4Z3rcYv6Ae2z3zaCqISXtbA9cf/qPS7QWlWwXwjh04MEwg+JDQHjxob7gggvcZz7zGedfo3P70pe+FOrFvvnNb8ZUzv3iF7+IW7XuRO9+97vD9m9/+9tgxne+85245ULdGFh+7BPSPKQPI/mjzhVPNs0T3wlPvef0gS32GeRcaTyiUAWunXpdBB3P8oADDnA/+clPYmwN6vWodzX4Tl0rZtdukJdiR/mtttoqbtVIBbAI5f/ss8/Gb85Nnjw5btXgN8B9NKj/pXsQ9d1nnHFGDG0M5ZXeHyiKOt4tWB4pU/XV7EL8DSl9b5c1b74YgxXrNIutwZb2pz/9aUxRX6fpRS6GZpn3pPLjpmb1XqmVQb3Z2muvXdfFyLD9LD9TpkyJMVlokbd46uZSqA+0uNSKdZ333Xdf3CPLvMdXF4c9+eSTMTbLvKdYF1csKywl7XJUNEs/bty4mDrL/va3v+XhGK3dBj0TrP4xrQNk23uudfsNHjw4dNliO63T9CIYyjrl+uuvz/cbMmRIDK1h4Zj/pxNDa9g50zpNeisMHDgwhKfXmfaqoNXf/yPJj+v/scaYGqrTbK3J01yKsLorwGPEA6Lj8siRI90pp5zivACEzuqGv4Hhk1biFDpAU4/HzDZpCy1Qt1ckDaNVGu+J13nq5s4///wY40J94O233+6OOeaYMDKHDt/MiJR6vjBjxoy45dw222wTqimo06NlH+hkbnCeH/zgB6EVnQ70/hmPMR2H13aD+l/yTX3xaaedFsoyxbxersmgIz6d3+l4zkAEOorTc4B64yK0uFPWP//5z2NIbRjpLrvsErbT+wVUJ9CLgNbyq6++OoZW5/TTT49btTzQAZ+qH1rXybfoQooqKqtuvhiDFT1NWjEJL6bFuzKee+65un6aXiRjTDlepPK0djz/+hlja9x88815Gma4SRk7duwS+w8dOjTGLuaSSy7J07VHOosO5oUwxtTjhSvE+wc+htSTtjpb3rCU0aNH16UpGnF4hLT2t8eLL76Y3yMs7UVQhuXvX//6VwzJwkAF2z+FfrB2X6dNmxZD28a8RfqPGlwHfWUJT6+Rz8cffzymaht5mq01eZotpNiQ4ws4btWTpqMBKK3jY1YghirSGlwEr44ZhIpQd5nWDaZ9BvHyUswLSfPG/qnnAuTLIO33vve90vpHPLJiPSHnvPjii+O3xVg926mnnho8tyJlrdPFMizWBxchPX0xN9100zC8MoVzMsQTvJaE/qLp8fEODznkkDAcsQiNata/NC2b9F7iYRp4zfTNBOpIaQRMwdum3yz3tDgbVnqN9D5Ifx9Ansk/jV/FsqfumWtk6K3RbAOjaA5f/uE/l+gE/ICByXzpoIw48GO3V+P0wSQtrZ+8ArKNUNhDag8D8GDS6k2DAY0JtBjzoPHKDHZMSz9w4MBwTusalAoQr/rkibTWaFHME9BN573vfW/45IEnX2meyDeds9///veHhx1h53h2rmKerLGG7k60bBdfVckXnby5Vu+9NRwPTpUBgo140AhCh/I0/0VsP+AclM2sWbPck08+GfbjGsgz6ayxK71OJpMmzzTY0H2H+2iDC4BGJoSNfYhPeyIwFpxwjDSc047LfuSHc3IvEXfyQjz3jbHt5Ivz0wrPPeM43AfC2TbSaySf/JOgRwH3hPwwCACxpMy4VzaFXXoM0TF8GUo0W0H6I04p+5GWpW30QJRRPGZbx2vvXMbbkSdoK1/QzHHK8l+kvfymVLnOMpq5pmaP2yht2TVXzWvZMUR1fDlKNIUQollUpymEEBWQp9ki9KpUjbS8enpZiO6FRLMFmAAwxnvvvfeum8WnCEP26FdJK3hHxaK7Cw75p5GIBgybIFnCKboLEs0WYCL23e9+t66TdCPo+jJ06NAOCUUqmEZ3EhzLP11jaN1leOfxxx8fwiScojugOs0WYpMwMCKHceJM0lA0ZsU566yzQrqOwryJzHCUjtbpbljfwbTPoxDdAXmaLcC8JzqIM9yRvnI2DVsjzKsq8xxTUu/L0n71q18NkwMzXDBdzbHoqTXjlbZ3/mbo6DGZvNeGVJZdZ5HieaCZaxSilcjTbCHmadJRGXh4GxnwwLNNegsDxhLTwRlMFFJxsPOkHdghTWPbHIdO90ZZmiKMsW5r5A3HpBO/jVRp5ph4lMUp2NIx6IbtT5kwqibNR/HY9p18kB8r90Z5EKIVSDRbCKN8qsIEsoz2oQGJeTIZicPIDkbHsCQFYmMiwFyZDA1k4glg9A5DIFmagckzDEvPkElG4jCihf1YBRJSUWHyCOJsOB5DINnn17/+dfjOCBcmCrEGmx//+MfBk2akC1UEtoRuekxGszDskHhgQg8mBWEZCEbEwKWXXuqmTp3qPv3pT4fvYMdgAuZHHnkklAOTZXCsdKLf9JMlK0iDAON5k2/EOc2PEC3Fezilg9JlzZsvxmA2YYcXnTyskdl+NklEuqJicTo3mxps1KhRMWRJWMTNjr3VVlvF0NqEDzNnzozfalPRWTpst912C+FMHJIuyDZ79uyQR6YrMwgD7+mGT+Puu++uOyZTxbHsA1xxxRXh02AaNdLYuVg10vbzHmPd4mZMU7coWVKjrSnomEqPadQMVmokTXqfZLJWmDzNLgDvjOnVrr322jpjTWoab3id9M91SGuTYOBFXn/99cETYzwyi6HZuGimhwMm28WLY1o2YHZyXqUZK77TTjuFMOBccMkll4RjUb+KV4r3St5sf7BJNBifjVFfyhRuTD5heTQYC8+kFnjEjM22pSNYNC2d1o79WG4DOB4NX4wfZ5o2vEewBc7s/IDXSNUEHijXxXhqxrvjjTJuPc0Pa3l/9KMfdV5YQ9eljTfeOKRl/Xe46KKLwmfxGoToNGVKKqtmvhiDFaeGK4Op3fr06ZPvYxMP+1fXPMzsoLgsLFOApeF77LFHCC9bAGzEiBEhDq+wGMfUY8DCZ3h1hKXTwpkXWLYPeGFfIt4WfPMCny9qxpLBL7/8cghPlxZO7aGHHgrxtvY6ZlPmfeMb36hLa7Z8nGrNi3o+9dtGG220RDqmfINtt902fC+7ZzJZR02eZhfArDQsSzto0KA6w0sbMmRI6RRrNiGtvyl5o5DNCoT3ZY0cYI0j1hCT7mPL+zIVGZ4adYEY+cFLZVYePElbZ8hgJhwm04X0eAae45QpU8J2Go8XzNRmHI9lKIqceeaZ4dP2KR43xaYzwxun878tIGfYFGos70B5MNkxM0Dhcdp1MgOTTQlXlh8hOotEswtAYGgEoVEnNVaAtAe6KB5ls4JbH0bvNOUC2R6II/AKznRrzOSNMbM3a5DTIo2lLerQlpgB5y/LI5jYlolUKvbt8f3vfz+fdf3www8PDVA0OHnPM4QZtoYP/xRoBEJs7TqpgmCBOZBoiq5AotkFFD3AMusqbDE3WsOZOBivLTVa62lpt/kVW4F1fWqrm1J7WJnQ7/TQQw/Nl8zAKybfLLNhWHcsBHLcuHGl18jyGcX5O4VoCf7HWvreLmvefDEGszpNW5ysLG1qpLE6TZaASPdhm+Uh4Pnnn6+rB91rr71CuNVppvtMnjw5xB1zzDF5+rbM6jSpa7Ww9HhWp0lreFk8daPWwu0FL4SldZqrrbZa3T62X1mdZtFYtuLEE08M6YBlPQjfZZddwnda4Iv7FC09r0zWCpOn2QWY5+Wf64bWGaxOtGyNbVsHndblRnRk6CKv5izXC+n5aDXHs6Ye11rGOwrVBob/cYYWdq6Dxc2A+kqgnyhlzOs3w1XLsGGaQrQaiWYXgMDwmklXmaKxBjZLPHRGOOl8DnSzKTaW8HqKgCEavL7SdclAZK+88sq8sagqdDK3NbwRtbFjx+biTMMNjUmdgcYr67hv5cN1DB48OGxTZwkzZ84MK1gC1RDWwd44+OCDS9dSEqIlpG6nrGPmizHYeeed55/19rn11lvzfe64444Qxqs939NjWid1Vjb03mG+D8brdMrTTz+dx9ElJ11bvMjOO++cp7XO7d6ry8PSPNjr+fz587MHH3wwbBe5+uqr830xOqHPmzcvxA0YMKDumHbcss7t3ksOYYb3JuNW/QqbZtdee22MXRIGC5AmPa9M1grr7f/U/rWLTsPCWbxi0gKMl1dmdMZmarh77rkn7ENndn8PQnceWqHZNvBYWTecYZI33HBDeCW1eFac5HWVrj6EM0fn5MmTQxyNPHTyZn8aZ/gkjOGaX//61/OuQ0CHdYZSMmzRVq5M80D8EUccEV6V6SBPZ3k601NFwPDMMWPGuBNOOCGktf04Hx4w32l0Yt/0mIAHzGs9wx7xHIFrJL+UIekZY8+CZkyCYqtIEm7HwjOdNm1a6JLFEFZ6LTDDFF4mHeXLzitEZ/G/qfCfX3QS79zEreawhzndr/iAF4+ZxqdxCI31YSRNM3kpOz8Uz0HrNd1+EDDEySYLQfCs7hYa5Q3SOCNNUzXPRnv7lJ1XiM6iOs0WwQNaxYyyMCONK8an31PBtM+yfaAYnqZNw420I37a59IEs2y/9HjFOKMYX/ye0l54Ma5ReiFagUSzG5OKRiORaCZNW5Tt05njNUN6/GbPUTW9EB1FoinaxLru0E2pyugeIZZV/D9m1WmKchrVGcqbEz0ZeZqiIWXiKMEUPR15mkIIUQF5mkIIUQGJphBCVECiKYQQFZBoCiFEBSSaQghRAYmmEEJUQKIphBAVkGgKIUQFJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJphBCVECiKYQQFZBoCiFEBSSaQghRAYmmEEJUQKIphBAVkGgKIUQFJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJphBCVECiKYQQTePc/wOcom/ZcMJR9wAAAABJRU5ErkJggg==">
</td>
</tr></tbody></table>

<h3>Summary: <a id="summary" href="#endOfUserArea">Outputs and Result</a><a onclick="Networks.display(true);" href="#Networks"> / Networks</a><a onclick="Nodes.display(true);" href="#Nodes"> / Nodes</a><a onclick="Security.display(true);" href="#Security"> / Security</a><a onclick="Misc.display(true);" href="#Misc"> / Misc</a><a onclick="RedisInstance.display(true);" href="#RedisInstance"> / RedisInstance</a><a onclick="OCSNFpolicy.display(true);" href="#OCSNFpolicy"> / OCSNFpolicy</a><a onclick="MessagingFramework.display(true);" href="#MessagingFramework"> / MessagingFramework</a><a onclick="MessagingFrameworkApplication.display(true);" href="#MessagingFrameworkApplication"> / MessagingFrameworkApplication</a><a onclick="MessagingGateway.display(true);" href="#MessagingGateway"> / MessagingGateway</a><a onclick="MessagingGatewayServices.display(true);" href="#MessagingGatewayServices"> / MessagingGatewayServices</a><a onclick="OCCPcountry.display(true);" href="#OCCPcountry"> / OCCPcountry</a><a onclick="OCCPswitchingPoint.display(true);" href="#OCCPswitchingPoint"> / OCCPswitchingPoint</a><a onclick="OCCPmediaServer.display(true);" href="#OCCPmediaServer"> / OCCPmediaServer</a><a onclick="TCAP.display(true);" href="#TCAP"> / TCAP</a><a onclick="MrfAdapter.display(true);" href="#MrfAdapter"> / MrfAdapter</a><a onclick="Diameter.display(true);" href="#Diameter"> / Diameter</a><a onclick="UcpSmpp.display(true);" href="#UcpSmpp"> / UcpSmpp</a><a onclick="SMPPsession.display(true);" href="#SMPPsession"> / SMPPsession</a><a onclick="SMPPprofile.display(true);" href="#SMPPprofile"> / SMPPprofile</a><a onclick="SMPPpair.display(true);" href="#SMPPpair"> / SMPPpair</a><a onclick="Datasource.display(true);" href="#Datasource"> / Datasource</a><a onclick="LDAPprofile.display(true);" href="#LDAPprofile"> / LDAPprofile</a><a onclick="SOAPconnector.display(true);" href="#SOAPconnector"> / SOAPconnector</a><a onclick="SOAPWebServiceServer.display(true);" href="#SOAPWebServiceServer"> / SOAPWebServiceServer</a><a onclick="SOAPsecurity.display(true);" href="#SOAPsecurity"> / SOAPsecurity</a><a onclick="SOAPWebService.display(true);" href="#SOAPWebService"> / SOAPWebService</a><a onclick="XMLRPCconnector.display(true);" href="#XMLRPCconnector"> / XMLRPCconnector</a><a onclick="XMLRPCService.display(true);" href="#XMLRPCService"> / XMLRPCService</a><a onclick="XMLRPCServer.display(true);" href="#XMLRPCServer"> / XMLRPCServer</a><a onclick="NativeApps.display(true);" href="#NativeApps"> / NativeApps</a><a onclick="WebRTC.display(true);" href="#WebRTC"> / WebRTC</a><a onclick="Licensing.display(true);" href="#Licensing"> / Licensing</a></h3>

<form>
<div id="tableInsertionPoint"><div id="NetworksSection"><a name="Networks"><h2>Networks</h2></a><table id="Networks" border="1"><tbody><tr><th><input onclick="Networks.add();" type="button" value="Add"></th><th class="Networksnetwork" style="width: 80px;">network</th><th class="Networksinterface" style="width: 50px;">interface</th><th class="Networksmask" style="width: 120px;">mask</th></tr><tr><td><input id="delButton1" onclick="Networks.delete('delButton1');" type="button" value="Del"></td><td class="Networksnetwork" style="width: 80px;"><select class="Networksnetwork" style="width: 80px;"><option value="MGMT" selected="selected">MGMT</option><option value="APP">APP</option><option value="SIP">SIP</option><option value="LBNAT">LBNAT</option><option value="PUBLIC">PUBLIC</option><option value="HA">HA</option><option value="DATA">DATA</option><option value="M3UA1">M3UA1</option><option value="M3UA2">M3UA2</option></select></td><td class="Networksinterface" style="width: 50px;"><input class="Networksinterface" style="width: 50px;" type="text" value="eth0"></td><td class="Networksmask" style="width: 120px;"><input class="Networksmask" style="width: 120px;" type="text" value="255.255.248.0"></td></tr></tbody></table><input class="buildButton" onclick="userOutput(Networks.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Networks.help());" type="button" value="Help"></div><div id="NodesSection"><a name="Nodes"><h2>Nodes</h2></a><table id="Nodes" border="1"><tbody><tr><th><input onclick="Nodes.add();" type="button" value="Add"></th><th class="NodesMGMT fqdn" style="width: 85px;">MGMT fqdn</th><th class="NodesMGMT IP addr" style="width: 85px;">MGMT IP addr</th><th class="NodesPUBLIC IP addr" style="width: 85px; display: none;">PUBLIC IP addr</th><th class="NodesVNFC" style="width: 55px;">VNFC</th><th class="NodesReFrsh GRP" style="width: 55px;">ReFrsh GRP</th><th class="NodesMSE EMS" style="width: 15px;">MSE EMS</th><th class="NodesOCMP EMS" style="width: 15px;">OCMP EMS</th><th class="NodesOCSNF EMS" style="width: 15px;">OCSNF EMS</th><th class="NodesUSPM EMS" style="width: 15px;">USPM EMS</th><th class="NodesKPI GUI" style="width: 15px;">KPI GUI</th><th class="NodesCons Stat" style="width: 15px;">Cons Stat</th><th class="NodesWRTC BE" style="width: 15px;">WRTC BE</th><th class="NodesWRTC FE" style="width: 15px;">WRTC FE</th><th class="NodesWRTC Pxy" style="width: 15px;">WRTC Pxy</th><th class="NodesWRTC Trcdr" style="width: 15px;">WRTC Trcdr</th><th class="NodesSEE role" style="width: 55px;">SEE role</th><th class="NodesUSPM role" style="width: 50px;">USPM role</th><th class="NodesHttp LB role" style="width: 50px;">Http LB role</th><th class="NodesOC SNF" style="width: 50px;">OC SNF</th><th class="NodesOCMP role" style="width: 50px;">OCMP role</th><th class="NodesLinux HA role" style="width: 50px;">Linux HA role</th><th class="NodesPgSQL HA" style="width: 50px;">PgSQL HA</th><th class="NodesRedis HA" style="width: 80px;">Redis HA</th><th class="NodesDB role" style="width: 80px;">DB role</th><th class="NodesDB Port" style="width: 85px;">DB Port</th><th class="NodesAPP fqdn" style="width: 85px; display: none;">APP fqdn</th><th class="NodesAPP IP addr" style="width: 85px; display: none;">APP IP addr</th><th class="NodesSIP fqdn" style="width: 85px; display: none;">SIP fqdn</th><th class="NodesSIP IP addr" style="width: 85px; display: none;">SIP IP addr</th><th class="NodesNAT fqdn" style="width: 85px; display: none;">NAT fqdn</th><th class="NodesNAT IP addr" style="width: 85px; display: none;">NAT IP addr</th><th class="NodesHA fqdn" style="width: 85px; display: none;">HA fqdn</th><th class="NodesHA IP addr" style="width: 85px; display: none;">HA IP addr</th><th class="NodesDATA fqdn" style="width: 85px; display: none;">DATA fqdn</th><th class="NodesDATA IP addr" style="width: 85px; display: none;">DATA IP addr</th><th class="NodesM3UA1 fqdn" style="width: 85px; display: none;">M3UA1 fqdn</th><th class="NodesM3UA1 IP addr" style="width: 85px; display: none;">M3UA1 IP addr</th><th class="NodesM3UA2 fqdn" style="width: 85px; display: none;">M3UA2 fqdn</th><th class="NodesM3UA2 IP addr" style="width: 85px; display: none;">M3UA2 IP addr</th></tr><tr><td><input id="delButton1" onclick="Nodes.delete('delButton1');" type="button" value="Del"></td><td class="NodesMGMT fqdn" style="width: 85px;"><input class="NodesMGMT fqdn" style="width: 85px;" type="text" value="pgsql.$(hostname -d)"></td><td class="NodesMGMT IP addr" style="width: 85px;"><input class="NodesMGMT IP addr" style="width: 85px;" dir="ltr" type="text" value="<_%_= node['mse']['map']['pgsql']['ipaddress'] _%_>"></td><td class="NodesPUBLIC IP addr" style="width: 85px; display: none;"><input class="NodesPUBLIC IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesVNFC" style="width: 55px;"><input class="NodesVNFC" style="width: 55px;" type="text" value=""></td><td class="NodesReFrsh GRP" style="width: 55px;"><select class="NodesReFrsh GRP" style="width: 55px;"><option value=""></option><option value="1" selected="selected">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option></select></td><td class="NodesMSE EMS" style="width: 15px;"><input class="NodesMSE EMS" style="width: 15px;" type="checkbox"></td><td class="NodesOCMP EMS" style="width: 15px;"><input class="NodesOCMP EMS" style="width: 15px;" type="checkbox"></td><td class="NodesOCSNF EMS" style="width: 15px;"><input class="NodesOCSNF EMS" style="width: 15px;" type="checkbox"></td><td class="NodesUSPM EMS" style="width: 15px;"><input class="NodesUSPM EMS" style="width: 15px;" type="checkbox"></td><td class="NodesKPI GUI" style="width: 15px;"><input class="NodesKPI GUI" style="width: 15px;" type="checkbox"></td><td class="NodesCons Stat" style="width: 15px;"><input class="NodesCons Stat" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC BE" style="width: 15px;"><input class="NodesWRTC BE" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC FE" style="width: 15px;"><input class="NodesWRTC FE" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC Pxy" style="width: 15px;"><input class="NodesWRTC Pxy" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC Trcdr" style="width: 15px;"><input class="NodesWRTC Trcdr" style="width: 15px;" type="checkbox"></td><td class="NodesSEE role" style="width: 55px;"><select class="NodesSEE role" style="width: 55px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Wit">Wit</option><option value="Nod">Nod</option><option value="N+W">N+W</option></select></td><td class="NodesUSPM role" style="width: 50px;"><select class="NodesUSPM role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="BE">BE</option><option value="Simulap">Simulap</option></select></td><td class="NodesHttp LB role" style="width: 50px;"><select class="NodesHttp LB role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="VIP">VIP</option></select></td><td class="NodesOC SNF" style="width: 50px;"><select class="NodesOC SNF" style="width: 50px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="VIP">VIP</option><option value="Grp0">Grp0</option><option value="Grp1">Grp1</option><option value="Grp2">Grp2</option><option value="Grp3">Grp3</option><option value="Grp4">Grp4</option><option value="Grp5">Grp5</option><option value="Grp6">Grp6</option><option value="Grp7">Grp7</option><option value="Grp8">Grp8</option><option value="Grp9">Grp9</option></select></td><td class="NodesOCMP role" style="width: 50px;"><select class="NodesOCMP role" style="width: 50px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Nod">Nod</option></select></td><td class="NodesLinux HA role" style="width: 50px;"><select class="NodesLinux HA role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Qrm">Qrm</option></select></td><td class="NodesPgSQL HA" style="width: 50px;"><select class="NodesPgSQL HA" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Mstr">Mstr</option></select></td><td class="NodesRedis HA" style="width: 80px;"><select class="NodesRedis HA" style="width: 80px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="ServerSentinel">ServerSentinel</option><option value="Sentinel">Sentinel</option></select></td><td class="NodesDB role" style="width: 80px;"><select class="NodesDB role" style="width: 80px;"><option value=""></option><option value="mysql">mysql</option><option value="pgsql" selected="selected">pgsql</option><option value="redis">redis</option><option value="redisVolatile">redisVolatile</option><option value="redisSpare">redisSpare</option><option value="redisLazy">redisLazy</option><option value="mongo">mongo</option><option value="oracle">oracle</option></select></td><td class="NodesDB Port" style="width: 85px;"><input class="NodesDB Port" style="width: 85px;" type="text" value=""></td><td class="NodesAPP fqdn" style="width: 85px; display: none;"><input class="NodesAPP fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesAPP IP addr" style="width: 85px; display: none;"><input class="NodesAPP IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesSIP fqdn" style="width: 85px; display: none;"><input class="NodesSIP fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesSIP IP addr" style="width: 85px; display: none;"><input class="NodesSIP IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesNAT fqdn" style="width: 85px; display: none;"><input class="NodesNAT fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesNAT IP addr" style="width: 85px; display: none;"><input class="NodesNAT IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesHA fqdn" style="width: 85px; display: none;"><input class="NodesHA fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesHA IP addr" style="width: 85px; display: none;"><input class="NodesHA IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesDATA fqdn" style="width: 85px; display: none;"><input class="NodesDATA fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesDATA IP addr" style="width: 85px; display: none;"><input class="NodesDATA IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA1 fqdn" style="width: 85px; display: none;"><input class="NodesM3UA1 fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA1 IP addr" style="width: 85px; display: none;"><input class="NodesM3UA1 IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA2 fqdn" style="width: 85px; display: none;"><input class="NodesM3UA2 fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA2 IP addr" style="width: 85px; display: none;"><input class="NodesM3UA2 IP addr" style="width: 85px; display: none;" type="text" value=""></td></tr><tr><td><input id="delButton2" onclick="Nodes.delete('delButton2');" type="button" value="Del"></td><td class="NodesMGMT fqdn" style="width: 85px;"><input class="NodesMGMT fqdn" style="width: 85px;" dir="ltr" type="text" value="ems.$(hostname -d)"></td><td class="NodesMGMT IP addr" style="width: 85px;"><input class="NodesMGMT IP addr" style="width: 85px;" type="text" value="<_%_= node['mse']['map']['ems']['ipaddress'] _%_>"></td><td class="NodesPUBLIC IP addr" style="width: 85px; display: none;"><input class="NodesPUBLIC IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesVNFC" style="width: 55px;"><input class="NodesVNFC" style="width: 55px;" type="text" value=""></td><td class="NodesReFrsh GRP" style="width: 55px;"><select class="NodesReFrsh GRP" style="width: 55px;"><option value="" selected="selected"></option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option></select></td><td class="NodesMSE EMS" style="width: 15px;"><input class="NodesMSE EMS" style="width: 15px;" type="checkbox" checked="checked"></td><td class="NodesOCMP EMS" style="width: 15px;"><input class="NodesOCMP EMS" style="width: 15px;" type="checkbox"></td><td class="NodesOCSNF EMS" style="width: 15px;"><input class="NodesOCSNF EMS" style="width: 15px;" type="checkbox"></td><td class="NodesUSPM EMS" style="width: 15px;"><input class="NodesUSPM EMS" style="width: 15px;" type="checkbox"></td><td class="NodesKPI GUI" style="width: 15px;"><input class="NodesKPI GUI" style="width: 15px;" type="checkbox"></td><td class="NodesCons Stat" style="width: 15px;"><input class="NodesCons Stat" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC BE" style="width: 15px;"><input class="NodesWRTC BE" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC FE" style="width: 15px;"><input class="NodesWRTC FE" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC Pxy" style="width: 15px;"><input class="NodesWRTC Pxy" style="width: 15px;" type="checkbox"></td><td class="NodesWRTC Trcdr" style="width: 15px;"><input class="NodesWRTC Trcdr" style="width: 15px;" type="checkbox"></td><td class="NodesSEE role" style="width: 55px;"><select class="NodesSEE role" style="width: 55px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Wit">Wit</option><option value="Nod">Nod</option><option value="N+W">N+W</option></select></td><td class="NodesUSPM role" style="width: 50px;"><select class="NodesUSPM role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="BE">BE</option><option value="Simulap">Simulap</option></select></td><td class="NodesHttp LB role" style="width: 50px;"><select class="NodesHttp LB role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="VIP">VIP</option></select></td><td class="NodesOC SNF" style="width: 50px;"><select class="NodesOC SNF" style="width: 50px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="VIP">VIP</option><option value="Grp0">Grp0</option><option value="Grp1">Grp1</option><option value="Grp2">Grp2</option><option value="Grp3">Grp3</option><option value="Grp4">Grp4</option><option value="Grp5">Grp5</option><option value="Grp6">Grp6</option><option value="Grp7">Grp7</option><option value="Grp8">Grp8</option><option value="Grp9">Grp9</option></select></td><td class="NodesOCMP role" style="width: 50px;"><select class="NodesOCMP role" style="width: 50px;"><option value="" selected="selected"></option><option value="Spx">Spx</option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Nod">Nod</option></select></td><td class="NodesLinux HA role" style="width: 50px;"><select class="NodesLinux HA role" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Qrm">Qrm</option></select></td><td class="NodesPgSQL HA" style="width: 50px;"><select class="NodesPgSQL HA" style="width: 50px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="Mstr">Mstr</option></select></td><td class="NodesRedis HA" style="width: 80px;"><select class="NodesRedis HA" style="width: 80px;"><option value="" selected="selected"></option><option value="Pri">Pri</option><option value="Sec">Sec</option><option value="ServerSentinel">ServerSentinel</option><option value="Sentinel">Sentinel</option></select></td><td class="NodesDB role" style="width: 80px;"><select class="NodesDB role" style="width: 80px;"><option value="" selected="selected"></option><option value="mysql">mysql</option><option value="pgsql">pgsql</option><option value="redis">redis</option><option value="redisVolatile">redisVolatile</option><option value="redisSpare">redisSpare</option><option value="redisLazy">redisLazy</option><option value="mongo">mongo</option><option value="oracle">oracle</option></select></td><td class="NodesDB Port" style="width: 85px;"><input class="NodesDB Port" style="width: 85px;" type="text" value=""></td><td class="NodesAPP fqdn" style="width: 85px; display: none;"><input class="NodesAPP fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesAPP IP addr" style="width: 85px; display: none;"><input class="NodesAPP IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesSIP fqdn" style="width: 85px; display: none;"><input class="NodesSIP fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesSIP IP addr" style="width: 85px; display: none;"><input class="NodesSIP IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesNAT fqdn" style="width: 85px; display: none;"><input class="NodesNAT fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesNAT IP addr" style="width: 85px; display: none;"><input class="NodesNAT IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesHA fqdn" style="width: 85px; display: none;"><input class="NodesHA fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesHA IP addr" style="width: 85px; display: none;"><input class="NodesHA IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesDATA fqdn" style="width: 85px; display: none;"><input class="NodesDATA fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesDATA IP addr" style="width: 85px; display: none;"><input class="NodesDATA IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA1 fqdn" style="width: 85px; display: none;"><input class="NodesM3UA1 fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA1 IP addr" style="width: 85px; display: none;"><input class="NodesM3UA1 IP addr" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA2 fqdn" style="width: 85px; display: none;"><input class="NodesM3UA2 fqdn" style="width: 85px; display: none;" type="text" value=""></td><td class="NodesM3UA2 IP addr" style="width: 85px; display: none;"><input class="NodesM3UA2 IP addr" style="width: 85px; display: none;" type="text" value=""></td></tr></tbody></table><input class="buildButton" onclick="userOutput(Nodes.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Nodes.help());" type="button" value="Help"></div><div id="SecuritySection"><a name="Security"><h2>Security</h2></a><table id="Security" border="1"><tbody><tr><th><input onclick="Security.add();" type="button" value="Add"></th><th class="SecurityProperty" style="width: 400px;">Property</th><th class="SecurityValue" style="width: 400px;">Value</th></tr><tr><td><input id="delButton3" onclick="Security.delete('delButton3');" type="button" value="Del"></td><td class="SecurityProperty" style="width: 400px;"><select class="SecurityProperty" style="width: 400px;"><option value="CERT_AUTH_ALIAS" selected="selected">CERT_AUTH_ALIAS</option><option value="CERT_AUTH_PASSWORD">CERT_AUTH_PASSWORD</option><option value="NIVR_OCADMIN_PASSWORD">NIVR_OCADMIN_PASSWORD</option><option value="NIVRDB_LINUXHA_PASSWORD">NIVRDB_LINUXHA_PASSWORD</option><option value="NIVR_DISABLE_FIREWALL_TOOLS">NIVR_DISABLE_FIREWALL_TOOLS</option><option value="NIVRDB_ADMIN">NIVRDB_ADMIN</option><option value="NIVRDB_ADMIN_PASSWORD">NIVRDB_ADMIN_PASSWORD</option><option value="NIVRDB_APP">NIVRDB_APP</option><option value="NIVRDB_APP_PASSWORD">NIVRDB_APP_PASSWORD</option><option value="NIVRDB_OPER">NIVRDB_OPER</option><option value="NIVRDB_OPER_PASSWORD">NIVRDB_OPER_PASSWORD</option><option value="NIVRDB_SYSDBA">NIVRDB_SYSDBA</option><option value="NIVRDB_SYSDBA_PASSWORD">NIVRDB_SYSDBA_PASSWORD</option><option value="NIVRDB_ORACLE_PASSWORD">NIVRDB_ORACLE_PASSWORD</option></select></td><td class="SecurityValue" style="width: 400px;"><input class="SecurityValue" style="width: 400px;" type="text" value="nfvCert"></td></tr><tr><td><input id="delButton4" onclick="Security.delete('delButton4');" type="button" value="Del"></td><td class="SecurityProperty" style="width: 400px;"><select class="SecurityProperty" style="width: 400px;"><option value="CERT_AUTH_ALIAS">CERT_AUTH_ALIAS</option><option value="CERT_AUTH_PASSWORD" selected="selected">CERT_AUTH_PASSWORD</option><option value="NIVR_OCADMIN_PASSWORD">NIVR_OCADMIN_PASSWORD</option><option value="NIVRDB_LINUXHA_PASSWORD">NIVRDB_LINUXHA_PASSWORD</option><option value="NIVR_DISABLE_FIREWALL_TOOLS">NIVR_DISABLE_FIREWALL_TOOLS</option><option value="NIVRDB_ADMIN">NIVRDB_ADMIN</option><option value="NIVRDB_ADMIN_PASSWORD">NIVRDB_ADMIN_PASSWORD</option><option value="NIVRDB_APP">NIVRDB_APP</option><option value="NIVRDB_APP_PASSWORD">NIVRDB_APP_PASSWORD</option><option value="NIVRDB_OPER">NIVRDB_OPER</option><option value="NIVRDB_OPER_PASSWORD">NIVRDB_OPER_PASSWORD</option><option value="NIVRDB_SYSDBA">NIVRDB_SYSDBA</option><option value="NIVRDB_SYSDBA_PASSWORD">NIVRDB_SYSDBA_PASSWORD</option><option value="NIVRDB_ORACLE_PASSWORD">NIVRDB_ORACLE_PASSWORD</option></select></td><td class="SecurityValue" style="width: 400px;"><input class="SecurityValue" style="width: 400px;" type="text" value="nfvCert"></td></tr><tr><td><input id="delButton3" onclick="Security.delete('delButton3');" type="button" value="Del"></td><td class="SecurityProperty" style="width: 400px;"><select class="SecurityProperty" style="width: 400px;"><option value="CERT_AUTH_ALIAS">CERT_AUTH_ALIAS</option><option value="CERT_AUTH_PASSWORD">CERT_AUTH_PASSWORD</option><option value="NIVR_OCADMIN_PASSWORD">NIVR_OCADMIN_PASSWORD</option><option value="NIVRDB_LINUXHA_PASSWORD" selected="selected">NIVRDB_LINUXHA_PASSWORD</option><option value="NIVR_DISABLE_FIREWALL_TOOLS">NIVR_DISABLE_FIREWALL_TOOLS</option><option value="NIVRDB_ADMIN">NIVRDB_ADMIN</option><option value="NIVRDB_ADMIN_PASSWORD">NIVRDB_ADMIN_PASSWORD</option><option value="NIVRDB_APP">NIVRDB_APP</option><option value="NIVRDB_APP_PASSWORD">NIVRDB_APP_PASSWORD</option><option value="NIVRDB_OPER">NIVRDB_OPER</option><option value="NIVRDB_OPER_PASSWORD">NIVRDB_OPER_PASSWORD</option><option value="NIVRDB_SYSDBA">NIVRDB_SYSDBA</option><option value="NIVRDB_SYSDBA_PASSWORD">NIVRDB_SYSDBA_PASSWORD</option><option value="NIVRDB_ORACLE_PASSWORD">NIVRDB_ORACLE_PASSWORD</option></select></td><td class="SecurityValue" style="width: 400px;"><input class="SecurityValue" style="width: 400px;" type="text" value="hacluster"></td></tr></tbody></table><input class="buildButton" onclick="userOutput(Security.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Security.help());" type="button" value="Help"></div><div id="MiscSection"><a name="Misc"><h2>Misc</h2></a><table id="Misc" border="1"><tbody><tr><th><input onclick="Misc.add();" type="button" value="Add"></th><th class="MiscProperty" style="width: 400px;">Property</th><th class="MiscValue" style="width: 400px;">Value</th></tr><tr><td><input id="delButton5" onclick="Misc.delete('delButton5');" type="button" value="Del"></td><td class="MiscProperty" style="width: 400px;"><select class="MiscProperty" style="width: 400px;"><option value="DEFAULT_GATEWAY_IP_ADDR">DEFAULT_GATEWAY_IP_ADDR</option><option value="SIP_DEFAULT_GATEWAY_IP_ADDR">SIP_DEFAULT_GATEWAY_IP_ADDR</option><option value="SNMP_TRAP_DESTINATION" selected="selected">SNMP_TRAP_DESTINATION</option><option value="SNMP_TRAP_COMMUNITY">SNMP_TRAP_COMMUNITY</option><option value="SEE_INSTANCES_MAX">SEE_INSTANCES_MAX</option><option value="VNF_CONFIG_DATA_FILE">VNF_CONFIG_DATA_FILE</option><option value="NIVR_OTHER_HOSTS">NIVR_OTHER_HOSTS</option><option value="REDIS_SENTINEL_PORT_OFFSET">REDIS_SENTINEL_PORT_OFFSET</option><option value="REDIS_DOWNAFTER">REDIS_DOWNAFTER</option><option value="REDIS_PARALLEL_SYNCS">REDIS_PARALLEL_SYNCS</option><option value="REDIS_FAILOVER_TIMEOUT">REDIS_FAILOVER_TIMEOUT</option><option value="ORACLE_SERVICE">ORACLE_SERVICE</option><option value="ORACLE_CONSOLE_PORT">ORACLE_CONSOLE_PORT</option><option value="ORACLE_PATH">ORACLE_PATH</option><option value="YUM_REPO_LIST">YUM_REPO_LIST</option><option value="HA_PING_IP_ADDR">HA_PING_IP_ADDR</option><option value="COROSYNC_UNICAST">COROSYNC_UNICAST</option><option value="NFVD_ADDR">NFVD_ADDR</option><option value="NFVD_TENANT_NAME">NFVD_TENANT_NAME</option><option value="NFVD_APPLICATION">NFVD_APPLICATION</option><option value="NFVD_DATACENTER">NFVD_DATACENTER</option><option value="NFVD_USERNAME">NFVD_USERNAME</option><option value="NFVD_PASSWORD">NFVD_PASSWORD</option><option value="NFVD_STACK_NAME">NFVD_STACK_NAME</option><option value="NFVD_REST_ADDR">NFVD_REST_ADDR</option><option value="NFVD_SCALING_TEMPLATE">NFVD_SCALING_TEMPLATE</option><option value="NIVR_SCALING_ROLE">NIVR_SCALING_ROLE</option><option value="VNF_RETRY_POLICY_MAX_TIMEOUT">VNF_RETRY_POLICY_MAX_TIMEOUT</option></select></td><td class="MiscValue" style="width: 400px;"><input class="MiscValue" style="width: 400px;" type="text" value="${NIVR_EMS_IP_ADDR}"></td></tr><tr><td><input id="delButton1" onclick="Misc.delete('delButton1');" type="button" value="Del"></td><td class="MiscProperty" style="width: 400px;"><select class="MiscProperty" style="width: 400px;"><option value="DEFAULT_GATEWAY_IP_ADDR">DEFAULT_GATEWAY_IP_ADDR</option><option value="SIP_DEFAULT_GATEWAY_IP_ADDR">SIP_DEFAULT_GATEWAY_IP_ADDR</option><option value="SNMP_TRAP_DESTINATION">SNMP_TRAP_DESTINATION</option><option value="SNMP_TRAP_COMMUNITY">SNMP_TRAP_COMMUNITY</option><option value="SEE_INSTANCES_MAX">SEE_INSTANCES_MAX</option><option value="VNF_CONFIG_DATA_FILE">VNF_CONFIG_DATA_FILE</option><option value="NIVR_OTHER_HOSTS">NIVR_OTHER_HOSTS</option><option value="REDIS_SENTINEL_PORT_OFFSET">REDIS_SENTINEL_PORT_OFFSET</option><option value="REDIS_DOWNAFTER">REDIS_DOWNAFTER</option><option value="REDIS_PARALLEL_SYNCS">REDIS_PARALLEL_SYNCS</option><option value="REDIS_FAILOVER_TIMEOUT">REDIS_FAILOVER_TIMEOUT</option><option value="ORACLE_SERVICE">ORACLE_SERVICE</option><option value="ORACLE_CONSOLE_PORT">ORACLE_CONSOLE_PORT</option><option value="ORACLE_PATH">ORACLE_PATH</option><option value="YUM_REPO_LIST" selected="selected">YUM_REPO_LIST</option><option value="HA_PING_IP_ADDR">HA_PING_IP_ADDR</option><option value="COROSYNC_UNICAST">COROSYNC_UNICAST</option><option value="NFVD_ADDR">NFVD_ADDR</option><option value="NFVD_TENANT_NAME">NFVD_TENANT_NAME</option><option value="NFVD_APPLICATION">NFVD_APPLICATION</option><option value="NFVD_DATACENTER">NFVD_DATACENTER</option><option value="NFVD_USERNAME">NFVD_USERNAME</option><option value="NFVD_PASSWORD">NFVD_PASSWORD</option><option value="NFVD_STACK_NAME">NFVD_STACK_NAME</option><option value="NFVD_REST_ADDR">NFVD_REST_ADDR</option><option value="NFVD_SCALING_TEMPLATE">NFVD_SCALING_TEMPLATE</option><option value="NIVR_SCALING_ROLE">NIVR_SCALING_ROLE</option><option value="VNF_RETRY_POLICY_MAX_TIMEOUT">VNF_RETRY_POLICY_MAX_TIMEOUT</option></select></td><td class="MiscValue" style="width: 400px;"><input class="MiscValue" style="width: 400px;" type="text" value="centos*,updates*,base*"></td></tr></tbody></table><input class="buildButton" onclick="userOutput(Misc.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Misc.help());" type="button" value="Help"></div><div id="RedisInstanceSection" style="display: none;"><a name="RedisInstance"><h2>RedisInstance</h2></a><table id="RedisInstance" border="1"><tbody><tr><th><input onclick="RedisInstance.add();" type="button" value="Add"></th><th class="RedisInstanceVNFC" style="width: 55px;">VNFC</th><th class="RedisInstanceName" style="width: 80px;">Name</th><th class="RedisInstanceMode" style="width: 80px;">Mode</th><th class="RedisInstanceInstance Port" style="width: 50px;">Instance Port</th><th class="RedisInstanceSentinel Port" style="width: 50px;">Sentinel Port</th></tr></tbody></table><input class="buildButton" onclick="userOutput(RedisInstance.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(RedisInstance.help());" type="button" value="Help"></div><div id="OCSNFpolicySection" style="display: none;"><a name="OCSNFpolicy"><h2>OCSNFpolicy</h2></a><table id="OCSNFpolicy" border="1"><tbody><tr><th><input onclick="OCSNFpolicy.add();" type="button" value="Add"></th><th class="OCSNFpolicyRange" style="width: 50px;">Range</th><th class="OCSNFpolicyAlgorithm" style="width: 120px;">Algorithm</th><th class="OCSNFpolicyPort" style="width: 80px;">Port</th><th class="OCSNFpolicyService" style="width: 80px;">Service</th><th class="OCSNFpolicy1st" style="width: 50px;">1st</th><th class="OCSNFpolicy2nd" style="width: 50px;">2nd</th><th class="OCSNFpolicy3rd" style="width: 50px;">3rd</th><th class="OCSNFpolicy4th" style="width: 50px;">4th</th><th class="OCSNFpolicy5th" style="width: 50px;">5th</th><th class="OCSNFpolicy6th" style="width: 50px;">6th</th><th class="OCSNFpolicyPattern A" style="width: 300px;">Pattern A</th><th class="OCSNFpolicyOperator" style="width: 50px;">Operator</th><th class="OCSNFpolicyPattern B" style="width: 300px;">Pattern B</th></tr></tbody></table><input class="buildButton" onclick="userOutput(OCSNFpolicy.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(OCSNFpolicy.help());" type="button" value="Help"></div><div id="MessagingFrameworkSection" style="display: none;"><a name="MessagingFramework"><h2>MessagingFramework</h2></a><table id="MessagingFramework" border="1"><tbody><tr><th><input onclick="MessagingFramework.add();" type="button" value="Add"></th><th class="MessagingFrameworkProperty" style="width: 250px;">Property</th><th class="MessagingFrameworkValue" style="width: 600px;">Value</th></tr></tbody></table><input class="buildButton" onclick="userOutput(MessagingFramework.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(MessagingFramework.help());" type="button" value="Help"></div><div id="MessagingFrameworkApplicationSection" style="display: none;"><a name="MessagingFrameworkApplication"><h2>MessagingFrameworkApplication</h2></a><table id="MessagingFrameworkApplication" border="1"><tbody><tr><th><input onclick="MessagingFrameworkApplication.add();" type="button" value="Add"></th><th class="MessagingFrameworkApplicationName" style="width: 200px;">Name</th><th class="MessagingFrameworkApplicationType" style="width: 200px;">Type</th><th class="MessagingFrameworkApplicationBase" style="width: 400px;">Base</th><th class="MessagingFrameworkApplicationDiameter" style="width: 200px;">Diameter</th><th class="MessagingFrameworkApplicationConfiguration" style="width: 400px;">Configuration</th></tr></tbody></table><input class="buildButton" onclick="userOutput(MessagingFrameworkApplication.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(MessagingFrameworkApplication.help());" type="button" value="Help"></div><div id="MessagingGatewaySection" style="display: none;"><a name="MessagingGateway"><h2>MessagingGateway</h2></a><table id="MessagingGateway" border="1"><tbody><tr><th><input onclick="MessagingGateway.add();" type="button" value="Add"></th><th class="MessagingGatewayProperty" style="width: 250px;">Property</th><th class="MessagingGatewayValue" style="width: 400px;">Value</th></tr></tbody></table><input class="buildButton" onclick="userOutput(MessagingGateway.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(MessagingGateway.help());" type="button" value="Help"></div><div id="MessagingGatewayServicesSection" style="display: none;"><a name="MessagingGatewayServices"><h2>MessagingGatewayServices</h2></a><table id="MessagingGatewayServices" border="1"><tbody><tr><th><input onclick="MessagingGatewayServices.add();" type="button" value="Add"></th><th class="MessagingGatewayServicesType" style="width: 80px;">Type</th><th class="MessagingGatewayServicesName">Name</th><th class="MessagingGatewayServicesUser" style="width: 80px;">User</th><th class="MessagingGatewayServicesPassword" style="width: 80px;">Password</th><th class="MessagingGatewayServicesCode" style="width: 120px;">Code</th><th class="MessagingGatewayServicesService Path" style="width: 400px;">Service Path</th></tr></tbody></table><input class="buildButton" onclick="userOutput(MessagingGatewayServices.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(MessagingGatewayServices.help());" type="button" value="Help"></div><div id="OCCPcountrySection" style="display: none;"><a name="OCCPcountry"><h2>OCCPcountry</h2></a><table id="OCCPcountry" border="1"><tbody><tr><th><input onclick="OCCPcountry.add();" type="button" value="Add"></th><th class="OCCPcountryName" style="width: 85px;">Name</th><th class="OCCPcountryCode" style="width: 85px;">Code</th><th class="OCCPcountryPrefix" style="width: 85px;">Prefix</th><th class="OCCPcountryInternational" style="width: 85px;">International</th></tr></tbody></table><input class="buildButton" onclick="userOutput(OCCPcountry.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(OCCPcountry.help());" type="button" value="Help"></div><div id="OCCPswitchingPointSection" style="display: none;"><a name="OCCPswitchingPoint"><h2>OCCPswitchingPoint</h2></a><table id="OCCPswitchingPoint" border="1"><tbody><tr><th><input onclick="OCCPswitchingPoint.add();" type="button" value="Add"></th><th class="OCCPswitchingPointName" style="width: 85px;">Name</th><th class="OCCPswitchingPointCountry" style="width: 85px;">Country</th><th class="OCCPswitchingPointOperator" style="width: 85px;">Operator</th><th class="OCCPswitchingPointDigits" style="width: 85px;">Digits</th><th class="OCCPswitchingPointTCAP flavor" style="width: 60px;">TCAP flavor</th><th class="OCCPswitchingPointSCCP flavor" style="width: 60px;">SCCP flavor</th><th class="OCCPswitchingPointSSN" style="width: 85px;">SSN</th><th class="OCCPswitchingPointPoint Code" style="width: 85px;">Point Code</th><th class="OCCPswitchingPointProtocol" style="width: 90px;">Protocol</th></tr></tbody></table><input class="buildButton" onclick="userOutput(OCCPswitchingPoint.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(OCCPswitchingPoint.help());" type="button" value="Help"></div><div id="OCCPmediaServerSection" style="display: none;"><a name="OCCPmediaServer"><h2>OCCPmediaServer</h2></a><table id="OCCPmediaServer" border="1"><tbody><tr><th><input onclick="OCCPmediaServer.add();" type="button" value="Add"></th><th class="OCCPmediaServerName" style="width: 85px;">Name</th><th class="OCCPmediaServerCountry" style="width: 85px;">Country</th><th class="OCCPmediaServerOperator" style="width: 85px;">Operator</th><th class="OCCPmediaServerMode" style="width: 90px;">Mode</th><th class="OCCPmediaServerType" style="width: 120px;">Type</th><th class="OCCPmediaServerSIP URI" style="width: 120px;">SIP URI</th><th class="OCCPmediaServerNAI" style="width: 120px;">NAI</th><th class="OCCPmediaServerNPI" style="width: 90px;">NPI</th><th class="OCCPmediaServerAddress" style="width: 85px;">Address</th><th class="OCCPmediaServerSwitching point" style="width: 85px;">Switching point</th><th class="OCCPmediaServerWeight" style="width: 50px;">Weight</th><th class="OCCPmediaServerOCMP" style="width: 15px;">OCMP</th><th class="OCCPmediaServerTCAP flavor" style="width: 60px;">TCAP flavor</th><th class="OCCPmediaServerSCCP flavor" style="width: 60px;">SCCP flavor</th><th class="OCCPmediaServerSSN" style="width: 85px;">SSN</th><th class="OCCPmediaServerPoint Code" style="width: 85px;">Point Code</th><th class="OCCPmediaServerProtocol" style="width: 90px;">Protocol</th></tr></tbody></table><input class="buildButton" onclick="userOutput(OCCPmediaServer.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(OCCPmediaServer.help());" type="button" value="Help"></div><div id="TCAPSection" style="display: none;"><a name="TCAP"><h2>TCAP</h2></a><table id="TCAP" border="1"><tbody><tr><th><input onclick="TCAP.add();" type="button" value="Add"></th><th class="TCAPVNFC" style="width: 85px;">VNFC</th><th class="TCAPProvider name" style="width: 150px;">Provider name</th><th class="TCAPService name" style="width: 200px;">Service name</th><th class="TCAPInstance Id" style="width: 85px;">Instance Id</th><th class="TCAPApp Id" style="width: 85px;">App Id</th><th class="TCAPSS7 stack" style="width: 85px;">SS7 stack</th><th class="TCAPFlavor" style="width: 85px;">Flavor</th><th class="TCAPSCCP flavor" style="width: 85px;">SCCP flavor</th><th class="TCAPSSN" style="width: 85px;">SSN</th><th class="TCAPPoint code" style="width: 85px;">Point code</th><th class="TCAPApp base" style="width: 250px;">App base</th></tr></tbody></table><input class="buildButton" onclick="userOutput(TCAP.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(TCAP.help());" type="button" value="Help"></div><div id="MrfAdapterSection" style="display: none;"><a name="MrfAdapter"><h2>MrfAdapter</h2></a><table id="MrfAdapter" border="1"><tbody><tr><th><input onclick="MrfAdapter.add();" type="button" value="Add"></th><th class="MrfAdapterVNFC" style="width: 85px;">VNFC</th><th class="MrfAdapterType" style="width: 90px;">Type</th><th class="MrfAdapterName" style="width: 90px;">Name</th><th class="MrfAdapterTransport" style="width: 50px;">Transport</th><th class="MrfAdapterInstance Id" style="width: 50px;">Instance Id</th><th class="MrfAdapterAddress" style="width: 200px;">Address</th><th class="MrfAdapterPort" style="width: 50px;">Port</th><th class="MrfAdapterMRF URI" style="width: 150px;">MRF URI</th><th class="MrfAdapterProvisioning" style="width: 150px;">Provisioning</th><th class="MrfAdapterRedis instance" style="width: 50px;">Redis instance</th><th class="MrfAdapterRedis password" style="width: 50px;">Redis password</th><th class="MrfAdapterRedis hosts&amp;ports" style="width: 200px;">Redis hosts&amp;ports</th><th class="MrfAdapterResource URL" style="width: 150px;">Resource URL</th><th class="MrfAdapterTenants" style="width: 150px;">Tenants</th></tr></tbody></table><input class="buildButton" onclick="userOutput(MrfAdapter.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(MrfAdapter.help());" type="button" value="Help"></div><div id="DiameterSection" style="display: none;"><a name="Diameter"><h2>Diameter</h2></a><table id="Diameter" border="1"><tbody><tr><th><input onclick="Diameter.add();" type="button" value="Add"></th><th class="DiameterVNFC" style="width: 85px;">VNFC</th><th class="DiameterName" style="width: 85px;">Name</th><th class="DiameterType" style="width: 60px;">Type</th><th class="DiameterInstance Id" style="width: 60px;">Instance Id</th><th class="DiameterTransp." style="width: 60px;">Transp.</th><th class="DiameterServers addresses" style="width: 120px;">Servers addresses</th><th class="DiameterServers Ports" style="width: 120px;">Servers Ports</th><th class="DiameterServers Realms" style="width: 120px;">Servers Realms</th><th class="DiameterRemote addresses" style="width: 120px;">Remote addresses</th><th class="DiameterRemote ports" style="width: 120px;">Remote ports</th><th class="DiameterRemote realms" style="width: 120px;">Remote realms</th><th class="DiameterPriority" style="width: 60px;">Priority</th></tr></tbody></table><input class="buildButton" onclick="userOutput(Diameter.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Diameter.help());" type="button" value="Help"></div><div id="UcpSmppSection" style="display: none;"><a name="UcpSmpp"><h2>UcpSmpp</h2></a><table id="UcpSmpp" border="1"><tbody><tr><th><input onclick="UcpSmpp.add();" type="button" value="Add"></th><th class="UcpSmppVNFC" style="width: 85px;">VNFC</th><th class="UcpSmppType" style="width: 90px;">Type</th><th class="UcpSmppName" style="width: 90px;">Name</th><th class="UcpSmppAddress" style="width: 200px;">Address</th><th class="UcpSmppPort" style="width: 90px;">Port</th></tr></tbody></table><input class="buildButton" onclick="userOutput(UcpSmpp.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(UcpSmpp.help());" type="button" value="Help"></div><div id="SMPPsessionSection" style="display: none;"><a name="SMPPsession"><h2>SMPPsession</h2></a><table id="SMPPsession" border="1"><tbody><tr><th><input onclick="SMPPsession.add();" type="button" value="Add"></th><th class="SMPPsessionVNFC" style="width: 85px;">VNFC</th><th class="SMPPsessionName" style="width: 90px;">Name</th><th class="SMPPsessionService" style="width: 90px;">Service</th><th class="SMPPsessionInstance Id" style="width: 60px;">Instance Id</th><th class="SMPPsessionProvider" style="width: 90px;">Provider</th><th class="SMPPsessionConnector" style="width: 90px;">Connector</th><th class="SMPPsessionHost" style="width: 90px;">Host</th><th class="SMPPsessionPort" style="width: 90px;">Port</th><th class="SMPPsessionSystem Id" style="width: 90px;">System Id</th><th class="SMPPsessionPassword" style="width: 90px;">Password</th><th class="SMPPsessionBindMode" style="width: 90px;">BindMode</th><th class="SMPPsessionSystemType" style="width: 90px;">SystemType</th><th class="SMPPsessionInterface" style="width: 90px;">Interface</th><th class="SMPPsessionConnTimeout" style="width: 90px;">ConnTimeout</th><th class="SMPPsessionBindTimeout" style="width: 90px;">BindTimeout</th><th class="SMPPsessionWaitTimeout" style="width: 90px;">WaitTimeout</th><th class="SMPPsessionMonitorInt" style="width: 90px;">MonitorInt</th><th class="SMPPsessionUse SSL" style="width: 90px;">Use SSL</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SMPPsession.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SMPPsession.help());" type="button" value="Help"></div><div id="SMPPprofileSection" style="display: none;"><a name="SMPPprofile"><h2>SMPPprofile</h2></a><table id="SMPPprofile" border="1"><tbody><tr><th><input onclick="SMPPprofile.add();" type="button" value="Add"></th><th class="SMPPprofileVNFC" style="width: 85px;">VNFC</th><th class="SMPPprofileName" style="width: 90px;">Name</th><th class="SMPPprofileConnector" style="width: 100px;">Connector</th><th class="SMPPprofileProfile Id" style="width: 60px;">Profile Id</th><th class="SMPPprofileDest Add" style="width: 90px;">Dest Add</th><th class="SMPPprofileEncoding" style="width: 60px;">Encoding</th><th class="SMPPprofileData coding" style="width: 60px;">Data coding</th><th class="SMPPprofileESM class" style="width: 60px;">ESM class</th><th class="SMPPprofileProtocol Id" style="width: 60px;">Protocol Id</th><th class="SMPPprofileTimeout" style="width: 60px;">Timeout</th><th class="SMPPprofileSource Add" style="width: 90px;">Source Add</th><th class="SMPPprofileSource TON" style="width: 90px;">Source TON</th><th class="SMPPprofileNPI" style="width: 90px;">NPI</th><th class="SMPPprofileDest TON" style="width: 90px;">Dest TON</th><th class="SMPPprofileService type" style="width: 90px;">Service type</th><th class="SMPPprofilePriority" style="width: 90px;">Priority</th><th class="SMPPprofileDelivery" style="width: 90px;">Delivery</th><th class="SMPPprofileResponse policy" style="width: 90px;">Response policy</th><th class="SMPPprofileBalancing policy" style="width: 15px;">Balancing policy</th><th class="SMPPprofileValidity period" style="width: 90px;">Validity period</th><th class="SMPPprofileURL" style="width: 130px;">URL</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SMPPprofile.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SMPPprofile.help());" type="button" value="Help"></div><div id="SMPPpairSection" style="display: none;"><a name="SMPPpair"><h2>SMPPpair</h2></a><table id="SMPPpair" border="1"><tbody><tr><th><input onclick="SMPPpair.add();" type="button" value="Add"></th><th class="SMPPpairVNFC" style="width: 85px;">VNFC</th><th class="SMPPpairName" style="width: 90px;">Name</th><th class="SMPPpairProvider" style="width: 90px;">Provider</th><th class="SMPPpairProfile" style="width: 90px;">Profile</th><th class="SMPPpairConnector" style="width: 90px;">Connector</th><th class="SMPPpairPrimary" style="width: 90px;">Primary</th><th class="SMPPpairSecondary" style="width: 90px;">Secondary</th><th class="SMPPpairWeight" style="width: 60px;">Weight</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SMPPpair.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SMPPpair.help());" type="button" value="Help"></div><div id="DatasourceSection" style="display: none;"><a name="Datasource"><h2>Datasource</h2></a><table id="Datasource" border="1"><tbody><tr><th><input onclick="Datasource.add();" type="button" value="Add"></th><th class="DatasourceVNFC" style="width: 85px;">VNFC</th><th class="DatasourceType" style="width: 90px;">Type</th><th class="DatasourceName" style="width: 90px;">Name</th><th class="DatasourceService" style="width: 90px;">Service</th><th class="DatasourceUser" style="width: 90px;">User</th><th class="DatasourcePassword" style="width: 90px;">Password</th><th class="DatasourceInstance Id" style="width: 90px;">Instance Id</th><th class="DatasourceURL" style="width: 250px;">URL</th><th class="DatasourceDocument" style="width: 250px;">Document</th><th class="DatasourceAutoDetect" style="width: 90px;">AutoDetect</th><th class="DatasourceAuthMode" style="width: 100px;">AuthMode</th><th class="DatasourceDriver" style="width: 250px;">Driver</th></tr></tbody></table><input class="buildButton" onclick="userOutput(Datasource.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Datasource.help());" type="button" value="Help"></div><div id="LDAPprofileSection" style="display: none;"><a name="LDAPprofile"><h2>LDAPprofile</h2></a><table id="LDAPprofile" border="1"><tbody><tr><th><input onclick="LDAPprofile.add();" type="button" value="Add"></th><th class="LDAPprofileVNFC" style="width: 85px;">VNFC</th><th class="LDAPprofileName" style="width: 90px;">Name</th><th class="LDAPprofileData source" style="width: 90px;">Data source</th><th class="LDAPprofileBase DN" style="width: 200px;">Base DN</th><th class="LDAPprofileScope" style="width: 90px;">Scope</th><th class="LDAPprofileTime limit" style="width: 90px;">Time limit</th><th class="LDAPprofileFilter" style="width: 400px;">Filter</th></tr></tbody></table><input class="buildButton" onclick="userOutput(LDAPprofile.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(LDAPprofile.help());" type="button" value="Help"></div><div id="SOAPconnectorSection" style="display: none;"><a name="SOAPconnector"><h2>SOAPconnector</h2></a><table id="SOAPconnector" border="1"><tbody><tr><th><input onclick="SOAPconnector.add();" type="button" value="Add"></th><th class="SOAPconnectorVNFC" style="width: 85px;">VNFC</th><th class="SOAPconnectorName" style="width: 90px;">Name</th><th class="SOAPconnectorInstance Id" style="width: 90px;">Instance Id</th><th class="SOAPconnectorRequest validation" style="width: 90px;">Request validation</th><th class="SOAPconnectorResponse validation" style="width: 90px;">Response validation</th><th class="SOAPconnectorTimeout" style="width: 90px;">Timeout</th><th class="SOAPconnectorRemove empty header" style="width: 90px;">Remove empty header</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SOAPconnector.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SOAPconnector.help());" type="button" value="Help"></div><div id="SOAPWebServiceServerSection" style="display: none;"><a name="SOAPWebServiceServer"><h2>SOAPWebServiceServer</h2></a><table id="SOAPWebServiceServer" border="1"><tbody><tr><th><input onclick="SOAPWebServiceServer.add();" type="button" value="Add"></th><th class="SOAPWebServiceServerVNFC" style="width: 85px;">VNFC</th><th class="SOAPWebServiceServerName" style="width: 90px;">Name</th><th class="SOAPWebServiceServerHostname" style="width: 200px;">Hostname</th><th class="SOAPWebServiceServerProtocol" style="width: 90px;">Protocol</th><th class="SOAPWebServiceServerService Port" style="width: 90px;">Service Port</th><th class="SOAPWebServiceServerWSDL port" style="width: 90px;">WSDL port</th><th class="SOAPWebServiceServerRetry URL timeout" style="width: 90px;">Retry URL timeout</th><th class="SOAPWebServiceServerMax connections" style="width: 90px;">Max connections</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SOAPWebServiceServer.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SOAPWebServiceServer.help());" type="button" value="Help"></div><div id="SOAPsecuritySection" style="display: none;"><a name="SOAPsecurity"><h2>SOAPsecurity</h2></a><table id="SOAPsecurity" border="1"><tbody><tr><th><input onclick="SOAPsecurity.add();" type="button" value="Add"></th><th class="SOAPsecurityVNFC" style="width: 85px;">VNFC</th><th class="SOAPsecurityName" style="width: 90px;">Name</th><th class="SOAPsecurityUser" style="width: 90px;">User</th><th class="SOAPsecurityPassword" style="width: 90px;">Password</th><th class="SOAPsecurityKeystore" style="width: 300px;">Keystore</th><th class="SOAPsecurityKeystore password" style="width: 90px;">Keystore password</th><th class="SOAPsecurityPublic key" style="width: 90px;">Public key</th><th class="SOAPsecurityPrivate key" style="width: 90px;">Private key</th><th class="SOAPsecurityPrivate key password" style="width: 90px;">Private key password</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SOAPsecurity.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SOAPsecurity.help());" type="button" value="Help"></div><div id="SOAPWebServiceSection" style="display: none;"><a name="SOAPWebService"><h2>SOAPWebService</h2></a><table id="SOAPWebService" border="1"><tbody><tr><th><input onclick="SOAPWebService.add();" type="button" value="Add"></th><th class="SOAPWebServiceVNFC" style="width: 85px;">VNFC</th><th class="SOAPWebServiceName" style="width: 90px;">Name</th><th class="SOAPWebServiceServers" style="width: 200px;">Servers</th><th class="SOAPWebServiceWSDL Servers" style="width: 200px;">WSDL Servers</th><th class="SOAPWebServiceName space" style="width: 200px;">Name space</th><th class="SOAPWebServiceWSDL URL suffix" style="width: 200px;">WSDL URL suffix</th><th class="SOAPWebServiceService URL suffix" style="width: 200px;">Service URL suffix</th><th class="SOAPWebServiceSecurity policy" style="width: 90px;">Security policy</th><th class="SOAPWebServiceProbe URL timeout" style="width: 90px;">Probe URL timeout</th><th class="SOAPWebServiceRetry URL timeout" style="width: 90px;">Retry URL timeout</th><th class="SOAPWebServiceInclude header" style="width: 90px;">Include header</th><th class="SOAPWebServiceInclude namespace" style="width: 90px;">Include namespace</th><th class="SOAPWebServiceResponse remove" style="width: 90px;">Response remove</th><th class="SOAPWebServiceError code translation" style="width: 90px;">Error code translation</th></tr></tbody></table><input class="buildButton" onclick="userOutput(SOAPWebService.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(SOAPWebService.help());" type="button" value="Help"></div><div id="XMLRPCconnectorSection" style="display: none;"><a name="XMLRPCconnector"><h2>XMLRPCconnector</h2></a><table id="XMLRPCconnector" border="1"><tbody><tr><th><input onclick="XMLRPCconnector.add();" type="button" value="Add"></th><th class="XMLRPCconnectorVNFC" style="width: 85px;">VNFC</th><th class="XMLRPCconnectorName" style="width: 90px;">Name</th><th class="XMLRPCconnectorInstance Id" style="width: 90px;">Instance Id</th></tr></tbody></table><input class="buildButton" onclick="userOutput(XMLRPCconnector.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(XMLRPCconnector.help());" type="button" value="Help"></div><div id="XMLRPCServiceSection" style="display: none;"><a name="XMLRPCService"><h2>XMLRPCService</h2></a><table id="XMLRPCService" border="1"><tbody><tr><th><input onclick="XMLRPCService.add();" type="button" value="Add"></th><th class="XMLRPCServiceVNFC" style="width: 85px;">VNFC</th><th class="XMLRPCServiceName" style="width: 90px;">Name</th><th class="XMLRPCServiceType" style="width: 60px;">Type</th><th class="XMLRPCServiceSchema" style="width: 350px;">Schema</th><th class="XMLRPCServiceProbe timeout" style="width: 60px;">Probe timeout</th><th class="XMLRPCServiceRetry timeout" style="width: 60px;">Retry timeout</th><th class="XMLRPCServiceMax connections" style="width: 60px;">Max connections</th><th class="XMLRPCServiceProbe operation" style="width: 150px;">Probe operation</th><th class="XMLRPCServiceProbe origin type" style="width: 60px;">Probe origin type</th><th class="XMLRPCServiceProbe origin host" style="width: 60px;">Probe origin host</th><th class="XMLRPCServiceProbe origin transaction ID" style="width: 60px;">Probe origin transaction ID</th><th class="XMLRPCServiceProbe origin timestamp" style="width: 150px;">Probe origin timestamp</th><th class="XMLRPCServiceProbe subscriber number" style="width: 85px;">Probe subscriber number</th><th class="XMLRPCServiceProbe serial number" style="width: 85px;">Probe serial number</th><th class="XMLRPCServiceProbe SOB" style="width: 60px;">Probe SOB</th></tr></tbody></table><input class="buildButton" onclick="userOutput(XMLRPCService.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(XMLRPCService.help());" type="button" value="Help"></div><div id="XMLRPCServerSection" style="display: none;"><a name="XMLRPCServer"><h2>XMLRPCServer</h2></a><table id="XMLRPCServer" border="1"><tbody><tr><th><input onclick="XMLRPCServer.add();" type="button" value="Add"></th><th class="XMLRPCServerVNFC" style="width: 85px;">VNFC</th><th class="XMLRPCServerService" style="width: 90px;">Service</th><th class="XMLRPCServerConnection" style="width: 90px;">Connection</th><th class="XMLRPCServerAddress" style="width: 90px;">Address</th><th class="XMLRPCServerPort" style="width: 90px;">Port</th><th class="XMLRPCServerUsename" style="width: 85px;">Usename</th><th class="XMLRPCServerPassword" style="width: 85px;">Password</th><th class="XMLRPCServerAgent" style="width: 150px;">Agent</th><th class="XMLRPCServerNode type" style="width: 85px;">Node type</th><th class="XMLRPCServerServlet" style="width: 85px;">Servlet</th></tr></tbody></table><input class="buildButton" onclick="userOutput(XMLRPCServer.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(XMLRPCServer.help());" type="button" value="Help"></div><div id="NativeAppsSection" style="display: none;"><a name="NativeApps"><h2>NativeApps</h2></a><table id="NativeApps" border="1"><tbody><tr><th><input onclick="NativeApps.add();" type="button" value="Add"></th><th class="NativeAppsVNFC" style="width: 85px;">VNFC</th><th class="NativeAppsNIVR_DB_TYPE" style="width: 90px;">NIVR_DB_TYPE</th><th class="NativeAppsEBRS TENANTMP" style="width: 90px;">EBRS TENANTMP</th><th class="NativeAppsNIVR" style="width: 90px;">NIVR</th><th class="NativeAppsCaaS IVR" style="width: 90px;">CaaS IVR</th><th class="NativeAppsOCCP" style="width: 90px;">OCCP</th></tr></tbody></table><input class="buildButton" onclick="userOutput(NativeApps.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(NativeApps.help());" type="button" value="Help"></div><div id="WebRTCSection" style="display: none;"><a name="WebRTC"><h2>WebRTC</h2></a><table id="WebRTC" border="1"><tbody><tr><th><input onclick="WebRTC.add();" type="button" value="Add"></th><th class="WebRTCFunction" style="width: 200px;">Function</th><th class="WebRTCValue" style="width: 85px;">Value</th></tr></tbody></table><input class="buildButton" onclick="userOutput(WebRTC.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(WebRTC.help());" type="button" value="Help"></div><div id="LicensingSection"><a name="Licensing"><h2>Licensing</h2></a><table id="Licensing" border="1"><tbody><tr><th><input onclick="Licensing.add();" type="button" value="Add"></th><th class="LicensingFeature" style="width: 400px;">Feature</th><th class="LicensingValue" style="width: 400px;">Value</th></tr><tr><td><input id="delButton7" onclick="Licensing.delete('delButton7');" type="button" value="Del"></td><td class="LicensingFeature" style="width: 400px;"><select class="LicensingFeature" style="width: 400px;"><option value="SEE_SIP_SERIAL" selected="selected">SEE_SIP_SERIAL</option><option value="SEE_SIP_CODEWORD">SEE_SIP_CODEWORD</option><option value="OCMP_BRE_LIC_KEY">OCMP_BRE_LIC_KEY</option><option value="OCMP_BRE_LIC_EXPIRES">OCMP_BRE_LIC_EXPIRES</option><option value="OCMP_BRE_LIC_DESCRIPTION">OCMP_BRE_LIC_DESCRIPTION</option><option value="OCMP_BRE_LIC_VXML_INSTANCES">OCMP_BRE_LIC_VXML_INSTANCES</option><option value="OCMP_BRE_LIC_ASR_INSTANCES">OCMP_BRE_LIC_ASR_INSTANCES</option><option value="OCMP_BRE_LIC_TTS_INSTANCES">OCMP_BRE_LIC_TTS_INSTANCES</option><option value="OCMP_BRE_LIC_FEATURE_NAME">OCMP_BRE_LIC_FEATURE_NAME</option><option value="OCMP_BRE_LIC_FEATURE_INSTANCES">OCMP_BRE_LIC_FEATURE_INSTANCES</option></select></td><td class="LicensingValue" style="width: 400px;"><input class="LicensingValue" style="width: 400px;" type="text" value="0BCN04-z8jWFC-VWXYAA-VVVVAA-VUzVAD-VQNVEB"></td></tr><tr><td><input id="delButton8" onclick="Licensing.delete('delButton8');" type="button" value="Del"></td><td class="LicensingFeature" style="width: 400px;"><select class="LicensingFeature" style="width: 400px;"><option value="SEE_SIP_SERIAL">SEE_SIP_SERIAL</option><option value="SEE_SIP_CODEWORD" selected="selected">SEE_SIP_CODEWORD</option><option value="OCMP_BRE_LIC_KEY">OCMP_BRE_LIC_KEY</option><option value="OCMP_BRE_LIC_EXPIRES">OCMP_BRE_LIC_EXPIRES</option><option value="OCMP_BRE_LIC_DESCRIPTION">OCMP_BRE_LIC_DESCRIPTION</option><option value="OCMP_BRE_LIC_VXML_INSTANCES">OCMP_BRE_LIC_VXML_INSTANCES</option><option value="OCMP_BRE_LIC_ASR_INSTANCES">OCMP_BRE_LIC_ASR_INSTANCES</option><option value="OCMP_BRE_LIC_TTS_INSTANCES">OCMP_BRE_LIC_TTS_INSTANCES</option><option value="OCMP_BRE_LIC_FEATURE_NAME">OCMP_BRE_LIC_FEATURE_NAME</option><option value="OCMP_BRE_LIC_FEATURE_INSTANCES">OCMP_BRE_LIC_FEATURE_INSTANCES</option></select></td><td class="LicensingValue" style="width: 400px;"><input class="LicensingValue" style="width: 400px;" type="text" value="0Emw03-z9pMFE-CDEF55-CCCC55-CDkC52-D2CC55-CeCC15"></td></tr></tbody></table><input class="buildButton" onclick="userOutput(Licensing.build());" type="button" value="Apply"><input class="helpButton" onclick="userOutput(Licensing.help());" type="button" value="Help"></div></div>
</form>

<hr>
<table border="0" cellspacing="5">
<tbody><tr>
<td valign="top">Build the MSE Descriptor</td><td valign="top"><input class="buildButton" onclick="buildVNFDescriptor()" type="button" value="Build"></td>
</tr><tr>
<td valign="top">Build the MSE Heat template</td>
<td valign="top"><input class="buildButton" onclick="buildHeatTemplate()" type="button" value="Deploy"> Volumes
<select id="useHeatVolumes">
<option selected="" name="image">from image</option>
<option name="volume">from master</option>
<option name="none">none</option>
</select>
<input class="helpButton" onclick="useHeatVolumesHelp()" type="button" value="Help">
</td> 
<td valign="top">Review USPM descriptor</td><td valign="top"><input class="helpButton" onclick="viewUspmAuxDescInput()" type="button" value="Review"></td>
<td valign="top">Review SMSC descriptor</td><td valign="top"><input class="helpButton" onclick="viewSmscAuxDescInput()" type="button" value="Review"></td>
</tr><tr>
<td valign="top">Save the current session</td><td valign="top"><input class="helpButton" onclick="saveSession()" type="button" value="Save"></td>
<td valign="top">Clear USPM descriptor</td><td valign="top"><input class="buildButton" onclick="clearUspmAuxDescInput()" type="button" value="Clear"></td>
<td valign="top">Clear SMSC descriptor</td><td valign="top"><input class="buildButton" onclick="clearSmscAuxDescInput()" type="button" value="Clear"></td>
</tr><tr>
<td valign="top">Import session from file</td><td valign="top"><input class="helpButton" id="importSession" onchange="importSession()" type="file" value="Import..."><br><b style="color:red">(Directory change is *NOT* supported)</b></td>
<td valign="top">Import USPM descriptor</td><td valign="top"><input class="buildButton" id="uspmAuxDescInput" onchange="setUspmAuxDescInput(event)" type="file" value="Import..."></td>
<td valign="top">Import SMSC descriptor</td><td valign="top"><input class="buildButton" id="smscAuxDescInput" onchange="setSmscAuxDescInput(event)" type="file" value="Import..."></td>
</tr></tbody></table>

<!-- Link to the end of the user area, useful to focus the user on the result on long pages -->
<p>Quick links: <a id="endOfUserArea" href="#endOfUserArea">Outputs and Result</a><a onclick="Networks.display(true);" href="#Networks"> / Networks</a><a onclick="Nodes.display(true);" href="#Nodes"> / Nodes</a><a onclick="Security.display(true);" href="#Security"> / Security</a><a onclick="Misc.display(true);" href="#Misc"> / Misc</a><a onclick="RedisInstance.display(true);" href="#RedisInstance"> / RedisInstance</a><a onclick="OCSNFpolicy.display(true);" href="#OCSNFpolicy"> / OCSNFpolicy</a><a onclick="MessagingFramework.display(true);" href="#MessagingFramework"> / MessagingFramework</a><a onclick="MessagingFrameworkApplication.display(true);" href="#MessagingFrameworkApplication"> / MessagingFrameworkApplication</a><a onclick="MessagingGateway.display(true);" href="#MessagingGateway"> / MessagingGateway</a><a onclick="MessagingGatewayServices.display(true);" href="#MessagingGatewayServices"> / MessagingGatewayServices</a><a onclick="OCCPcountry.display(true);" href="#OCCPcountry"> / OCCPcountry</a><a onclick="OCCPswitchingPoint.display(true);" href="#OCCPswitchingPoint"> / OCCPswitchingPoint</a><a onclick="OCCPmediaServer.display(true);" href="#OCCPmediaServer"> / OCCPmediaServer</a><a onclick="TCAP.display(true);" href="#TCAP"> / TCAP</a><a onclick="MrfAdapter.display(true);" href="#MrfAdapter"> / MrfAdapter</a><a onclick="Diameter.display(true);" href="#Diameter"> / Diameter</a><a onclick="UcpSmpp.display(true);" href="#UcpSmpp"> / UcpSmpp</a><a onclick="SMPPsession.display(true);" href="#SMPPsession"> / SMPPsession</a><a onclick="SMPPprofile.display(true);" href="#SMPPprofile"> / SMPPprofile</a><a onclick="SMPPpair.display(true);" href="#SMPPpair"> / SMPPpair</a><a onclick="Datasource.display(true);" href="#Datasource"> / Datasource</a><a onclick="LDAPprofile.display(true);" href="#LDAPprofile"> / LDAPprofile</a><a onclick="SOAPconnector.display(true);" href="#SOAPconnector"> / SOAPconnector</a><a onclick="SOAPWebServiceServer.display(true);" href="#SOAPWebServiceServer"> / SOAPWebServiceServer</a><a onclick="SOAPsecurity.display(true);" href="#SOAPsecurity"> / SOAPsecurity</a><a onclick="SOAPWebService.display(true);" href="#SOAPWebService"> / SOAPWebService</a><a onclick="XMLRPCconnector.display(true);" href="#XMLRPCconnector"> / XMLRPCconnector</a><a onclick="XMLRPCService.display(true);" href="#XMLRPCService"> / XMLRPCService</a><a onclick="XMLRPCServer.display(true);" href="#XMLRPCServer"> / XMLRPCServer</a><a onclick="NativeApps.display(true);" href="#NativeApps"> / NativeApps</a><a onclick="WebRTC.display(true);" href="#WebRTC"> / WebRTC</a><a onclick="Licensing.display(true);" href="#Licensing"> / Licensing</a></p>
<p>
<textarea id="userArea" rows="20" cols="200" readonly=""># -------------------------------------------------------------
# MSE 2 nodes: ems and Pgsql database, refresh one node
# MSE Descriptor generated by the builder 2018-08-02 Version 2.36
# Build date: Sun Sep 09 2018 21:37:35 GMT+0200 (heure dt dEurope centrale)
# PRE REQUISISTES ON THE NODE RUNNING THE UNATTENDED NIVR SETUP
# 1. The management network is up and running
# 2.1 The command 'hostname' returns a fully qualified domain name used for node identification within the cluster
# 2.2 The command 'hostname -i' returns the node IPV4 address on the MGMT network
# OR
# 2. /etc/sysconfig/network has a fully qualified domain name at the HOSTNAME entry
# 3. MSE bits are available as:
# 3.1 ISOs images on the file system in /var/opt/OC/iso or 
# 3.2 YUM repositories listed in YUM_REPO_LIST and IS_YUM_REPO=yes
# -------------------------------------------------------------


# ------------------------------- #
# Network interfaces definition   #
# ------------------------------- #
MGMT_DEVICE=eth0
MGMT_NETMASK=255.255.248.0

# ------------------------------- #
# Nodes and roles definition      #
# ------------------------------- #

# VNF Element Manager      #
NIVR_EMS_NAME=ems.$(hostname -d)
NIVR_EMS_IP_ADDR=&lt;_%_= node['mse']['map']['ems']['ipaddress'] _%_&gt;

# ------------------------------- #
# SEE Clusters                    #
# ------------------------------- #
# SEE Simplex      #
# SEE Primary      #

# SEE Secondary      #

# SEE Witness      #

# SEE additional nodes      #

# HTTP Load Balancer Primary node   #

# HTTP Load Balancer Secondary node   #

# HTTP Load balancer virtual IP      #
SEE_VIP_NAME=${VHTTP_NAME}
RSLMF_VIP_NAME=${VHTTP_NAME}

# Pgsql database
# -Standalone: one single entry pointing to the Pgsql node
# -Linux HA: one single entry defining the VIP of the Pgsql resource
# -Static cluster: list of SEE nodes co-locating Pgsql, the first being the initial master
PGSQL_HOST=( pgsql.$(hostname -d) )
PGSQL_IP_ADDR=( &lt;_%_= node['mse']['map']['pgsql']['ipaddress'] _%_&gt; )

#-------------------------------------------------#
# Groups for service continuity upon upgrade
# IP addresses preferred to address unresolved names
#--------------------------------------------------#
NIVR_REFRESH_SCHEDULE=(
	&lt;_%_= node['mse']['map']['pgsql']['ipaddress'] _%_&gt; \
)

# ------------------------------- #
# Security                        #
# ------------------------------- #
# Certification authority for self signed certificates
CERT_AUTH_ALIAS="nfvCert"
# Certification authority password
CERT_AUTH_PASSWORD="nfvCert"
# Password for Linux HA administrator account (hacluster) and Redis access control; enforced for all Redis resources, default value: hacluster
NIVRDB_LINUXHA_PASSWORD="hacluster"

# ------------------------------- #
# Miscellaneous properties        #
# ------------------------------- #
# node collecting SNMP traps emitted by all the VNF members, typically the VNF EMS
SNMP_TRAP_DESTINATION="${NIVR_EMS_IP_ADDR}"
# YUM repositories list
YUM_REPO_LIST=centos*,updates*,base*
[ "$YUM_REPO_LIST" != "" ] &amp;&amp; IS_YUM_REPO=yes || IS_YUM_REPO=no

# ------------------------ #
# Redis Sentinel Instances #
# ------------------------ #

# ------------------------------- #
#    OCSNF policy                 #
# ------------------------------- #

# ------------------------------- #
#       Messaging Framework       #
# ------------------------------- #

# ------------------------------- #
# Messaging Framework Application #
# ------------------------------- #

# ------------------------------- #
#       Messaging Gateway       #
# ------------------------------- #

# ------------------------------- #
#    Messaging Gateway Services   #
# ------------------------------- #

# ------------------------------- #
# OCCP countries                  #
# ------------------------------- #

# ------------------------------- #
# OCCP switching points           #
# ------------------------------- #

# ------------------------------- #
# OCCP media servers              #
# ------------------------------- #

# ------------------------------- #
#  TCAP connectivity providers    #
# ------------------------------- #

# ------------------------------- #
# MRF adapters                    #
# ------------------------------- #

# ------------------------------- #
# Diameter     providers          #
# ------------------------------- #

# ------------------------------- #
# Ucp and Smpp providers          #
# ------------------------------- #

# ------------------------------- #
# SMPP sessions                   #
# ------------------------------- #

# ------------------------------- #
# SMPP profiles                   #
# ------------------------------- #

# ------------------------------- #
# SMPP pairs                      #
# ------------------------------- #

# ------------------------------- #
# JDBC and LDAP data sources      #
# ------------------------------- #

# ------------- #
# LDAP profiles #
# ------------- #

# --------------- #
# SOAP connectors #
# --------------- #

# ------------------------- #
# SOAP Web Services Servers #
# ------------------------- #

# -----------------------#
# SOAP Security Policies #
# -----------------------#

# ----------------- #
# SOAP Web Services #
# ----------------- #

# ----------------- #
# XMLRPC connectors #
# ----------------- #

# ----------------- #
# XMLRPC Services   #
# ----------------- #

# ----------------- #
# XMLRPC Servers    #
# ----------------- #

# ------------------------------- #
# Activable Native Applications   #
# ------------------------------- #
# NIVR database type mysql|pgsql|oracle  
ACTIVATE_APPLI_NIVR=no
ACTIVATE_APPLI_CAASIVR=no
ACTIVATE_OCCP_SNTS=no

# ------------------------------- #
# WebRTC                           #
# ------------------------------- #

# ----------------- #
# Licensing         #
# ------------------#
# SIP stack licensing serial number for SEE and OCMP
SEE_SIP_SERIAL="0BCN04-z8jWFC-VWXYAA-VVVVAA-VUzVAD-VQNVEB"
# SIP stack licensing codeword for SEE and OCMP
SEE_SIP_CODEWORD="0Emw03-z9pMFE-CDEF55-CCCC55-CDkC52-D2CC55-CeCC15"
# SIP stack licensing codeword for OCMP same as SEE
OCMP_SIPLIC_SERIAL=${SEE_SIP_SERIAL}
OCMP_SIPLIC_CODEWORD=${SEE_SIP_CODEWORD}


# --------------------------------------------------- #
# Node receiving outgoing calls from SMB WebRTC client
# Default: the NFV installed SIP load balancer VIP 
# --------------------------------------------------- #
WEBRTC_CALLEE_NAME=${VSIP_NAME}
WEBRTC_CALLEE_IP_ADDR=${VSIP_IP_ADDR}

# Optional list of RPM packages providing specific prompts
APP_PROMPTS="/var/opt/OC/iso/hpoc-smb-demo-prompts*.rpm"

# ------------------------------- #
# Various database passwords 
# ------------------------------- #
# pgsql
NIVRDB_OCDBROOT_PASSWORD=ocdbroot
NIVRDB_OCDBREP_PASSWORD=ocdbrep
NIVRDB_OCDBADMIN_PASSWORD=ocdbadmin
NIVRDB_OCDBACCESS_PASSWORD=ocdbaccess
NIVRDB_APPADMIN_PASSWORD=appadmin
NIVRDB_APPACCESS_PASSWORD=appaccess

# mysql: force strong passwords
if [[ "$NIVR_DB_TYPE" == "mysql" ]] ; then
NIVRDB_ROOT_PASSWORD=HP1nvent!
NIVRDB_OCDBACCESS_PASSWORD=${NIVRDB_ROOT_PASSWORD}
NIVRDB_OCDBREP_PASSWORD=${NIVRDB_ROOT_PASSWORD}
fi


# oracle
TPDM_TABLESPACE=NFVTPDM_TS
AAA_TABLESPACE=NFVAAA_TS
MCM_TABLESPACE=NFVMCM_TS
MCS_TABLESPACE=NFVMCS_TS
SMB_TABLESPACE=NFVSMB_TS

# Reporting System 
NIVRDB_CCPS_DS_PASSWORD=CCPS_DS
NIVRDB_CCPS_PASSWORD=CCPS
NIVRDB_CCXML_PASSWORD=CCXML
NIVRDB_EBRS_DS_PASSWORD=EBRS_DS
NIVRDB_EBRS_QRTZ_PASSWORD=EBRS_QRTZ
NIVRDB_EBRS_QRTZ_DS_PASSWORD=EBRS_QRTZ_DS
NIVRDB_EBRS_PASSWORD=EBRS
NIVRDB_JBOSS_JMS_PASSWORD=JBOSS_JMS
NIVRDB_MSCML_PASSWORD=MSCML
NIVRDB_REPORT_USER_PASSWORD=REPORT_USER
NIVRDB_VXML_PASSWORD=CRYSTAL
NIVRDB_QRTZ_DS_PASSWORD=QRTZ_DS
NIVRDB_QRTZ_PASSWORD=QRTZ

# ----------------------
# USPM ISO image Details
# ----------------------
USPM_ISO_PATH=$(ls /var/opt/OC/iso/USPM*.iso 2&gt; /dev/null)

# Enable refresh by not deleting root ssh keys at the end of installation
RETAIN_SSH_KEYS_ROOT=YES

#-------------------------------------------
# Legacy management based on MSE connectors 
# Used to enable/disable features           
#-------------------------------------------
_legacySEE() {  command -v install-mse-connectors.sh install-mse_connectors.sh &gt; /dev/null || test -f /var/opt/OC/iso/OpenCall-SEE*.iso &amp;&amp; return 0 || return 1 ; }
# NIVR and CaaS IVR: activate on SEE3 only
# Messaging Framework, redis and all emscli resources: disable on SEE3
if _legacySEE ; then
MESSAGING_FRAMEWORK_SERVICE_COMPONENT_NAME=
MESSAGING_GATEWAY_SERVICE_COMPONENT_NAME=
ACTIVATE_APPLI_MESSAGING_FRAMEWORK=no
ACTIVATE_APPLI_MESSAGING_GATEWAY=no
TCAP_PROVIDER_NAME=()
DIAMETER_SERVICE_COMPONENT_NAME=()
UCP_PROVIDER_NAME=()
SMPP_PROVIDER_NAME=()
MRF_ADAPTER_SERVICE_COMPONENT_NAME=()
DATASOURCE_NAME=()
LDAP_PROFILE_NAME=()
SOAP_SERVICE_COMPONENT_NAME=()
SOAP_WSS_NAME=()
SOAP_SECURITY_NAME=()
SOAP_WS_NAME=()
REDIS_HOST=()
REDIS_IP_ADDR=()
REDIS_INSTANCE_ID=()
REDIS_PORT=()
OCCP_SWITCHING_POINT=()
OCCP_MEDIA_SERVER=()
XMLRPC_SERVICE_COMPONENT_NAME=()
XMLRPC_SERVICE=()
XMLRPC_SERVER_ADDR=()
else
# NIVR native applications supported only on PostgreSQL database without WebRTC on SEE &gt; 3
ACTIVATE_APPLI_NIVR=$([[ $WEBRTC_SIGNALING_IP_ADDR == '' ]] &amp;&amp; [[ $NIVR_DB_TYPE == 'pgsql' ]] &amp;&amp; echo $ACTIVATE_APPLI_NIVR || echo no)
ACTIVATE_APPLI_CAASIVR=no
ACTIVATE_OCCP_SNTS=no
fi

# +++ EOF +++ # Do not delete this line</textarea>
<a name="endOfUserArea"></a>
</p>
<iframe name="importedDocument" width="1500" height="200" style="display:none"></iframe>
<p class="copyright"> 2018 Hewlett Packard Enterprise Development LP</p>
<script>

// Define an HPE standard style
var HPEStyle = "{font-family: arial; font-size: small}"+
	"body {font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}"+
	"th, table { font: 12px arial, sans-serif; color: #C6C9CA; background-color: black;}"+
	"h1, {color: #FF8D6D;}"+
	"h2, h3, h4, h5 {color: #C6C9CA;}"+
	"input, select {border: none; font: 12px arial, sans-serif; color: #01a982; background-color: black;}"+
	".buildButton { background-color: #FF8D6D; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}"+
	".buildButton:hover { background-color: #4CAF50; color: white;}"+
	".helpButton { background-color: #2AD2C9; border: none; color: black; text-align: center; text-decoration: none; display: inline-block; border-radius: 2px;}"+
	".helpButton:hover { background-color: blue; color: white;}"+
	"a:link, a:visited { text-decoration: none; color: #80746E;}";
// Base 64 encoded logo and icon
var HPEicon="AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////AYe0AP+ItAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/h7QA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP////8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wGHtAD/h7QA/4e0AP+HtAD/////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8Bh7QA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4i0AP+HtAD/iLQA/4i0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+ItAD/h7QA/4e0AP+HtAD/iLQA/4e0AP+HtAD/h7QA/4e0AP+HtAD/iLQA/////wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8B////Af///wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//w==";
var HPElogo="iVBORw0KGgoAAAANSUhEUgAAAU0AAACBCAYAAABErei/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABo/SURBVHhe7Z0JuFVV+YcXIgpqqDjhVGZqZWamleX0hAaBlg2PkuY8JIQpfzUnxKkcM6KQHMqhIjON1JzIoUwrMzKVnCg0ckYlJUVEAfd/veusb7POZp97z773XOVyf+/zfPfss9bae6+99tm/++019vJkTgghRFMsFz+FEEI0gURTCCEqINEUQogKSDSFEKICEk0hhKiARFMIISog0RRCiApINIUQogISTSGEqIBEUwghKiDRFEKICkg0hRCiAhJNIYSogERTCCEqINEUQogKSDSFEKICEk0hhKiARFMIISog0RRCiApINIUQogISTSGEqIBEUwghKiDRFEKICkg0hRCiAhJNIYSogERTCCEqINEUQogK9PJkcVt0lqyHFGWvXnFDiJ6HRLNVIJgr9nFuhRWce+utGLiM0du/mMx9vXZ9Ek7RQ5FotoJQgv7PAUNddtSeXljmh+BljlVXdr0OOde5qY9KNEWPRaLZCkw0hw9y2YjdnXttGRbN0ROce+AxiabosUg0W4GJ5p5eNEcmornSis4t183b2hYtcu71N2vbiOb/ne/c/TMkmqLHItFsBdYAtM9glx20q3PzvGhS/3fZzc694QWnVzcVTgRz4IDwz8AtWFgTzVHjnXt4pkRT9Fgkmq2g6GnOe8O5Pr1dr2HHLRbU7sq6a7ps0pjaNcnTFEL9NFtKUUf6rVD7RGC6o0HfeA1GT+lWJUQDJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJZlcyP3YKp8W5OxrQz1QIkaN+mq0glKD/kw6jpHP7xGtqwtldRwXRuX2dNZw7aKhzb8bO7RpGKXo4Es1WUCaasHLf7iuYBsJJx3aQaAoh0WwJjURzWUOiKYREsyWYaO5vU8O9HoKXORDNQ5kabrpEU/RYJJqtwERz5X4u67/SMjwJcW/Xa/acWv2mRFP0UCSarcKEsycgwRQ9GImmEEJUQP00hRCiAhJNIYSogERTCCEqINEUQogKSDSFEKICEk0hhKiAuhy1kMxmBkrw5Ru3FtNsureLYn7eybwUKSurIm9nfpe2e1dGozJb2vLZXfHlKNFsBfxQ+/Xr51ZaaSX31ltvueWWW87997//DXHpj5V0q6yyiltxxRXDNmnnzJkT4t6JHzV56N+/v1t++eXD90WLFrn//e9/S8UDZg//Rz7yEffmm/VT1JG/xx57rDS8q7D8bLLJJm6FFVYI93j27Nlu1qxZS0V5geVxs802C/eUPL7wwgvBYGnJZ7fGF2Im65z5Ygw2fvx4/5tdzIABA0J4Me3kyZNjiizzopl5oV0i3dtlnHfq1KkxN1nmhb7TeWH/1NqKM0vTpGn5bI8ZM2ZkW2+9dZvHaoXZ8b1QxjNn2VVXXdXl561i5KNv376Z/2cSc5hlEyZMWKry2N1NdZot5JVXXolbNRYuXBi36jHPEp5//vng3b2TvPTSS3HLuRdffDFudQz/jLqJEye6G264wd10003u5JNPzr0fPv2Pzl1xxRXuN7/5jbvlllvcV77ylTyujEbhKXh+f//7393YsWPD92b26Qz2BgHFe740wO8pvY9z586NW6IVSDRFy/n85z/vPve5z7ldd93VDRo0KIbWQND23HNPt/vuu7shQ4a4LbfcMsY0x7x584JopUJvfPvb33bbbbdd/CZE1yDRXApBWNqyRmmMZsMtzj4BT7BIcZ+iGbadejavvvpq+EzTvfbaa3FrcTykaRoxatQot+aaa7o11lgj5PXYY4+NMTXGjBkTPi1vbVmRsjSptUfZPs1aSll80Rqlg3f6zWVZx//uQj2I6AT2Y8XTsVdEWHXVVcPrWypEpL388svdgQceGL4/99xzbqONNgoNGqSzY332s591++67b4i777773D333OOuvPLKEAcf+9jHgsf2xhtvBO9r/PjxYRve9773uREjRoTqgbvvvtvdeOONIRz233//vJFgypQp7s4773S33nqrGzx4cIh/9NFH3eabb57n2fJD49Vhhx3mhg0bFs5DfngFnzZtWogHvMctttjCHXXUUUHYgMaaH/3oR27llVcOjV4c98QTTwwNYfCHP/whnL9v377uzDPPzMsB7Nz2CaNHj3YTJkyoK6u//vWv7hOf+ETYfuaZZ9wGG2wQ4rlOXv+5HsqRuIceeiiU4/Tp00P64rkADxiPdfvttw+i/sADD7gLL7wwf+X95z//GY4NXBtlDVzD0UcfHa6td+/e4d6PGzcuiNj6668fvO9PfepTYV+O+/DDD7vrrrvO3XXXXWF/uya873322SeUM+nOO++8kBfuHQ1PJ510UkgP6667bvjdUe78lrgnv/zlL8OxuWY4++yz838mdr2iE/hCLK3slDVvvhiDnXXWWf43vxgLL9pFF10UU2SZf5AzL2B18f6HH2Pr+fOf/5z1798/pNlhhx1iaI0PfvCD+f7nnHNODM0yL1p5uH+YM+/lxZgsGz58eAj/3e9+F0Oy7MEHHwxh6bV5QcpmzZoVU9Rz2mmn5cefNGlSDO0Y73rXu5Y4N5Zy5JFH5mks/qabboqxNQjbe++947dyvPDk+9uxaED54x//GFPUM3/+/LzBzotmDM0yL6b5cYrXf/jhh4fwD3zgAzGkHM5px8AOOuigGJOFcvf/ZOK3LPNCmqf75Cc/GUPr8SKfvfDCC/FbFn6Xto+VrazjJtFsgdkPsiia3mvL/H/87JFHHsntH//4RzZnzpyYIsueffbZOtH805/+FGNqFMWKlmJL+5///CeGZkEoLZw0Bg/ZeuutF8K32WabGJpl3oPJ0zcSTT69JxNjaixYsCB76aWX4rcaI0eODGm9BxdDOob9QyiWa4oJUWr8YzAQDMJI1x7ek8+PgWB6zzDGlGOiXiaaqdDBKaeckh+bfzrt4d8+8vTey4yhtfuXMnfu3JBm4403jiHtI9FsralOswvxHkZ4NfReYG4f/vCHw2t7GXvssUd4DYOXX37ZbbvttuG1jtbhp59+OoSzzas70AJtfOELXwifG264YdjHoD+h90jCNq/7xh133BG3yvHPWvikpdugtdsLh1tnnXXc1772tRjq3Lnnnhs+eQX80Ic+5J544onwHf7yl7+EMuC1lOvhtff11xcvB8LrLf0wue5mWnnXXnttt9Zaa7n3vOc94VjeSwvVEQbfgSoL/8/Abb311qGqYPXVV3df/OIX8yoM4FXa+OEPfxiuzfBevfv4xz8e7pkXRPfvf/879HksQv0s5X3ZZZfFEOfuv/9+961vfSt+q5Ul1RDcI/K+2mqrhTJ56qmnYgoX8lb2u+D+gf9n66655prQSwDSaiD4/e9/73beeedQ7UOViOhCypRUVs18MQYreprNkHqa/sGKoVl2/PHH58fFTj755BiTZf6BDGGp5+iFKPMPXTZs2LAYspiJEyeG9NOnT48hWfblL385P3aZp4mtssoqMTTLFi5cmHlxyOOwRYsWxdgs69evXx6OR23ceOONdftgeEtG8TrLyrVZvFBmXhzrjod5Ic8222yzsH3GGWfE1FnmRSucxwtTDKlBNUjxGJgXzfCZepoXX3xx5oUsfqvdh7SaId0fw0PcYostwnZ6/8D/IwjhqacJl156ad0xsJT0nmH8DtIylqfZWpOn2YUcfPDBbvjw4W6vvfbKjcYAq/g3/O86fOKFGv51O4SbpZ4LjUCA92FeHY0QO+ywQ2iMgfnz5+eeDOfFuzGPjMYFPJP2wEszaNjA203zlHpe1hADaTj7gf+xhU9It/v06RM+CUvDq4InSAMKHjrQGEQ5k08af2i8YTttRMGLw/BYU0444YTwaXmyfNGQVYTGMSsnjo9nSvkWrwVPlPjHH3/ceZEL2/fee2/4NKwsihx33HHhs1H50DAGFo/HbuUgWo9EswuZNGmS+9WvfuWuuuqq3OjwXXx94mHk4W300BQZMGBA+FywYEFo/TZ222230DcSbrvttvz1ne45++23Xz5UkpbvtIN9I6z1tRnWW2+9uNW10EcT4eGfBeLzs5/9LLw+8w/ByhXRRpB23HHH8B1olU8FCvhO2VtLvlEmOI0EKxVS0livAY5t5+NekEeDfWz4Z3rcYv6Ae2z3zaCqISXtbA9cf/qPS7QWlWwXwjh04MEwg+JDQHjxob7gggvcZz7zGedfo3P70pe+FOrFvvnNb8ZUzv3iF7+IW7XuRO9+97vD9m9/+9tgxne+85245ULdGFh+7BPSPKQPI/mjzhVPNs0T3wlPvef0gS32GeRcaTyiUAWunXpdBB3P8oADDnA/+clPYmwN6vWodzX4Tl0rZtdukJdiR/mtttoqbtVIBbAI5f/ss8/Gb85Nnjw5btXgN8B9NKj/pXsQ9d1nnHFGDG0M5ZXeHyiKOt4tWB4pU/XV7EL8DSl9b5c1b74YgxXrNIutwZb2pz/9aUxRX6fpRS6GZpn3pPLjpmb1XqmVQb3Z2muvXdfFyLD9LD9TpkyJMVlokbd46uZSqA+0uNSKdZ333Xdf3CPLvMdXF4c9+eSTMTbLvKdYF1csKywl7XJUNEs/bty4mDrL/va3v+XhGK3dBj0TrP4xrQNk23uudfsNHjw4dNliO63T9CIYyjrl+uuvz/cbMmRIDK1h4Zj/pxNDa9g50zpNeisMHDgwhKfXmfaqoNXf/yPJj+v/scaYGqrTbK3J01yKsLorwGPEA6Lj8siRI90pp5zivACEzuqGv4Hhk1biFDpAU4/HzDZpCy1Qt1ckDaNVGu+J13nq5s4///wY40J94O233+6OOeaYMDKHDt/MiJR6vjBjxoy45dw222wTqimo06NlH+hkbnCeH/zgB6EVnQ70/hmPMR2H13aD+l/yTX3xaaedFsoyxbxersmgIz6d3+l4zkAEOorTc4B64yK0uFPWP//5z2NIbRjpLrvsErbT+wVUJ9CLgNbyq6++OoZW5/TTT49btTzQAZ+qH1rXybfoQooqKqtuvhiDFT1NWjEJL6bFuzKee+65un6aXiRjTDlepPK0djz/+hlja9x88815Gma4SRk7duwS+w8dOjTGLuaSSy7J07VHOosO5oUwxtTjhSvE+wc+htSTtjpb3rCU0aNH16UpGnF4hLT2t8eLL76Y3yMs7UVQhuXvX//6VwzJwkAF2z+FfrB2X6dNmxZD28a8RfqPGlwHfWUJT6+Rz8cffzymaht5mq01eZotpNiQ4ws4btWTpqMBKK3jY1YghirSGlwEr44ZhIpQd5nWDaZ9BvHyUswLSfPG/qnnAuTLIO33vve90vpHPLJiPSHnvPjii+O3xVg926mnnho8tyJlrdPFMizWBxchPX0xN9100zC8MoVzMsQTvJaE/qLp8fEODznkkDAcsQiNata/NC2b9F7iYRp4zfTNBOpIaQRMwdum3yz3tDgbVnqN9D5Ifx9Ansk/jV/FsqfumWtk6K3RbAOjaA5f/uE/l+gE/ICByXzpoIw48GO3V+P0wSQtrZ+8ArKNUNhDag8D8GDS6k2DAY0JtBjzoPHKDHZMSz9w4MBwTusalAoQr/rkibTWaFHME9BN573vfW/45IEnX2meyDeds9///veHhx1h53h2rmKerLGG7k60bBdfVckXnby5Vu+9NRwPTpUBgo140AhCh/I0/0VsP+AclM2sWbPck08+GfbjGsgz6ayxK71OJpMmzzTY0H2H+2iDC4BGJoSNfYhPeyIwFpxwjDSc047LfuSHc3IvEXfyQjz3jbHt5Ivz0wrPPeM43AfC2TbSaySf/JOgRwH3hPwwCACxpMy4VzaFXXoM0TF8GUo0W0H6I04p+5GWpW30QJRRPGZbx2vvXMbbkSdoK1/QzHHK8l+kvfymVLnOMpq5pmaP2yht2TVXzWvZMUR1fDlKNIUQollUpymEEBWQp9ki9KpUjbS8enpZiO6FRLMFmAAwxnvvvfeum8WnCEP26FdJK3hHxaK7Cw75p5GIBgybIFnCKboLEs0WYCL23e9+t66TdCPo+jJ06NAOCUUqmEZ3EhzLP11jaN1leOfxxx8fwiScojugOs0WYpMwMCKHceJM0lA0ZsU566yzQrqOwryJzHCUjtbpbljfwbTPoxDdAXmaLcC8JzqIM9yRvnI2DVsjzKsq8xxTUu/L0n71q18NkwMzXDBdzbHoqTXjlbZ3/mbo6DGZvNeGVJZdZ5HieaCZaxSilcjTbCHmadJRGXh4GxnwwLNNegsDxhLTwRlMFFJxsPOkHdghTWPbHIdO90ZZmiKMsW5r5A3HpBO/jVRp5ph4lMUp2NIx6IbtT5kwqibNR/HY9p18kB8r90Z5EKIVSDRbCKN8qsIEsoz2oQGJeTIZicPIDkbHsCQFYmMiwFyZDA1k4glg9A5DIFmagckzDEvPkElG4jCihf1YBRJSUWHyCOJsOB5DINnn17/+dfjOCBcmCrEGmx//+MfBk2akC1UEtoRuekxGszDskHhgQg8mBWEZCEbEwKWXXuqmTp3qPv3pT4fvYMdgAuZHHnkklAOTZXCsdKLf9JMlK0iDAON5k2/EOc2PEC3Fezilg9JlzZsvxmA2YYcXnTyskdl+NklEuqJicTo3mxps1KhRMWRJWMTNjr3VVlvF0NqEDzNnzozfalPRWTpst912C+FMHJIuyDZ79uyQR6YrMwgD7+mGT+Puu++uOyZTxbHsA1xxxRXh02AaNdLYuVg10vbzHmPd4mZMU7coWVKjrSnomEqPadQMVmokTXqfZLJWmDzNLgDvjOnVrr322jpjTWoab3id9M91SGuTYOBFXn/99cETYzwyi6HZuGimhwMm28WLY1o2YHZyXqUZK77TTjuFMOBccMkll4RjUb+KV4r3St5sf7BJNBifjVFfyhRuTD5heTQYC8+kFnjEjM22pSNYNC2d1o79WG4DOB4NX4wfZ5o2vEewBc7s/IDXSNUEHijXxXhqxrvjjTJuPc0Pa3l/9KMfdV5YQ9eljTfeOKRl/Xe46KKLwmfxGoToNGVKKqtmvhiDFaeGK4Op3fr06ZPvYxMP+1fXPMzsoLgsLFOApeF77LFHCC9bAGzEiBEhDq+wGMfUY8DCZ3h1hKXTwpkXWLYPeGFfIt4WfPMCny9qxpLBL7/8cghPlxZO7aGHHgrxtvY6ZlPmfeMb36hLa7Z8nGrNi3o+9dtGG220RDqmfINtt902fC+7ZzJZR02eZhfArDQsSzto0KA6w0sbMmRI6RRrNiGtvyl5o5DNCoT3ZY0cYI0j1hCT7mPL+zIVGZ4adYEY+cFLZVYePElbZ8hgJhwm04X0eAae45QpU8J2Go8XzNRmHI9lKIqceeaZ4dP2KR43xaYzwxun878tIGfYFGos70B5MNkxM0Dhcdp1MgOTTQlXlh8hOotEswtAYGgEoVEnNVaAtAe6KB5ls4JbH0bvNOUC2R6II/AKznRrzOSNMbM3a5DTIo2lLerQlpgB5y/LI5jYlolUKvbt8f3vfz+fdf3www8PDVA0OHnPM4QZtoYP/xRoBEJs7TqpgmCBOZBoiq5AotkFFD3AMusqbDE3WsOZOBivLTVa62lpt/kVW4F1fWqrm1J7WJnQ7/TQQw/Nl8zAKybfLLNhWHcsBHLcuHGl18jyGcX5O4VoCf7HWvreLmvefDEGszpNW5ysLG1qpLE6TZaASPdhm+Uh4Pnnn6+rB91rr71CuNVppvtMnjw5xB1zzDF5+rbM6jSpa7Ww9HhWp0lreFk8daPWwu0FL4SldZqrrbZa3T62X1mdZtFYtuLEE08M6YBlPQjfZZddwnda4Iv7FC09r0zWCpOn2QWY5+Wf64bWGaxOtGyNbVsHndblRnRk6CKv5izXC+n5aDXHs6Ye11rGOwrVBob/cYYWdq6Dxc2A+kqgnyhlzOs3w1XLsGGaQrQaiWYXgMDwmklXmaKxBjZLPHRGOOl8DnSzKTaW8HqKgCEavL7SdclAZK+88sq8sagqdDK3NbwRtbFjx+biTMMNjUmdgcYr67hv5cN1DB48OGxTZwkzZ84MK1gC1RDWwd44+OCDS9dSEqIlpG6nrGPmizHYeeed55/19rn11lvzfe64444Qxqs939NjWid1Vjb03mG+D8brdMrTTz+dx9ElJ11bvMjOO++cp7XO7d6ry8PSPNjr+fz587MHH3wwbBe5+uqr830xOqHPmzcvxA0YMKDumHbcss7t3ksOYYb3JuNW/QqbZtdee22MXRIGC5AmPa9M1grr7f/U/rWLTsPCWbxi0gKMl1dmdMZmarh77rkn7ENndn8PQnceWqHZNvBYWTecYZI33HBDeCW1eFac5HWVrj6EM0fn5MmTQxyNPHTyZn8aZ/gkjOGaX//61/OuQ0CHdYZSMmzRVq5M80D8EUccEV6V6SBPZ3k601NFwPDMMWPGuBNOOCGktf04Hx4w32l0Yt/0mIAHzGs9wx7xHIFrJL+UIekZY8+CZkyCYqtIEm7HwjOdNm1a6JLFEFZ6LTDDFF4mHeXLzitEZ/G/qfCfX3QS79zEreawhzndr/iAF4+ZxqdxCI31YSRNM3kpOz8Uz0HrNd1+EDDEySYLQfCs7hYa5Q3SOCNNUzXPRnv7lJ1XiM6iOs0WwQNaxYyyMCONK8an31PBtM+yfaAYnqZNw420I37a59IEs2y/9HjFOKMYX/ye0l54Ma5ReiFagUSzG5OKRiORaCZNW5Tt05njNUN6/GbPUTW9EB1FoinaxLru0E2pyugeIZZV/D9m1WmKchrVGcqbEz0ZeZqiIWXiKMEUPR15mkIIUQF5mkIIUQGJphBCVECiKYQQFZBoCiFEBSSaQghRAYmmEEJUQKIphBAVkGgKIUQFJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJphBCVECiKYQQFZBoCiFEBSSaQghRAYmmEEJUQKIphBAVkGgKIUQFJJpCCFEBiaYQQlRAoimEEBWQaAohRAUkmkIIUQGJphBCVECiKYQQTePc/wOcom/ZcMJR9wAAAABJRU5ErkJggg==";

var localStyle = document.createElement('style');
localStyle.innerHTML = HPEStyle;
document.head.appendChild(localStyle)
var localIcon = document.createElement('link');
localIcon.href = "data:image/x-icon;base64,"+HPEicon;
localIcon.rel="icon";
localIcon.type="image/x-icon";
document.head.appendChild(localIcon)
document.getElementById("HPElogo").src="data:image/png;base64,"+HPElogo;

// Display version history in the user output area
function versionHistory(){
	userOutput("Version history:"+
	"\n2018-08-02 2.36	Add missing Pgsql and OCSNF HA network interface definitions"+
	"\n2018-07-26 2.35	SMPP connector compatibility break: turn integer values to enums"+	
	"\n2018-07-23 2.34	Expose ORACLE_PATH in the Misc section for more flexibility to connect to Oracle instances"+
	"\n2018-07-23 2.33	Support for Messaging Framework Application (SMSC) configuration via auxiliary descriptor"+	
	"\n2018-07-20 2.32	Restore the capability for deploying MSE *without* any SEE instance for more flexibility, eg naked Linux HA cluster."+	
	"\n2018-07-17 2.31	Allow VNFCs consisting of an SEE simplex, while waiting for SEE5 cluster mode"+ 
	"\n2018-07-12 2.30	Redis Sentinel: in addition to the MGMT network, optionally manage HA and APP interfaces"+
	"\n2018-07-10 2.29	Offer the Jdbc datasource driver setting"+
	"\n2018-07-09 2.28	MMCC tenants: support regular expressions by surrounding simple quotes; get rid of deprecated Heat personality feature to manage USPM auxiliary descriptor"+
	"\n2018-07-09 2.27	Do not output the HTML code upon session saving"+
	"\n2018-06-28 2.26	Allow only one MMCC per VNFC; output area is read only; fix on Linux HA Redis topology check with 2 resources; allow subsequent import of USPM auxiliary descriptor"+
	"\n2018-06-22 2.25	MrfAdapter MMCC: add parameters for redis, servlet and tenants automated configuration"+	
	"\n2018-06-20 2.24	Redis instances on Sentinel: new section for more flexibility"+
	"\n2018-06-18 2.23	EBRS TenantMP: multi-tenant access control database type for the reports interface of the EBRS; fix for static Pgsql clusters on OpenStack"+
	"\n2018-06-07 2.22	Netmask consistency enforcement with additional help"+
	"\n2018-05-31 2.21	Offer the option to build Heat templates not using volumes as storage"+
	"\n2018-05-29 2.19	Security section: support NIVR_DISABLE_FIREWALL_TOOLS in SEE cluster.properties to disable firewall tools on SEE nodes."+
	"\n2018-05-28 2.18	Support for Diameter TASAPPs types (experimental): NAF TpReg BSF XDM MMTel."+ 
	"\n2018-05-04 2.17	Enforce redis resource password setting."+
	"\n2018-04-27 2.15	Redis Sentinel support and MMCC as a new MRF adapter type"+
	"\n2018-04-16 2.12	XMLRPC support: adding missing serialNumber and SOB probe arguments for VSIP and CAX services respectively"+
	"\n2018-04-11 2.11	Hide unused sections for better legibility; add compatiblity matrix"+
	"\n2018-04-06 2.1	XMLRPC support"+
	"\n2018-03-26 2.08	Messaging Framework: properties default policy documented"+
	"\n2018-03-26 2.08	Misc: NIVR_OTHER_HOSTS to add IP address/fqdn in /etc/hosts; check Diameter resource for SMSC application; check Redis and SEE *non* colocation; fix webrtc on specific SIP interface"+
	"\n2018-03-02 2.06	Prevent Messaging Gateway instantiation on SEE cluster with *non* USPM Back End node(s)"+	
	"\n2018-02-22 2.05	OpenStack support: elaborate a Heat template ready to deploy, optionally including the USPM auxiliary descriptor"+   
	"\n2018-02-01 1.93	OCCP support; check non co-location of Linux HA and SEE"+
	"\n2018-02-07 1.91	Diameter to support RO and SH mix provider; version history display"+
	"\n2018-01-24 1.88	SMSC support"+
	"\n2018-01-23 1.87	Extending the default OCSNF group to all SEE nodes, including simplex, in addition to OCMP nodes"+
	"\n2018-01-22 1.86	Adding include-namespace-in-request option to soap_web_service create command "+
	"\n2018-01-17 1.85	SMPP client support"+
	"\n2018-01-10 1.84	Pgsql static cluster can be restricted to a specific VNFC; do not require SIP/APP/LBNAT networks on a SEE witness"+
	"\n2018-01-05 1.83	Display non ambiguous messages"+
	"\n2017-12-21 1.82	Extend connectivity selection/filtering on all VNF, not only the VNF components;\n\t\tallow concurrent TCAP/UCP/SMPP connectivity on Messaging Framework;\n\t\toffer SNMP_TRAP_COMMUNITY and SEE_INSTANCES_MAX in the Misc section"+
	"\n2017-12-19 1.75	Support Pgsql cluster HA in static master mode"+
	"\n2017-12-13 1.73	Prevent short host names clash across network interfaces"+
	"\n2017-12-08 1.72	Allow missing SIP interface on SEE pure witness; do not delete network interface in use"+
	"\n2017-11-30 1.7	Open OCSNF configuration to any type of back end"+
	"\n2017-11-24 1.68	Check SEE instance Ids conflicts for HTTP load balancing across native (MCM/TPDM), messaging gateway and MRF adapter applications;\n\t\tnative applications refactoring regarding multiple VNF components;\n\t\tprevent database co-location with SEE/HTTP LB roles in case of multiple VNF components; fix OCSNF simplex with specific SIP network."+
	"\n2017-11-20 1.63	Support Redis replication mode: lsb with REDIS_SPARE attribute, spare and lazy in the VNF Descriptor assistant;\n\t\tallow one MRF Adapter per VNFC; offers VNF_RETRY_POLICY_MAX_TIMEOUT and SEE_CLUSTER_EXPERIMENTAL in Misc section"+
	"\n2017-11-13 1.6	Connectors: re-factoring ldap, adding jdbc, soap"+
	"\n2017-10-20 1.57	Applied logo, fonts and colors from HPE branding policy"+
	"\n2017-10-17 1.56	Switch default port for MFR_ADAPTER from 5080 to 5060; enable automatic Messaging Gateway re-configuration"+
	"\n2017-09-27 1.50	MFR_ADAPTER: default port switch from 2775 to 5080, more appropriate for SIP network analyzers"+
	"\n2017-09-21 1.49	SMSGW_APP_SERVICE_PATH moves from section MessagingGateway to MessagingGatewayServices as a vector so that each service can specify its own path."+
	"\n2017-09-20 1.48	Support for Diameter+MrfAdapter RF type"+
	"\n2017-09-07 1.4	Session import; skip SNF installation if less than 2 OCMPs; simplified VNF Descriptor: clean @yum_repos@ for all architectures"+
	"\n2017-09-05 1.35	Support Diameter RO_SH type in addition to SH and RO; restore the missing DIAMETER_SERVICE_COMPONENT_TYPE entry."+
	"\n2017-08-09 1.34	Support for MessagingGateway application, with multiple services deployment by extending SMSGW_APP_SERVICE* and SMSGW_APP_SMPP_SERVICE* properties as vectors."+
	"\n2017-07-27 1.2	Features renamed as NativeApps, enabled per VNFC, using placeholders for Heat activation;\n\t\tsupport dynamic YUM repositories from Heat, multiple database types, SIP and OCMP licenses refresh, legacy detection on mse-connectors instead of SEE ISO naming;\n\t\tMessaging Framework: support for Front End Cache"+
	"\n2017-07-05 1.1	Add a Licensing section for SIP and OCMP; manage select attribute for saved sessions; add NFVD_USER and related information for REST scaling."+
	"\n2017-07-04 1.0	Messaging Framework support for multiple addresses (MESSAGING_FRAMEWORK_ADDRESSES);\n\t\tenable line deletion in saved documents; support for 2 networks for Linux HA"+
	"\n2017-06-29 0.98	VNF descriptor assistant with simplex example"
	);
}

// Display the compatibility matrix in a distinct window
function compatibilityMatrix(){
	var w = window.open('', 'MSE compatibility matrix', 'width=800,height=900,status=no,menubar=no');
	w.document.head.innerHTML = "<title>MSE compatibility matrix</title>"
	var localStyle = w.document.createElement('style');
	localStyle.innerHTML = HPEStyle;
	w.document.head.appendChild(localStyle);
	
	var matrix = w.document.createElement('table');
	matrix.id = "compatibilityMatrix";
	var matrixCaption = w.document.createElement('CAPTION');
	matrixCaption.appendChild(w.document.createTextNode('MSE compatibility matrix '+document.getElementById("vnfDescriptorWizardVersion").innerHTML));
	matrix.appendChild(matrixCaption);
	
	// If the compatibility matrix is already displayed, stop
	if(w.document.getElementById(matrix.id) != undefined)return;
	
	w.document.body.appendChild(matrix);
	
	var targetSEE=['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5'];

	// insert a first row with a feature cell, one cell per target, then a note
	var tr = w.document.createElement('tr');
	var th = w.document.createElement('th');
	th.appendChild(w.document.createTextNode('Feature'));
	tr.appendChild(th);
	targetSEE.forEach(function(e,i,t){
		th = w.document.createElement('th');
		th.appendChild(w.document.createTextNode(e));
		tr.appendChild(th);
	});
	th = w.document.createElement('th');
	th.appendChild(w.document.createTextNode('Note'));
	tr.appendChild(th);
	matrix.appendChild(tr);
	
	// Feature prototype, candidate for compatibility matrix
	// - a title for this feature
	// - list of compatible versions, from targetSEE list
	// - specific notice to display for this feature
	var compatibleFeature = function(title, targets, notice){
		var tr = w.document.createElement('tr');
		var td = w.document.createElement('td');
		var checkCell;
		td.appendChild(w.document.createTextNode(title));
		tr.appendChild(td);
		targetSEE.forEach(function(e,i,t){
			td = w.document.createElement('td');
			checkCell = w.document.createElement('INPUT');
			checkCell.type = "checkbox";
			checkCell.disabled = true;
			checkCell.setAttribute("checked", "checked");
			if(targets != undefined && targets.indexOf(e) >= 0){
				td.appendChild(checkCell);
			}
			tr.appendChild(td);
		});
		// optional note
		if(notice != undefined){
			td = w.document.createElement('td');
			td.appendChild(w.document.createTextNode(notice));
			tr.appendChild(td);
		}
		matrix.appendChild(tr);
	}
	
	// Supported features
	new compatibleFeature("SEE simplex",	['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("SEE cluster",	['SEE3.6', 'SEE3.7', 'SEE4'], "Cluster not available on SEE5 yet");
	new compatibleFeature("Linux HA",		['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("USPM", 			['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5'], "YUM repositories not supported yet on RHEL7");
	new compatibleFeature("HTTP LB", 		['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("SIP LB simplex", ['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("SIP LB HA",		['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("Simulap",		['SEE4']);
	new compatibleFeature("OCMP",			['SEE3.6', 'SEE3.7', 'SEE4'], "OCMP not ready yet on RHEL7?");
	new compatibleFeature("Databases");
	new compatibleFeature("MySQL simplex",	['SEE3.6', 'SEE3.7', 'SEE4']);
	new compatibleFeature("Oracle simplex",	['SEE3.6', 'SEE3.7', 'SEE4']);
	new compatibleFeature("Pgsql Simplex",	['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("Pgsql HA",		['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5']);
	new compatibleFeature("Pgsql Static",	['SEE3.6', 'SEE3.7', 'SEE4'], "Cluster not available on SEE5 yet");
	new compatibleFeature("Redis simplex",	['SEE4', 'SEE5']);
	new compatibleFeature("Redis HA",		['SEE4', 'SEE5']);
	new compatibleFeature("Mongo",			['SEE4', 'SEE5']);
	new compatibleFeature("Applications");
	new compatibleFeature("ACM/TenantMP",	['SEE3.6', 'SEE3.7', 'SEE4', 'SEE5'], "emscli reports LOCKED_ENABLED state on SEE5");
	new compatibleFeature("WebRTC",			['SEE3.6', 'SEE3.7']);
	new compatibleFeature("SMB apps",		['SEE3.6', 'SEE3.7']);
	new compatibleFeature("Conferencing",	['SEE3.6'], "SIP stack discontinued with SEE 3.7");
	new compatibleFeature("MessagingFramework",	['SEE4']);
	new compatibleFeature("SMSC",			['SEE4']);
	new compatibleFeature("MessagingGateway",['SEE4']);
	new compatibleFeature("OCCP",			['SEE4', 'SEE5']);
	new compatibleFeature("Connectivities");
	new compatibleFeature("TCAP",			['SEE4', 'SEE5']);
	new compatibleFeature("MrfAdapter/MMCC",['SEE4', 'SEE5']);
	new compatibleFeature("Diameter/TASAPPs",['SEE4', 'SEE5'], "TASAPPs experimental implementation as specific Diameter types, on SEE4 only");
	new compatibleFeature("UCP",			['SEE4']);
	new compatibleFeature("SMPP",			['SEE4', 'SEE5']);
	new compatibleFeature("Datasource",		['SEE4'], "Common to JDBC and LDAP");
	new compatibleFeature("LDAP",			['SEE4']);
	new compatibleFeature("SOAP",			['SEE4', 'SEE5'], "Fix for emscli operations pending on SEE5");
	new compatibleFeature("XMLRPC",			['SEE4']);
	

	
	return false;
}

function userOutput(aText){
	document.getElementById("userArea").innerHTML=aText;
	document.getElementById("endOfUserArea").click();
}

// Class implementing a unique role
var uniqueRole = function(aName){
	this.v = false;
	this.name = aName;
}
uniqueRole.prototype.init = function(){this.v = false;}
uniqueRole.prototype.v = this.v;
// Set if y, unless already true; in that case, return a duplication alert for role
uniqueRole.prototype.setIfNotOrAlert = function(y){
	if(y){
		if(this.v)return "\nRole " + this.name + " is duplicated."
		this.v = true;
	}
	return "";
}

// Class implementing a Heat node: a short name, and a flavor
// Plus a list of network interfaces identified by the integer behind the 'eth' prefix, -1 for the external network used to connect floating IPs
// Plus 2 booleans: isVIP if this node is a VIP and hasVIP if this node hosts VIP(s)
var heatPublicInterface = -1;   
var heatNode = function(aName){
	this.flavor = 'flavorSmall';
	this.name = aName;
	this.interfaces = new Array();
	this.isVIP = false;
	this.hasVIP = false;
}

// Global variables used for global consistency checks
// List of VNF components, plus the composed VNF at index 0
var VNFCnames = new Array();
VNFCnames.push("");

// List of http load balancers, one per VNFC, used to store the list of balanced SEE applications and manage uniqueness of instance Ids
var httpLb = new Array();
function httpLbCheckAndGetSeeInstanceIds(anApplication, aVNFCindex, aListOfIDs){
	var uniquenessResult = "";
	var VNFdisplayName = aVNFCindex != 0 ? "the VNFC " + VNFCnames[aVNFCindex] : "the composed VNF";
	// an application is candidate to http load balancing: check conflict on instance id with other candidates
	if(httpLb[aVNFCindex] != undefined ){
		// An http load balancer exists on this VNF; if no application is recorded, prepare for reservation
		if(httpLb[aVNFCindex].application == undefined ){
			httpLb[aVNFCindex].application = new Array();
		}
		// Multiple instance Ids as a list of comma separated integers
		aListOfIDs.split(',').forEach(function(eInstanceId,i,t){
			// if an application is recorded for this instance id different from the candidate
			if(httpLb[aVNFCindex].application[eInstanceId] != undefined && httpLb[aVNFCindex].application[eInstanceId] != anApplication){
				uniquenessResult += "\n"+anApplication+": SEE instance Id " + eInstanceId +" is already allocated on "+VNFdisplayName+" for http load balancing "+ httpLb[aVNFCindex].application[eInstanceId];
			} else {
				// mark the application as the owner
				httpLb[aVNFCindex].application[eInstanceId] = anApplication; 
			}
			// Same on the composed VNF, only for checking, not for reserving
			if(aVNFCindex != 0 && httpLb[0] != undefined && httpLb[0].application != undefined && httpLb[0].application[eInstanceId] != undefined && httpLb[0].application[eInstanceId] != anApplication){
				uniquenessResult += "\n"+anApplication+" on "+VNFdisplayName+": SEE instance Id " + eInstanceId +" is already allocated on the composed VNF for http load balancing "+ httpLb[0].application[eInstanceId];
			}
		});
	}
	return uniquenessResult;
}

var seeInstancesMax=4;
// Function verifying that all the SEE instance Ids passed as a list of comma separated values in candidateList parameter are valid: 1 <= integer <= seeInstancesMax
// Returns an error message with msgHeader in case of error, or an empty string in case of success
function checkSeeInstanceId(candidateList, msgHeader){
	var result="";
	if(msgHeader != "")msgHeader="\n"+msgHeader+": ";
	candidateList.split(',').forEach(function(candidate){
		var anId = Number(candidate);
		if(Number.isNaN(anId)){result+=msgHeader+"Illegal value for SEE instance Id: "+candidate+"; expecting integer";} 
		if(anId < 1 || anId > seeInstancesMax){result+=msgHeader+"Illegal value for SEE instance Id: "+candidate+"; expecting integer in the range 1 to "+seeInstancesMax;}
	});
	return result;
}

var seePrimaryIpAddr;
var seeSimplexIpAddr;
// Utilities returning a bash if open or close statement on the primary SEE IP addr for the 'i'th VNFC, named 'e'
// Pre requisite: seePrimaryIpAddr, seeSimplexIpAddr and VNFCnames
// Useless if only one VNF, however: returns nothing 
function ifVNFCopen(e,i){
	var ret="";
	var discriminatingIpAddr = seePrimaryIpAddr['MGMT'][i];
	var discriminatingVar = "PRIMARY_SEE_IP_ADDR";
	if(discriminatingIpAddr == undefined || discriminatingIpAddr == '""' || discriminatingIpAddr == ""){
		discriminatingIpAddr = seeSimplexIpAddr['MGMT'][i];
		discriminatingVar = "SIMPLEX_SEE_IP_ADDR";
	}
	if(VNFCnames.length > 1)ret='\n# Restricted to VNF #'+i+': '+e+'\nif [ "${'+discriminatingVar+'}" = "'+discriminatingIpAddr+'" ]; then';
	return ret;
}
function ifVNFCclose(e,i){
	var ret="";
	if(VNFCnames.length > 1)ret='\nfi # closing if on VNF #'+i+': '+e;
	return ret;
}

var consistency = new Object;
var emsRole = new uniqueRole("EMS");
var emsOcmpRole = new uniqueRole("EMS OCMP");
var ocmpVNFC = new uniqueRole("OCMP VNFC");
var emsOcsnfRole = new uniqueRole("EMS OCSNF");
var emsUspmRole = new uniqueRole("EMS USPM");
var kpiRole = new uniqueRole("KPI GUI");
var cStatusRole = new uniqueRole("Consolidated Status");
var vipSipRole = new uniqueRole("SIP balancer virtual IP");
var mysqlRole = new uniqueRole("mysql");
var pgsqlRole = new uniqueRole("pgsql");
var oracleRole = new uniqueRole("oracle");

consistency.initSingle = function (){
	emsRole.init();
	emsOcmpRole.init();
	ocmpVNFC.init();
	emsOcsnfRole.init();
	emsUspmRole.init();
	kpiRole.init();
	cStatusRole.init();
	vipSipRole.init();
	mysqlRole.init();
	oracleRole.init();
	pgsqlRole.init();
}
consistency.init = function (){
	consistency.initSingle();
}

consistency.check = function (){
	// Cross sections consistency checks, cannot be executed locally to the sections
	var warnings = "";
	if(!emsRole.v)warnings+="\nNodes section: EMS role is mandatory";
	if(ocmpVNFC.v && !emsOcmpRole.v)warnings+="\nNodes section: OCMP EMS role is mandatory";
	if(!Networks.search('network','MGMT'))warnings+="\nNetwork section: management interface is mandatory";
	VNFCnames.forEach(function(VNFCname,VNFCindex){
		var VNFdisplayName = VNFCindex != 0 ? "the VNFC " + VNFCname : "the composed VNF";
		warnings+=checkDependency(NativeApps.activateNivrs[VNFCindex] == 'yes', [httpLb[VNFCindex] != undefined], "Nodes vs NativeApps sections on "+VNFdisplayName, ": NIVR and CaaS IVR applications require an HTTP LB VIP or a simplex SEE");
	});
	warnings+=checkDependency(NativeApps.search('CaaS IVR', 'yes'), [vipSipRole.v], "Nodes vs NativeApps sections: ", "CaaS IVR applications require a SIP LB VIP or a simplex OCMP");
	if(oracleRole.v && oracleRole.service == undefined)warnings+="\nMisc section: ORACLE_SERVICE undefined while oracle DB is defined";
	if(oracleRole.v && oracleRole.sysdba == undefined)warnings+="\nSecurity section: NIVRDB_SYSDBA account undefined while oracle DB is defined";
	[ 'oracle', 'pgsql', 'mysql' ].forEach(function(e,i,t){
	warnings+=checkDependency(NativeApps.search('NIVR_DB_TYPE', e), [Nodes.search('DB role', e)], "Nodes vs NativeApps sections: ", "NIVR_DB_TYPE "+e+" requested by NativeApps not hosted by any node");
	});
	if(!Security.search('Property','CERT_AUTH_ALIAS') || !Security.search('Property','CERT_AUTH_PASSWORD'))warnings+="\nSecurity section: missing certification authority: name and password";
	if(!Misc.search('Property','SNMP_TRAP_DESTINATION'))warnings+="\nMisc section: missing SNMP_TRAP_DESTINATION";
	if(Nodes.search('Http LB role','VIP') && !Misc.search('Property','HA_PING_IP_ADDR'))warnings+="\nMisc section: missing Reference IP address for LB HA: HA_PING_IP_ADDR";
	if(Nodes.search('WRTC BE','true') && !WebRTC.search('Function','WEBRTC_SIP_PORT')) warnings+="\nWebRTC section: WebRTC feature requires port definition: WEBRTC_SIP_PORT";
	if(Nodes.search('WRTC BE','true') && !WebRTC.search('Function','WEBRTC_SIPPROXY_PORT')) warnings+="\nWebRTC section: WebRTC feature requires port definition: WEBRTC_SIPPROXY_PORT";
	if(Nodes.search('WRTC BE','true') && !WebRTC.search('Function','WEBRTC_SIPREGISTRAR_PORT')) warnings+="\nWebRTC section: WebRTC feature requires port definition: WEBRTC_SIPREGISTRAR_PORT";
	if(Nodes.search('WRTC BE','true') && !WebRTC.search('Function','WEBRTC_OCMP_TRANSCODER_PORT')) warnings+="\nWebRTC section: WebRTC feature requires port definition: WEBRTC_OCMP_TRANSCODER_PORT";
	if(Nodes.search('WRTC BE','true') && !WebRTC.search('Function','WEBRTC_MEDIA_EXT_END')) warnings+="\nWebRTC section: WebRTC feature requires port definition: WEBRTC_MEDIA_EXT_END";
	warnings+=checkDependency(NativeApps.count('NIVR_DB_TYPE') > 0, [Security.search('Property', 'NIVRDB_ADMIN') && Security.search('Property', 'NIVRDB_ADMIN_PASSWORD') && Security.search('Property', 'NIVRDB_APP') && Security.search('Property', 'NIVRDB_APP_PASSWORD') && Security.search('Property', 'NIVRDB_OPER') && Security.search('Property', 'NIVRDB_OPER_PASSWORD')], "NativeApps vs Security section: NIVR_DB_TYPE ", " requires NIVRDB_ADMIN NIVRDB_ADMIN_PASSWORD NIVRDB_APP NIVRDB_APP_PASSWORD NIVRDB_OPER NIVRDB_OPER_PASSWORD" );
	warnings+=checkDependency(Nodes.search('USPM role', 'Pri'), [Misc.search('Property', 'VNF_CONFIG_DATA_FILE')], "Nodes vs Misc sections:", " USPM middle ware requires VNF_CONFIG_DATA_FILE defining the auxiliary MSE Descriptor");
	
	return warnings;
}

// Class defining a VNF resource named 'title' as an extensible table with a set of 'columns'
// Each column needs to define a 
// - name
// - type (optional)
//		. bool to define a check box
//		. choice to define a drop down menu
//			for that type, a 'choices' attribute is expected to define the list of choices
//		. text (default)
// - value (optional: the default value)
// Two methods linked to buttons at the bottom of the table are to be provided for each VNF resource:
// - build: returns the MSE Descriptor section for this resource as a string; if any issue prevents this build, the check variable should return the error messages 
// - help: provides hints for this resource as a text string
// Convenient methods are offered for a VNF resource:
// search(column, value): to search for a text value in a given column
// display(column, value): set the display style attribute for a given column, where 'value' typically is 'none' to hide a column, and id one by default
// count(column, value): count the number of occurrences of a specific value in a specific column
// isEmpty(): check if the table is empty
 
// Cell width control
var cellWidth="85px";
var boolCellWidth="15px";
var choiceCellWidth="200px";

var _uniqueInputId=1;

// List of VNF resources for applying actions to multiples resources
vnfResources = new Array();

var vnfResource = function(title, columns){
	this.result = "\nWARNING: " + title + " section is not defined yet: please apply and rebuild\n";
	var self = this;
	
	var table = document.createElement('TABLE');
	table.border='1';
	table.id=title;
	
	var tableCaption = document.createElement('CAPTION');
	tableCaption.appendChild(document.createTextNode(title));

	var tableBody = document.createElement('TBODY');
	table.appendChild(tableBody);
	
	var tr = document.createElement('TR');
	tableBody.appendChild(tr);
	var td = document.createElement('TH');
	var addButton = document.createElement('INPUT');
	addButton.type="button";
	addButton.value="Add";
	addButton.setAttribute("onClick", title + ".add();");
	td.appendChild(addButton);
	tr.appendChild(td);

	// Create all columns in this table; set a class concatenating the table and column names for further search
	// Build an array of the names for easy search with name key  when calling the build function
	// The first cell is used for the delete button, skip it
	var iName = new Array(columns.length + 1);
	for (i=0; i<columns.length; i++){
		var td = document.createElement('TH');
		td.className = title + columns[i].name;
		td.appendChild(document.createTextNode(columns[i].name));
		iName[i+1] = columns[i].name;
		var localWidth = cellWidth;
		switch(columns[i].type){
			case 'bool':
				localWidth = boolCellWidth;
				break;
			case 'choice':
				localWidth = choiceCellWidth;
				break;
		}
		if(columns[i].width != undefined)localWidth = columns[i].width;
		td.style.width = localWidth;
		tr.appendChild(td);
	}

	// Attach useful variables to this current object for further asynchronous reference
	self.title = title;
	self.nameIndexes = iName;
	self.columns = columns;
	self.check = "";
	
	// Add a button to trigger the MSE Descriptor build for this section
	var buildButton = document.createElement('INPUT');
	buildButton.type="button";
	buildButton.value="Apply";
	buildButton.className="buildButton";
	buildButton.setAttribute("onClick", "userOutput(" + title + ".build());");
	
	// Add a button to show help 
	var helpButton = document.createElement('INPUT');
	helpButton.type="button";
	helpButton.value="Help";
	helpButton.padding="5px";
	helpButton.className = "helpButton";
	helpButton.setAttribute("onClick", "userOutput(" + title + ".help());");
	
	// Append the new elements to the DOM behind the insertion point, if they dot not exist already
	if(document.getElementById(title) == undefined){
		var myTableDiv = document.getElementById("tableInsertionPoint");
		// Create an anchor for quick reference to this table
		var anchorTable = document.createElement('A');
		anchorTable.setAttribute("name", title);
		// Add a link to this table just before the user result area: a click on this link displays the related section 
		var linkToTable = document.createElement('A');
		linkToTable.setAttribute("href", "#"+title);
		linkToTable.innerHTML=" / "+title;
		linkToTable.setAttribute("onClick", this.title + ".display(true);");
		var userArea = document.getElementById("endOfUserArea");
		userArea.appendChild(linkToTable);
		var linkToTableSummary = linkToTable.cloneNode(true);
		var summary = document.getElementById("summary");
		summary.appendChild(linkToTableSummary);
		var headerTable = document.createElement('H2');
		headerTable.innerHTML=title;

		anchorTable.appendChild(headerTable);
		// Create a specific div for this section, easing management, hide, show, etc.
		var thisTableDiv = document.createElement('div');
		thisTableDiv.id = title+'Section';
		thisTableDiv.appendChild(anchorTable);
		thisTableDiv.appendChild(table);
		thisTableDiv.appendChild(buildButton);
		thisTableDiv.appendChild(helpButton);
		myTableDiv.appendChild(thisTableDiv);
	}
	
	// update the list of VNF resources for actions applying to all elements, like build, import...
	vnfResources.push(this);
};
// Default help 
vnfResource.prototype.help = function(){
	return "No help available";
}
// Default build
vnfResource.prototype.build = function(){
	return "No build instructions defined";
}
// Delete the current line in the table
vnfResource.prototype.delete = function(inputId){
	var table = document.getElementById(this.title);
	var theInput = document.getElementById(inputId);
	var index = theInput.parentNode.parentNode.rowIndex;
	table.deleteRow(index);	
}
// Add a new line in the table
vnfResource.prototype.add = function(){
	var table = document.getElementById(this.title);
	var columns = this.columns;
 
	var rowCount = table.rows.length;
	var row = table.insertRow(rowCount);
	var delButton = document.createElement('INPUT');
	delButton.type="button";
	delButton.value="Del";
	delButton.id="delButton"+(_uniqueInputId++);
	delButton.setAttribute("onClick", this.title + ".delete('"+delButton.id+"');");
	var cell = row.insertCell(0);
	cell.appendChild(delButton);
	for (i=0; i<columns.length; i++){
		var cell = row.insertCell(i+1);
		cell.className = this.title + columns[i].name;
		switch(columns[i].type){
			case 'bool':
				var checkCell = document.createElement('INPUT');
				checkCell.className = this.title + columns[i].name;
				checkCell.type = "checkbox";
				cell.style.width = checkCell.style.width = boolCellWidth;
				cell.appendChild(checkCell);
				break;
			case 'choice':
				var selectCell = document.createElement('SELECT');
				selectCell.className = this.title + columns[i].name;
				var localWidth = choiceCellWidth;
				if(columns[i].width != undefined)localWidth = columns[i].width;
				cell.style.width = selectCell.style.width = localWidth;
				for (j=0; j<columns[i].choices.length; j++){
					var option = document.createElement('OPTION');
					option.value = columns[i].choices[j];
					option.innerHTML = option.value;
					selectCell.appendChild(option);
				}
				// if the default value is not a null string, avoid adding always the same selection:
				// set a default value according to the row in the table, instead of the first choice
				if(columns[i].choices[0] != "")selectCell.value = columns[i].choices[rowCount-1];
				cell.appendChild(selectCell);
				break;
			default:
				var inputCell = document.createElement('INPUT');
				inputCell.className = this.title + columns[i].name;
				var localWidth = cellWidth;
				if(columns[i].width != undefined)localWidth = columns[i].width;
				cell.style.width = inputCell.style.width = localWidth;
				inputCell.type = "text";
				if(columns[i].value != undefined)inputCell.value = columns[i].value;
				cell.appendChild(inputCell);
				break;
		}
	}
	// hide unused columns if the method is available
	if(this['hideUnused'] != undefined)this.hideUnused();
}

// Import from a provided document
// Returns a text string summarizing the import
vnfResource.prototype.import = function(importedDocument){
	var summary = "";
	var table = document.getElementById(this.title);
	var importedTable = importedDocument.getElementById(this.title);
	if(importedTable == null)return summary;
	
	var rowCount = table.rows.length;
	var importedRowCount = importedTable.rows.length;
	var columns = this.columns;
	
	for(var i=1; i < importedRowCount; i++, rowCount++){
		if(summary == "")summary = "\n" + this.title;
		summary += "\n";
		
		// one more line
		this.add();
		
		for (j=0; j<columns.length; j++){
			// Source: 2 cells expected: one for the td element, the second for the input element
			var source = Array.prototype.slice.call(importedTable.rows[i].getElementsByClassName(this.title + columns[j].name));
			// Otherwise, this column is missing in the source document, continue
			if(source.length < 2)continue;
			
			// Destination: j+1 as the first cell is dedicated to the delete button
			var destination=table.rows[rowCount].cells[j+1].childNodes[0];
			switch(columns[j].type){
				case 'bool':
					destination.removeAttribute("checked");
					if(source[1].checked){
						destination.setAttribute("checked", "checked");
					}
					break;
				case 'choice':
					var selectedOption = source[1].selectedIndex;
					var selectedValue = source[1].options[selectedOption].value;
					if(selectedOption != -1){
						// looping over the destination options to select the selected value
						for (selectedOption=destination.options.length;selectedOption--;) { 
						  if(destination.options[selectedOption].value == selectedValue)
						  	break;
						}
						destination.options.selectedIndex=selectedOption;
						if(selectedOption != -1){
							destination.options[selectedOption].setAttribute("selected", "selected");
							if(destination.options[selectedOption].value != "")summary += "\t" + destination.options[selectedOption].value;
						}
					}
					break;
				default:
					destination.value = source[1].value;
					destination.removeAttribute("value");
					destination.setAttribute("value", source[1].value);
					if(destination.value != "")summary += "\t" + destination.value;
					break;
			}	 
		}
	}
	return summary;
}

// Search for a specific value in a specific column
vnfResource.prototype.search = function(column, value){
	var table = document.getElementById(this.title);

	// Search for the column by class name
	var cells = Array.prototype.slice.call( table.getElementsByClassName(this.title + column) );
	return cells.some(function(e,i){
		var boolValue = "___this_should_never_match___";
		var textValue = "___this_should_never_match___";
		if(e.value != undefined)textValue=e.value.valueOf();
		// check box case
		if(e.checked != undefined)boolValue=e.checked.toString();
		var refValue = this.valueOf();
		return boolValue === refValue || textValue === refValue;
		}, 
		value);	// this parameter is passed as this to the function
}

// Count the number of occurrences of a specific value in a specific column
//  If the value is undefined or an empty string, return the count of unique values in this column
vnfResource.prototype.count = function(column, value){
	var table = document.getElementById(this.title);
	if(value == undefined)value = new String("");

	// Search for the column by class name
	var cells = Array.prototype.slice.call( table.getElementsByClassName(this.title + column));
	// Retain values
	var values = cells.map(function(e,i){
		if(e.value != undefined){
			return String(e.value.valueOf());
		} else if(e.checked != undefined) {
			// check box case
			return String(e.checked.toString());
		}
		return String("");
	});
	var filtered = values.filter(function(e,i,t){
		// where e: element in the table, i: index in the table, t: table
		var b = this.valueOf();
		if(b == ""){
			// counting the number of unique occurrences
			// ignore empty items
			if(e == "")return false;
			// Gratitude to https://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array
			var firstOccurence = t.indexOf(e);
			return  firstOccurence === i;
		}
		else
			return e === b;
		}, 
		value);	// this parameter is passed as this to the function
		
	return filtered.length;
}
// Hide or show a specific column, or the full section if no column specified
vnfResource.prototype.display = function(column, display){
	var table = document.getElementById(this.title);
	var section = document.getElementById(this.title+'Section');
	if(display == undefined){
		// The first parameter drives the visibility of the section as a boolean
		section.style.display = column ? '' : 'none';
	}else{
		// Search for the column by class name
		var cells = Array.prototype.slice.call( table.getElementsByClassName(this.title + column) );
		cells.forEach(function(e,i){e.style.display = display ? '' : 'none';});
	}
}

// Check if the table is empty, ie with no cell
vnfResource.prototype.isEmpty = function(){
	var table = document.getElementById(this.title);

	// Search for any cell in the table
	var cells = Array.prototype.slice.call( table.getElementsByTagName('td') );
	
	return cells.length == 0;
}

// Retrieve from the 'row' the value of an input field named 'column' in the list of columns'names 'nameIndexes' 
// Set the attribute of this element accordingly so that the DOM contains it for further saving
vnfResource.prototype.getAndSetValue = function(row, nameIndexes, column, defaultValue, promptText){
	var elem=row.cells[nameIndexes.indexOf(column)].childNodes[0];
	var x=elem.value;
	if(x == "" && defaultValue != undefined && defaultValue != ""){
		if(promptText == undefined)promptText = this.title + " section: " + column + " cannot be blank.";
		elem.value = x = prompt(promptText, defaultValue);
	}
	elem.removeAttribute("value");
	elem.setAttribute("value", x);
	return x;
}
vnfResource.prototype.getAndSetChecked = function(row, nameIndexes, column){
	var elem=row.cells[nameIndexes.indexOf(column)].childNodes[0];
	var x=elem.checked;
	elem.removeAttribute("checked");
	if(x){
		elem.setAttribute("checked", "checked");
	}
	return x;
}
vnfResource.prototype.getAndSetSelection = function(row, nameIndexes, column, defaultSelection){
	var elem=row.cells[nameIndexes.indexOf(column)].childNodes[0];
	var selectedOption=elem.options.selectedIndex;
	if(selectedOption == -1 && defaultSelection != undefined){
		elem.options.selectedIndex=selectedOption=defaultSelection;
	}
	// Remove all existing selected attributes
	for (var i=elem.options.length;i--;) { // looping over the options
	  elem.options[i].removeAttribute("selected");
	}
	var s = elem.options[selectedOption];
	if(s != undefined)s.setAttribute("selected", "selected");
	var x=elem.value;
	return x;
}

// ==================
// Network interfaces
// ==================
var Networks = new vnfResource("Networks", [
	{name:'network', type:'choice', width: '80px', choices:['MGMT', 'APP', 'SIP', 'LBNAT', 'PUBLIC', 'HA', 'DATA', 'M3UA1', 'M3UA2']}, 
	{name:'interface', type:'text', width: '50px', value:'eth0'}, 
	{name:'mask', type:'text', width: '120px', value:'255.255.248.0'}]
	);
	
Networks.help = function(){
	return "Network interfaces names and associated masks" + 
	"\nMGMT is mandatory: all nodes part of the MSE VNF should be connected to the MGMT interface"+
	"\n\tThe hostname command should return the fully qualified domain name on this network, hostname -i the IPv4 address on this same network"+
	"\nAPP: optional application network, typically used by OCMP nodes to collect Ccxml/Vxml scripts through an http load balancer"+
	"\nSIP: optional SIP network used for SIP traffic by OCMP, SEE and OCSNF nodes"+
	"\nLBNAT: optional application network for load balancer in NAT mode, typically used by SEE nodes to deliver Ccxml/Vxml scripts behind an http load balancer"+
	"\nPUBLIC: optional external IP address of nodes visible through an address translation (OCMP and WebRTC Front End nodes OpenStack instances typically)"+
	"\nHA: optional high availability network used by SEE nodes for cluster communication, Pgsql static cluster for replication, and Linux HA nodes as a second corosync network"+
	"\nSEE cluster interfaces:"+
	"\n\t- SEE public bind address refer to the application interface, ie VNF LBNAT or APP or MGMT as fall-backs"+
	"\n\t- EMS public and SEE management refer to the VNF MGMT interface"+ 
	"\nDATA/M3UA: USPM specific networks"+
	"\n\nAll optional networks definition trigger related cells in the Nodes table so that names and addresses can be defined on those interfaces"+
	"\n\nHeat target"+
	"\n\tNetmasks should be consistent across networks"+
	"\n\tThe first netmask in the table sets the network width for all networks."+
	"\n\tThis width defines the maximum number of nodes and networks; it should be in the range 0 to 8, ie:"+
	"\n\t- from mask 255.255.255.0: width: 8, 1 network, 256 nodes"+
	"\n\t- to mask 255.255.255.255: width: 1, 256 networks, 1 node"+
	"\n\t- recommended: 255.255.255.224: width: 5, 8 networks, 32 nodes";
}
	
Networks.build = function(target){
	var nameIndexes = Networks.nameIndexes;
	var result = '\n';
	Networks.check = "";
	var table = document.getElementById('Networks');
	var rowCount = table.rows.length;
	Networks.heatNetworks = new Array();
	Networks.heatMaxNetwork = 0;
	var HeatNetworkCount = Number(Networks.count('network') - 1);
	Networks.heatWidth = undefined;
	
	if(Networks.count('network', 'MGMT') != 1)Networks.check += "\nNetworks: one and only one MGMT is required";
	if(Networks.count('network', 'PUBLIC') < 1 && target == 'Heat')Networks.check += "\nNetworks: missing PUBLIC pseudo interface, required for OpenStack Heat target";
	['APP', 'SIP', 'LBNAT', 'PUBLIC', 'HA', 'DATA', 'M3UA1', 'M3UA2'].forEach(function(name){
		if(Networks.count('network', name) > 1)Networks.check += "\nNetworks: concurrent definitions of "+name+" detected";
	});

	result += '\n# ------------------------------- #';
	result += '\n# Network interfaces definition   #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var networkName=Networks.getAndSetSelection(table.rows[i], nameIndexes, 'network');
		var networkDevice=Networks.getAndSetValue(table.rows[i], nameIndexes, 'interface');
		var networkMask=Networks.getAndSetValue(table.rows[i], nameIndexes, 'mask');
		if(networkName == ""){
			Networks.check += "\nNetworks: undefined network name for interface " + networkDevice;
			continue;
		}
		networkMask.split('.').forEach(function(e,i,t){
			var aByte = Number(e);
			if(Number.isNaN(aByte) || aByte < 0 || aByte > 255 )Networks.check += "\nNetworks: invalid netmask " + networkMask + " for interface " + networkDevice + "; expecting positive integer <= 255, found "+e;
		});
		if(networkDevice != ""){
			result += '\n'+networkName+'_DEVICE='+networkDevice;
			result += '\n'+networkName+'_NETMASK='+networkMask;
			
			if(target == 'Heat'){
				// Heat deployments: all networks have the same width: guess it from the first netmask proposed 
				if(Networks.heatWidth ==  undefined){
					// Use the 4th byte of the mask as the source for network width
					var cidr=Number(networkMask.split('.')[3]);
					// Use the closest integer
					Networks.heatWidth = Math.floor(Math.log(256 - cidr)/Math.log(2));
					Networks.heatMaxInterfaces=Math.pow(2, 8-Networks.heatWidth);
					Networks.heatCidrLength=Number(32-Networks.heatWidth).toString();
					Networks.heatMaxNodes=Math.pow(2, Networks.heatWidth);
					Networks.heatMask="255.255.255."+Number(256-Networks.heatMaxNodes).toString();
					if(HeatNetworkCount > Networks.heatMaxInterfaces)Networks.check += "\nNetworks: network count limited by the netmask "+Networks.heatMask+" for Heat target to " + Networks.heatMaxInterfaces + ": found " + HeatNetworkCount;
				}
				// Heat networks should be named ethN, N integer
				var prefix='eth';
				if(!networkDevice.startsWith(prefix))Networks.check += "\nNetworks: unsupported interface name for Heat target " + networkDevice + ": prefix " + prefix +" required";
				var candidate = networkDevice.substr(prefix.length);
				var interfaceNumber = Number(candidate);
				if(Number.isNaN(interfaceNumber)){
					Networks.check += "\nNetworks: illegal value for interface number "+networkName+" : "+candidate+"; expecting integer";
					continue;
				} 
				Networks.heatNetworks[networkName] = interfaceNumber;
				Networks.heatMaxNetwork = Math.max(Networks.heatMaxNetwork,interfaceNumber);
				if(networkMask !== Networks.heatMask)Networks.check += "\nNetworks: netmask for Heat target is enforced to " + Networks.heatMask + ": found " + networkMask + " on interface " + networkName;
			}
		}
	}

	// update visible networks in the nodes table
	Nodes.hideUnused();

	// local check
	if(Networks.check != "")result = Networks.check;
	
	return result;
}

// Add one network by default, for MGMT typically
if(Networks.isEmpty())Networks.add();

// ===========================
// Nodes resource
// ===========================
var sipGrpPrefix='Grp'
var Nodes= new vnfResource("Nodes", [
	{name:'MGMT fqdn', type:'text'}, 
	{name:'MGMT IP addr', type:'text'},
	{name:'PUBLIC IP addr', type:'text'},  
	{name:'VNFC', type:'text', width:'55px'}, 
	{name:'ReFrsh GRP', type:'choice', choices:['', '1', '2', '3', '4', '5', '6', '7', '8', '9'], width:'55px'},
	{name:'MSE EMS', type:'bool'},
	{name:'OCMP EMS', type:'bool'},
	{name:'OCSNF EMS', type:'bool'},
	{name:'USPM EMS', type:'bool'},
	{name:'KPI GUI', type:'bool'},
	{name:'Cons Stat', type:'bool'},
	{name:'WRTC BE', type:'bool'},
	{name:'WRTC FE', type:'bool'},
	{name:'WRTC Pxy', type:'bool'},
	{name:'WRTC Trcdr', type:'bool'},
	{name:'SEE role', type:'choice', choices:['', 'Spx', 'Pri', 'Sec', 'Wit', 'Nod', 'N+W'], width:'55px'},
	{name:'USPM role', type:'choice', choices:['', 'Pri', 'Sec', 'BE', 'Simulap'], width:'50px'},
	{name:'Http LB role', type:'choice', choices:['', 'Pri', 'Sec', 'VIP'], width:'50px'},
	{name:'OC SNF', type:'choice', choices:['', 'Spx', 'Pri', 'Sec', 'VIP', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'OCMP role', type:'choice', choices:['', 'Spx', 'Pri', 'Sec', 'Nod'], width:'50px'},
	{name:'Linux HA role', type:'choice', choices:['', 'Pri', 'Sec', 'Qrm'], width:'50px'},
	{name:'PgSQL HA', type:'choice', choices:['', 'Pri', 'Sec', 'Mstr'], width:'50px'},
	{name:'Redis HA', type:'choice', choices:['', 'Pri', 'Sec', 'ServerSentinel', 'Sentinel'], width:'80px'},
	{name:'DB role', type:'choice', choices:['', 'mysql', 'pgsql', 'redis', 'redisVolatile', 'redisSpare', 'redisLazy', 'mongo', 'oracle'], width:'80px'},
	{name:'DB Port', type:'text'},
	{name:'APP fqdn', type:'text'}, 
	{name:'APP IP addr', type:'text'}, 
	{name:'SIP fqdn', type:'text'}, 
	{name:'SIP IP addr', type:'text'}, 
	{name:'NAT fqdn', type:'text'}, 
	{name:'NAT IP addr', type:'text'}, 
	{name:'HA fqdn', type:'text'}, 
	{name:'HA IP addr', type:'text'}, 
	{name:'DATA fqdn', type:'text'}, 
	{name:'DATA IP addr', type:'text'}, 
	{name:'M3UA1 fqdn', type:'text'}, 
	{name:'M3UA1 IP addr', type:'text'}, 
	{name:'M3UA2 fqdn', type:'text'}, 
	{name:'M3UA2 IP addr', type:'text'}
	]
	);
	
Nodes.help = function(){
	return "Nodes and roles definition and assignement"+
	"\n<network> fqdn/IP addr: name and IP address on the <network> interface" +	
	"\nVNFC: (optional) VNF component name: only SEE clusters and HTTP Load balancer can be part of a VNFC" +
	"\n\tso that several SEE clusters can be instantiated in one single composed VNF"+
	"\n\tonce defined, a VNFC can be associated to resources restricted to this specific SEE cluster"+
	"\nReFrsh GRP: up to 9 groups of nodes can be defined by an Id, in order to schedule an on line VFN refresh :"+
	"\n\tall nodes belonging to a same group are refreshed concurrently, groups are refreshed by ascending Id order "+
	"\nMSE EMS: Element Manager for the whole MSE VNF"+
	"\nOCMP EMS: Element Manager for the OCMP VNFC, defaults to MSE EMS"+
	"\nOCSNF EMS: Element Manager for the OCSNF/LinuxHA VNFC, defaults to MSE EMS"+	
	"\nUSPM EMS: Element Manager for the USPM VNFC, defaults to MSE EMS"+
	"\nKPI GUI: (demo purpose) node displaying Key Performance Indicators as SNMP traps received on the EMS; requires SEE and MCM running on this node"+
	"\n\tURI: http://<node>:8080/mcm/resources/_nivr/gui/topology/nivr-ems-alarms.html"+
	"\nCons Stat: the consolidated status of the whole VNF, defaults to EMS"+
	"\nSEE role: role of this node in an SEE cluster"+
	"\nWRTC BE: activate WebRTC Back end role"+
	"\nWRTC FE: activate WebRTC Front end role"+	
	"\nWRTC Pxy: activate WebRTC SIP proxy role	"+
	"\nWRTC Trcdr: activate WebRTC transcoder role"+	
	"\nHttp LB role: role of this node in an HTTP load balancer: primary, secondary, vip"+	
	"\nLinux HA role: role of this node in Linux HA cluster: primary, secondary, quorum"+	
	"\nOC SNF role: role of this node in an SIP load balancer: primary, secondary, vip, back-end"+
	"\n\tGrpN: membership of the back-ends group N for OCSNF dispatching policy definition in OCSNFpolicy table"+ 
	"\nPgSQL HA: role of this node in an PostgreSQL HA cluster:"+
	"\n\tprimary, secondary: the two nodes hosting a PgSQL Linux HA resource; the VIP associated to this resource is the node which dbrole is pgsql"+
	"\n\tmaster: the static master node hosting the read/write PgSQL database, replicated on all nodes which dbrole is pgsql"+
	"\nRedis HA role: two Redis HA implementations available:"+
	"\n- Linux HA based: one VIP is instantiated for each redis entry defined in DB role column."+
	"\n\trequires Redis HA primary and secondary roles defined"+
	"\n\tCo-location with SEE nodes *not* supported"+
	"\n- Redis Sentinel based: "+
	"\n\tA Sentinel HA cluster managing all redis instances is built with the nodes playing a Sentinel or ServerSentinel role, plus all nodes playing a redis DB role."+
	"\n\tOne redis instance is instantiated for each redis entry defined in DB role column."+
	"\n\tAlternatively, Redis instances can be defined in the RedisInstance section."+
	"\n\tCo-location with SEE nodes is supported"+
	"\n\tA valid cluster requires a minimum of 3 sentinels."+
	"\nUSPM role: role of this node in an USPM cluster: primary, secondary, backend, simulap"+
	"\n\tNOTE for Simulap: The simulap node is defined only on the management network in the MSE Descriptor."+
	"\n\tAddresses on other interfaces are guessed at run time from the network configuration"+
	"\n\t=> pre requisite on the target node: data and m3ua1 networks are configured"+
	"\nOCMP role: role of this node in an OCMP cluster: primary, secondary, node"+
	"\nDB role:"+
	"\n\tDatabase type instantiated on this node acting either as"+
	"\n\t\tStandalone: pgqsl, redis, mongo, oracle, mysql or"+
	"\n\t\tVirtual IP in a Linux HA cluster: pgsql, redis or"+
	"\n\t\tNode in a replicating cluster: pgsql, redis."+
	"\n\tOR"+
	"\n\tReference to a foreign existing database if this node is not instantiated as part of this VNF."+
	"\nRedis instances:"+
	"\n\tResources are named as the short host name of the VIP or node on the management network (non alpha numerical character are replaced with an underscore)"+
	"\n\tFour modes available:"+ 
	"\n\t- redis: persistency and active/active (both nodes are active and write to disk)"+
	"\n\t- redisVolatile: no persistency and active/active (both nodes are active but do not write to disk)"+
	"\n\t- redisSpare: persistency and active/spare (one node active at once and write to disk)"+
	"\n\t- redisLazy: no persistency and active/spare (one node active at once and no write to disk)"+
	"\nDB Port: port number used for this database (redis, mongo, oracle)"+
	"\n\tFor Redis Sentinel mode, a second port may be defined for the Sentinel process, e.g. 6379,16379"+
	"\n\tThe default value is the redis port number plus an offset defined as REDIS_SENTINEL_PORT_OFFSET in the Misc section (default 20000)"
	;
}

Nodes.build = function(target){
	// Consistency checks reset
	consistency.initSingle();
	Nodes.check = "";
	
	var nameIndexes = Nodes.nameIndexes;
	var result = "\n";
	var table = document.getElementById("Nodes");
	var rowCount = table.rows.length;
	
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	// How many refresh groups to manage?
	var nbRefreshGroups = Nodes.count('ReFrsh GRP');
	var refreshGroups = new Array();
	// Reset the VNFC definition list, and insert a blank one, the main composed VNF
	VNFCnames = new Array();
	VNFCnames.push("");
	// Reset the http LB definition list
	httpLb = new Array();
	// List of SEE nodes *non* USPM back end: cannot deploy Messaging Gateway if one or more SEE node is not an USPM back end
	var seeNodesNonUspmBackEnd = new Array();
	// For all interfaces concerned with SEE roles
	var seeNetworks = ['MGMT', 'APP', 'SIP', 'LBNAT', 'HA'];
	var seeSimplexNames = new Array();
	var seePrimaryNames = new Array();
	var seeSecondaryNames = new Array();
	var seeWitnessNames = new Array();
	var seeNodesNames = new Array();
	seeSimplexIpAddr = new Array();
	seePrimaryIpAddr = new Array();
	var seeSecondaryIpAddr = new Array();
	var seeWitnessIpAddr = new Array();
	var seeNodesIpAddr = new Array();
	seeNetworks.forEach(function(e,i,t){
		seeSimplexNames[e] = new Array(nbVNFC);
		seePrimaryNames[e] = new Array(nbVNFC);
		seeSecondaryNames[e] = new Array(nbVNFC);
		seeWitnessNames[e] = new Array(nbVNFC);
		seeNodesNames[e] = new Array(nbVNFC);
		seeSimplexIpAddr[e] = new Array(nbVNFC);
		seePrimaryIpAddr[e] = new Array(nbVNFC);
		seeSecondaryIpAddr[e] = new Array(nbVNFC);
		seeWitnessIpAddr[e] = new Array(nbVNFC);
		seeNodesIpAddr[e] = new Array(nbVNFC);
	});
	// Network interfaces concerned with Linux HA
	linuxHANetworks = ['MGMT', 'HA'];
	
	// For all interfaces concerned with HTTP LB roles
	var httpLbNetworks = ['MGMT', 'APP', 'LBNAT'];
	var httpLbPrimaryNames = new Array();
	var httpLbSecondaryNames = new Array();
	var httpLbVipNames = new Array();
	var httpLbPrimaryIpAddr = new Array();
	var httpLbSecondaryIpAddr = new Array();
	var httpLbVipIpAddr = new Array();
	httpLbNetworks.forEach(function(e,i,t){
		httpLbPrimaryNames[e] = new Array(nbVNFC);
		httpLbSecondaryNames[e] = new Array(nbVNFC);
		httpLbVipNames[e] = new Array(nbVNFC);
		httpLbPrimaryIpAddr[e] = new Array(nbVNFC);
		httpLbSecondaryIpAddr[e] = new Array(nbVNFC);
		httpLbVipIpAddr[e] = new Array(nbVNFC);
	});
	
	var ocmpNodesCount = 0;
	var uspmBeNodesCount = 0;
	var REDIS_INSTANCE_ID = new Array();
	var REDIS_HOST = new Array();
	REDIS_HOST['MGMT'] = new Array();REDIS_HOST['HA'] = new Array(); REDIS_HOST['APP'] = new Array();
	var REDIS_IP_ADDR = new Array();
	REDIS_IP_ADDR['MGMT'] = new Array();REDIS_IP_ADDR['HA'] = new Array();REDIS_IP_ADDR['APP'] = new Array();
	var REDIS_PORT = new Array();
	var REDIS_PERSISTENCE = new Array();
	var REDIS_SPARE = new Array();
	var REDIS_SENTINEL = new Array();
	REDIS_SENTINEL['MGMT'] = new Array();REDIS_SENTINEL['HA'] = new Array();REDIS_SENTINEL['APP'] = new Array();
	var REDIS_SENTINEL_PORT = new Array();
	var REDIS_SENTINEL_IP_ADDR = new Array();
	REDIS_SENTINEL_IP_ADDR['MGMT'] = new Array();REDIS_SENTINEL_IP_ADDR['HA'] = new Array();REDIS_SENTINEL_IP_ADDR['APP'] = new Array();
	var seeConnectivities = new String();
	var sipGroups;
	var pgsqlNodeName = new Array(nbVNFC);
	var pgsqlNodeIp = new Array(nbVNFC);
	var isRedisSentinel = new Array(nbVNFC);
	var heatNodes = new Array();
	
	result += "\n# ------------------------------- #";
	result += "\n# Nodes and roles definition      #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		
		var row = table.rows[i];
		var VNFCName	=	Nodes.getAndSetValue(row, nameIndexes, 'VNFC');
		// if this VNFC is unknown, add it
		if(VNFCnames.indexOf(VNFCName)== -1)VNFCnames.push(VNFCName);
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		var VNFdisplayName = "the composed VNF";
		if(VNFCindex != 0)VNFdisplayName = "the VNFC " + VNFCName;
		
		// Read the network definitions 'MGMT', 'APP', 'SIP', 'LBNAT', 'PUBLIC', 'HA'
		var nodeName		=	Nodes.getAndSetValue(row, nameIndexes, 'MGMT fqdn');
		var nodeIpAddr		=	Nodes.getAndSetValue(row, nameIndexes, 'MGMT IP addr');
		var nodeAppName		=	Nodes.getAndSetValue(row, nameIndexes, 'APP fqdn');
		var nodeAppIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'APP IP addr');
		var nodeSipName		=	Nodes.getAndSetValue(row, nameIndexes, 'SIP fqdn');
		var nodeSipIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'SIP IP addr');
		var nodeNatName		=	Nodes.getAndSetValue(row, nameIndexes, 'NAT fqdn');
		var nodeNatIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'NAT IP addr');
		var nodeHaName		=	Nodes.getAndSetValue(row, nameIndexes, 'HA fqdn');
		var nodeHaIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'HA IP addr');
		var nodePubIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'PUBLIC IP addr');
		var nodeDataName	=	Nodes.getAndSetValue(row, nameIndexes, 'DATA fqdn');
		var nodeDataIpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'DATA IP addr');
		var nodeM3ua1Name	=	Nodes.getAndSetValue(row, nameIndexes, 'M3UA1 fqdn');
		var nodeM3ua1IpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'M3UA1 IP addr');
		var nodeM3ua2Name	=	Nodes.getAndSetValue(row, nameIndexes, 'M3UA2 fqdn');
		var nodeM3ua2IpAddr	=	Nodes.getAndSetValue(row, nameIndexes, 'M3UA2 IP addr');
		var nodePort		=	Nodes.getAndSetValue(row, nameIndexes, 'DB Port');
		
		// Read the roles definition
		var isCStatus		=	Nodes.getAndSetChecked(row, nameIndexes, 'Cons Stat');
		var isEms			=	Nodes.getAndSetChecked(row, nameIndexes, 'MSE EMS');
		var isOcmpEms		=	Nodes.getAndSetChecked(row, nameIndexes, 'OCMP EMS');
		var isOcsnfEms		=	Nodes.getAndSetChecked(row, nameIndexes, 'OCSNF EMS');
		var isUspmEms		=	Nodes.getAndSetChecked(row, nameIndexes, 'USPM EMS');
		var isKpiGui		=	Nodes.getAndSetChecked(row, nameIndexes, 'KPI GUI');
		var isWrtcBE		=	Nodes.getAndSetChecked(row, nameIndexes, 'WRTC BE');
		var isWrtcFE		=	Nodes.getAndSetChecked(row, nameIndexes, 'WRTC FE');
		var isWrtcPxy		=	Nodes.getAndSetChecked(row, nameIndexes, 'WRTC Pxy');
		var isWrtcTranscoder=	Nodes.getAndSetChecked(row, nameIndexes, 'WRTC Trcdr');
		var seeRole			=	Nodes.getAndSetSelection(row, nameIndexes, 'SEE role');
		var linuxHaRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'Linux HA role');
		var httpLbRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'Http LB role');
		var sipLbRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'OC SNF');
		var pgsqlHaRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'PgSQL HA');
		var redisHaRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'Redis HA');
		var dbRole			=	Nodes.getAndSetSelection(row, nameIndexes, 'DB role');
		var uspmRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'USPM role');
		var ocmpRole		=	Nodes.getAndSetSelection(row, nameIndexes, 'OCMP role');
		var refreshGroup	=	Nodes.getAndSetSelection(row, nameIndexes, 'ReFrsh GRP');
		
		// Collect the short name of this node in the short names array for Heat template build
		var shortName = nodeName.substr(0, nodeName.indexOf('.'));
		var theHeatNode = new heatNode(shortName);
		
		if(target == 'Heat'){
			// IP addresses will be known at instantiation time: 
			// Replace undefined values with place holders resolved later
			// Push the network interface number in the interfaces list for this node
			if(nodeIpAddr == "?")		{nodeIpAddr="~"+shortName+		"_mgmt~";	theHeatNode.interfaces.push(Networks.heatNetworks['MGMT']);}
			if(nodeAppIpAddr == "?")	{nodeAppIpAddr="~"+shortName+	"_app~";	theHeatNode.interfaces.push(Networks.heatNetworks['APP']);}
			if(nodeSipIpAddr == "?")	{nodeSipIpAddr ="~"+shortName+	"_sip~";	theHeatNode.interfaces.push(Networks.heatNetworks['SIP']);}
			if(nodeNatIpAddr == "?")	{nodeNatIpAddr="~"+shortName+	"_nat~";	theHeatNode.interfaces.push(Networks.heatNetworks['LBNAT']);}
			if(nodePubIpAddr == "?")	{nodePubIpAddr="~"+shortName+	"_pub~";	theHeatNode.interfaces.push(heatPublicInterface);}
			if(nodeHaIpAddr == "?")		{nodeHaIpAddr="~"+shortName+	"_ha~";		theHeatNode.interfaces.push(Networks.heatNetworks['HA']);}
			if(nodeDataIpAddr == "?")	{nodeDataIpAddr="~"+shortName+	"_data~";	theHeatNode.interfaces.push(Networks.heatNetworks['DATA']);}
			if(nodeM3ua1IpAddr == "?")	{nodeM3ua1IpAddr="~"+shortName+	"_m3ua1~";	theHeatNode.interfaces.push(Networks.heatNetworks['M3UA1']);}
			if(nodeM3ua2IpAddr == "?")	{nodeM3ua2IpAddr="~"+shortName+	"_m3ua2~";	theHeatNode.interfaces.push(Networks.heatNetworks['M3UA2']);}
		}
		
		var nodeNames		= new Array();
		var nodeIpAddresses	= new Array();
		nodeNames['MGMT'] 		=	nodeName;
		nodeIpAddresses['MGMT']	=	nodeIpAddr;
		nodeNames['APP'] 		=	nodeAppName;
		nodeIpAddresses['APP']	=	nodeAppIpAddr;
		nodeNames['SIP']		=	nodeSipName;
		nodeIpAddresses['SIP']	=	nodeSipIpAddr;
		nodeNames['LBNAT']		=	nodeNatName;
		nodeIpAddresses['LBNAT']=	nodeNatIpAddr;
		nodeNames['HA']			=	nodeHaName;
		nodeIpAddresses['HA']	=	nodeHaIpAddr;
		
		if(refreshGroup != ""){
			// no refresh supported on USPM out of the EMS and backends
			if(uspmRole == "" || uspmRole == "BE"){
				if(refreshGroups[refreshGroup] == undefined)refreshGroups[refreshGroup] = new Array();
				refreshGroups[refreshGroup].push(nodeIpAddr);
			}else{
				Nodes.check+= "\nUSPM middle ware nodes should not be part of a refresh group; USPM EMS manages the whole middle ware refresh";
			}	
		}
		
		// co-location and dependency checks
		Nodes.check += checkDependency(nodeName == "" || nodeIpAddr == "", [httpLbRole == 'VIP' && nodeAppIpAddr != "", sipLbRole == 'VIP' && nodeSipIpAddr != ""], "Nodes section: MGMT FQDN and IP address are required", " (except for HTTP/SIP VIP roles)");
		Nodes.check += checkUnicity([dbRole != "" , ocmpRole != ""], nodeName + ": Database and OCMP");
		Nodes.check += checkUnicity([seeRole != "" , isOcmpEms && Nodes.search('OCMP role', 'Pri')], nodeName + ": SEE role and OCMP cluster EMS");
		Nodes.check += vipSipRole.setIfNotOrAlert(sipLbRole == 'VIP');
		Nodes.check += mysqlRole.setIfNotOrAlert(dbRole == 'mysql');
		Nodes.check += oracleRole.setIfNotOrAlert(dbRole == 'oracle');
		Nodes.check += checkDependency(pgsqlHaRole == 'Mstr', [dbRole == 'pgsql'], nodeName + ": PgSQL HA Master role requires a pgsql DB role, not ", dbRole+".");
		Nodes.check += checkDependency(pgsqlHaRole == 'Pri' || pgsqlHaRole == 'Sec', [dbRole == ''], nodeName + ": PgSQL HA "+pgsqlHaRole+" role is incompatible with dbrole ", dbRole);
		Nodes.check += checkDependency(pgsqlHaRole == 'Pri' || pgsqlHaRole == 'Sec', [Nodes.count('DB role', 'pgsql') > 0], nodeName + ": PgSQL HA "+pgsqlHaRole+" role requires one VIP: ", "missing a pgsql role in DB role");
		Nodes.check += checkDependency(pgsqlHaRole == 'Pri' || pgsqlHaRole == 'Sec', [Nodes.count('PgSQL HA', 'Mstr') == 0], nodeName + ": PgSQL HA "+pgsqlHaRole+" role is incompatible with ", "a Pgsql HA Master role");
		Nodes.check += checkDependency(pgsqlHaRole == 'Pri', [Nodes.count('PgSQL HA', 'Sec') == 1], nodeName + ": PgSQL HA Primary role requires one and only one Secondary role: ", "found "+Nodes.count('PgSQL HA', 'Sec'));
		Nodes.check += checkDependency(dbRole == 'pgsql', [Nodes.count('DB role', 'pgsql') < 2, seeRole != "" && seeRole != "Wit"], nodeName + ": PgSQL replicating node must be co-located with an SEE node, not ", seeRole+".");
		Nodes.check += emsRole.setIfNotOrAlert(isEms);
		Nodes.check += emsOcmpRole.setIfNotOrAlert(isOcmpEms);
		Nodes.check += emsOcsnfRole.setIfNotOrAlert(isOcsnfEms);
		Nodes.check += emsUspmRole.setIfNotOrAlert(isUspmEms);
		Nodes.check += kpiRole.setIfNotOrAlert(isKpiGui);
		Nodes.check += cStatusRole.setIfNotOrAlert(isCStatus);
		Nodes.check += checkDependency(isWrtcBE, [ seeRole == 'Spx',  seeRole == 'Pri' ], "Nodes: "+nodeName + ": WebRTC Back End and SEE simplex or primary");
		Nodes.check += checkDependency(isWrtcPxy, [isWrtcBE], "Nodes: "+nodeName + ": WebRTC SIP Proxy and WebRTC Back End");
		Nodes.check += checkDependency(isWrtcTranscoder, [ocmpRole != ""], "Nodes: "+nodeName + ": WebRTC transcoder and OCMP");
		Nodes.check += checkDependency(dbRole == "oracle", [nodePort != ""], "Nodes: "+nodeName + ": Port and oracle ");
		Nodes.check += checkDependency(dbRole == "mongo", [nodePort != ""], "Nodes: "+nodeName + ": Port and mongo ");
		Nodes.check += checkDependency(uspmRole != "", [nodeDataIpAddr != ""], "Nodes: "+nodeName + ": USPM role and DATA IP address ");
		Nodes.check += checkDependency(uspmRole == "Pri" || uspmRole == "Sec", [nodeM3ua1Name != "" && nodeM3ua1Name != nodeM3ua2Name], "Nodes: "+nodeName + ": USPM role and M3UA1 IP address distinct from M3UA2");
		Nodes.check += checkUnicity([seeRole == "Spx" , seeSimplexIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": SEE simplex role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([seeRole == "Pri" , seePrimaryIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": SEE primary role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([seeRole == "Sec" , seeSecondaryIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": SEE secondary role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([seeRole == "Wit" || seeRole == "N+W", seeWitnessIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": SEE witness role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([httpLbRole == "Pri" , httpLbPrimaryIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": httpLb primary role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([httpLbRole == "Sec" , httpLbSecondaryIpAddr['MGMT'][VNFCindex] != undefined], "Nodes: "+nodeName + ": httpLb secondary role on " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([httpLbRole == "VIP" , httpLbVipIpAddr['MGMT'][VNFCindex] != undefined], nodeName + ": httpLb Vip role on  " + VNFdisplayName, " is duplicated.");
		Nodes.check += checkUnicity([linuxHaRole != "" , seeRole != ""], nodeName + ": Linux HA and SEE roles", " are mutually exclusive.");
		Nodes.check += checkUnicity([redisHaRole  == "Pri" || redisHaRole  == "Sec", seeRole != ""], nodeName + ": Redis Linux HA and SEE roles", " are mutually exclusive.");
		Nodes.check += checkUnicity([pgsqlHaRole == "Pri" || pgsqlHaRole == "Sec", seeRole != ""], nodeName + ": Pgsql HA and SEE roles", " are mutually exclusive.");
		Nodes.check += checkUnicity([sipLbRole == "Pri" || sipLbRole == "Sec", seeRole != ""], nodeName + ": OC SNF HA and SEE roles", " are mutually exclusive.");
		Nodes.check += checkDependency(VNFCindex != 0, [linuxHaRole == "", seeRole != "", httpLbRole != "" ],"Nodes: "+nodeName + " on " + VNFdisplayName + ": linuxHaRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [sipLbRole == "", seeRole != "", httpLbRole != "" ], 	"Nodes: "+nodeName + " on " + VNFdisplayName + ": sipLbRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [pgsqlHaRole == "", seeRole != "", httpLbRole != ""], "Nodes: "+nodeName + " on " + VNFdisplayName + ": pgsqlHaRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [redisHaRole  != "Pri", redisHaRole  != "Sec", seeRole != "", httpLbRole != "" ],"Nodes: "+nodeName + " on " + VNFdisplayName + ": redis on Linux HA not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [dbRole == "", seeRole != "", httpLbRole != "" ], 	"Nodes: "+nodeName + " on " + VNFdisplayName + ": dbRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [uspmRole == "", seeRole != "", httpLbRole != "" ], 	"Nodes: "+nodeName + " on " + VNFdisplayName + ": uspmRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency(VNFCindex != 0, [ocmpRole == ""], 	"Nodes: "+nodeName + " on " + VNFdisplayName + ": ocmpRole not supported on a VNFC", " (SEE cluster and HTTP LB roles only)");
		Nodes.check += checkDependency((nodeHaName != "" || nodeHaIpAddr != "") && (linuxHaRole != "" || redisHaRole != ""), [Security.search('Property','NIVRDB_LINUXHA_PASSWORD')], 
			"Nodes vs Security sections: "+ nodeName+" connection to HA network", " requires NIVRDB_LINUXHA_PASSWORD");
		Nodes.check += checkDependency(ocmpRole != "", [
			Licensing.search('Feature', 'SEE_SIP_SERIAL') && Licensing.search('Feature', 'SEE_SIP_CODEWORD') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_KEY') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_EXPIRES') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_DESCRIPTION') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_VXML_INSTANCES') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_ASR_INSTANCES') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_TTS_INSTANCES') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_FEATURE_NAME') && 
			Licensing.search('Feature', 'OCMP_BRE_LIC_FEATURE_INSTANCES')], 
			nodeName + ": OCMP SIP and BRE licensing: SEE_SIP_SERIAL SEE_SIP_CODEWORD OCMP_BRE_LIC_KEY OCMP_BRE_LIC_EXPIRES OCMP_BRE_LIC_DESCRIPTION OCMP_BRE_LIC_VXML_INSTANCES OCMP_BRE_LIC_ASR_INSTANCES OCMP_BRE_LIC_TTS_INSTANCES OCMP_BRE_LIC_FEATURE_NAME OCMP_BRE_LIC_FEATURE_INSTANCES",
			" are required in the Licensing section");
		Nodes.check += checkDependency(seeRole != "", [
			Licensing.search('Feature', 'SEE_SIP_SERIAL') && Licensing.search('Feature', 'SEE_SIP_CODEWORD')], 
			nodeName + ": SEE SIP licensing: SEE_SIP_SERIAL SEE_SIP_CODEWORD ",
			" are required in the Licensing section, for SEE version < 3.7");
		Nodes.check += checkDependency(nbVNFC > 0 && dbRole != "", [seeRole == "" && httpLbRole == ""], 
			"Nodes: "+nodeName + " cannot play a " + dbRole+" DB role concurrently with "+seeRole+" SEE role and "+httpLbRole+" HTTP LB role because databases are shared across the composed VNF and ", nbVNFC + " VNFC(s)");
		Nodes.check += checkDependency(dbRole.startsWith("redis") || redisHaRole.endsWith("Sentinel"), [Security.search('Property','NIVRDB_LINUXHA_PASSWORD')], 
			"Nodes vs Security: "+nodeName + " playing a " + dbRole+" "+redisHaRole+" DB role misses NIVRDB_LINUXHA_PASSWORD in the Security section", " since all redis resources are protected with NIVRDB_LINUXHA_PASSWORD as password ");
			
		// Check all names and addresses are defined for configured interfaces
		// Except for LBNAT interface, which may be used to specify address translation on OCMP nodes
		// Out of a pure witness, SEE requires APP network if the interface is defined, unless LBNAT is defined
		Nodes.check += checkDependency(Networks.search('network', 'APP') && seeRole != "" && seeRole != "Wit", [nodeAppName != "" && nodeAppIpAddr != "", nodeNatName != "" && nodeNatIpAddr != ""], 
			nodeName + " " + nodeAppName + ": APP network interface definition ",
			" requires both name and IP address on APP network");
		// OCMP and LB require APP network if the interface is defined 
		Nodes.check += checkDependency(Networks.search('network', 'APP') && (ocmpRole != "" || httpLbRole != "" ), [nodeAppName != "" && nodeAppIpAddr != ""], 
			nodeName + " " + nodeAppName + ": APP network interface definition ", " requires both name and IP address on APP network");
		// OCMP, SIPLB and non pure witness SEE require SIP network if the interface is defined
		Nodes.check += checkDependency(Networks.search('network', 'SIP') && (ocmpRole != "" || ( seeRole != "" && seeRole != "Wit" ) || sipLbRole != "") , [nodeSipName != "" && nodeSipIpAddr != ""], 
			nodeName + " " + nodeSipName + ": SIP network interface definition ", " requires both name and IP address on SIP network");
		
		// Select a Heat profile for this node, default to small, performance for OCMP, standard for SEE nodes
		if(ocmpRole != "")theHeatNode.flavor = 'flavorPerformance';
		if(seeRole != "" && seeRole != "Wit")theHeatNode.flavor = 'flavorStandard'; 
		
		// Store SEE nodes not playing an USPM back end role: Messaging Gateway does not support such nodes
		if(seeRole != "" && seeRole != "Wit" && uspmRole != 'BE')seeNodesNonUspmBackEnd.push(nodeName);
		
		// Build the MSE Descriptor
		if(isCStatus){
			result += "\n\n# Consolidated Status      #";
			result += getNameIpAddr("CONSOLIDATED_STATUS_EMS", "", nodeName, nodeIpAddr);
			result += "\nCONSOLIDATED_STATUS_LOG=${nivr_nfv_result}";
		}
		if(isEms){
			result += "\n\n# VNF Element Manager      #";
			result += getNameIpAddr("NIVR_EMS", "", nodeName, nodeIpAddr);
			// The EMS short name for Heat template build should be the last element in the shortNames array, so that the descriptor is passed as EMS raw data 
			heatNodes.push(theHeatNode); 
		}else{
			// Is this node a virtual IP?
			theHeatNode.isVIP |= httpLbRole == 'VIP';
			theHeatNode.isVIP |= sipLbRole == 'VIP';
			// Detect Linux HA virtual IPs for pgsql and redis databases
			theHeatNode.isVIP |= ( dbRole == 'pgsql' && Nodes.search('PgSQL HA', 'Pri') ) || ( dbRole.indexOf('redis') != -1 && Nodes.search('Redis HA', 'Pri') );   
			
			// Is this node hosting virtual IP(s)?
			// HTTP load balancer
			theHeatNode.hasVIP |= httpLbRole == 'Pri' || httpLbRole == 'Sec';
			// Linux HA cluster
			theHeatNode.hasVIP |= linuxHaRole == 'Pri' || linuxHaRole == 'Sec';
			theHeatNode.hasVIP |= sipLbRole == 'Pri' || sipLbRole == 'Sec';
			theHeatNode.hasVIP |= pgsqlHaRole == 'Pri' || pgsqlHaRole == 'Sec';
			theHeatNode.hasVIP |= redisHaRole == 'Pri' || redisHaRole == 'Sec';
			
			// Non EMS names are pushed in first place to let the last place to the EMS node
			heatNodes.unshift(theHeatNode); 
		}
		if(isOcmpEms){
			result += "\n\n# OCMP VNF Component Element Manager      #";
			result += getNameIpAddr("OCMP_EMS", "", nodeName, nodeIpAddr);
		}
		if(isOcsnfEms){
			result += "\n\n# OCSNF VNF Component Element Manager      #";
			result += getNameIpAddr("OCSNF_EMS", "", nodeName, nodeIpAddr);
		}
		if(isUspmEms){
			result += "\n\n# USPM VNF Component Element Manager      #";
			result += getNameIpAddr("EMS_USPM", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("EMS_USPM", "_DATA", nodeDataName, nodeDataIpAddr);
		}
		if(isKpiGui){
			result += "\n\n# Host IP address displaying KPI alarms (demo purpose)\n# URI: http://"+nodeIpAddr+":8080/mcm/resources/_nivr/gui/topology/nivr-ems-alarms.html";
			result += getNameIpAddr("APP_KPI_GUI", "", "", nodeIpAddr);
		}
		switch(sipLbRole){
			case 'Spx':
				// act as a primary but connect the vip to this primary
				vipSipRole.v = true;
				// Definitions on the SIP network have precedence on the MGMT network
				var vsipName = nodeSipName;
				var vsipIpAddr = nodeSipIpAddr;
				if(vsipName == "" || vsipIpAddr == ""){
					vsipName = nodeName; vsipIpAddr = nodeIpAddr;
				}
				result += "\n\n# SIP balancer virtual IP simplex #";
				result += "\n\n# Direct to primary node          #";
				result += getNameIpAddr("VSIP", "", vsipName, vsipIpAddr);
			case 'Pri': 
				result += "\n\n# SIP Load Balancer Primary node   #";
				result += getNameIpAddr("PRIMARY_SNF", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PRIMARY_SNF", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				result += getNameIpAddr("PRIMARY_SNF", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Sec': 
				result += "\n\n# SIP Load Balancer Secondary node   #";
				result += getNameIpAddr("SECONDARY_SNF", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("SECONDARY_SNF", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				result += getNameIpAddr("SECONDARY_SNF", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'VIP':
				// Definitions on the SIP network have precedence on the MGMT network
				var vsipName = nodeSipName;
				var vsipIpAddr = nodeSipIpAddr;
				if(vsipName == "" || vsipIpAddr == ""){
					vsipName = nodeName; vsipIpAddr = nodeIpAddr;
				}
				result += "\n\n# SIP balancer virtual IP      #";
				result += getNameIpAddr("VSIP", "", vsipName, vsipIpAddr);
				break;
			default:
				if(sipLbRole.indexOf(sipGrpPrefix) < 0) break;
				// Back end group membership
				var sipGrp=sipLbRole.substr(sipGrpPrefix.length);
				if(sipGroups == undefined)sipGroups= new Array();
				if(sipGroups[sipGrp] == undefined)sipGroups[sipGrp]= new Array();
				sipGroups[sipGrp].push(nodeSipIpAddr != "" ? nodeSipIpAddr : nodeIpAddr);
				break;
		}
		// Ensure that all nodes composing a Redis Sentinel cluster are connected to the same network interfaces: HA and APP
		function checkRedisNetworkConsistency(){
			var nbNodesOnMgmt = REDIS_HOST['MGMT'].length + REDIS_SENTINEL['MGMT'].length;
			var nbNodesOnHA = REDIS_HOST['HA'].length + REDIS_SENTINEL['HA'].length;
			var nbNodesOnApp = REDIS_HOST['APP'].length + REDIS_SENTINEL['APP'].length;
			if(nbNodesOnMgmt > 1){
				// at least one node defined on the management network: this node sets the policy for the whole cluster
				var redisHaInconsistency = checkGroupConsistency([nbNodesOnHA == 0, nodeHaName == "", nodeHaIpAddr == ""], "Nodes: " + nodeName, " Redis HA network definition must be consistent over the whole Redis Sentinel Cluster"); 
				var redisAppInconsistency = checkGroupConsistency([nbNodesOnApp == 0, nodeAppName == "", nodeAppIpAddr == ""], "Nodes: " + nodeName, " Redis APP network definition must be consistent over the whole Redis Sentinel Cluster");
				Nodes.check += redisHaInconsistency+redisAppInconsistency; 
				return redisHaInconsistency+redisAppInconsistency == "";
			}
			return true;
		}
		switch(redisHaRole){
			case 'Pri': 
				result += "\n\n# Redis HA primary node";
				result += getNameIpAddr("REDIS_PRIMARY", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("REDIS_PRIMARY", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Sec': 
				result += "\n\n# Redis HA secondary node";
				result += getNameIpAddr("REDIS_SECONDARY", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("REDIS_SECONDARY", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'ServerSentinel':
				REDIS_HOST['MGMT'].push(nodeName);
				REDIS_IP_ADDR['MGMT'].push(nodeIpAddr);
				isRedisSentinel[VNFCindex] = true;
				if(!checkRedisNetworkConsistency())break;
				if(nodeHaName != "")REDIS_HOST['HA'].push(nodeHaName);
				if(nodeHaIpAddr != "")REDIS_IP_ADDR['HA'].push(nodeHaIpAddr);
				if(nodeAppName != "")REDIS_HOST['APP'].push(nodeAppName);
				if(nodeAppIpAddr != "")REDIS_IP_ADDR['APP'].push(nodeAppIpAddr);
				break;
			case 'Sentinel':
				// all redis instances are to be concatenated in one vector
				REDIS_SENTINEL['MGMT'].push(nodeName);
				REDIS_SENTINEL_IP_ADDR['MGMT'].push(nodeIpAddr);
				isRedisSentinel[VNFCindex] = true;
				if(!checkRedisNetworkConsistency())break;
				if(nodeHaName != "")REDIS_SENTINEL['HA'].push(nodeHaName);
				if(nodeHaIpAddr != "")REDIS_SENTINEL_IP_ADDR['HA'].push(nodeHaIpAddr);
				if(nodeAppName != "")REDIS_SENTINEL['APP'].push(nodeAppName);
				if(nodeAppIpAddr != "")REDIS_SENTINEL_IP_ADDR['APP'].push(nodeAppIpAddr);
				break;
		}
		switch(pgsqlHaRole){
			case 'Pri': 
				result += "\n\n# PostgreSQL HA primary node";
				result += getNameIpAddr("PGSQL_PRIMARY", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PGSQL_PRIMARY", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Sec': 
				result += "\n\n# PostgreSQL HA secondary node";
				result += getNameIpAddr("PGSQL_SECONDARY", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PGSQL_SECONDARY", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Mstr':
				// A pgsql Master must be the first element of PGSQL_HOST/IP_ADDR 
				if(pgsqlNodeName[VNFCindex] == undefined)	pgsqlNodeName[VNFCindex]=new Array();
				if(pgsqlNodeIp[VNFCindex] == undefined)		pgsqlNodeIp[VNFCindex]=new Array();
				if(pgsqlNodeName[VNFCindex].master != undefined){
					Nodes.check += "\n"+nodeName + " has a PgSQL HA Master role duplicated with " + pgsqlNodeName[VNFCindex].master;
					break;
				} 
				else {
					pgsqlNodeName[VNFCindex].master = nodeName;
				}
				pgsqlNodeName[VNFCindex].unshift(nodeName);
				pgsqlNodeIp[VNFCindex].unshift(nodeIpAddr);
				break;
		}
		switch(dbRole){
			case 'mysql': 
				result += "\n\n# MySQL database";
				result += "\nMYSQL_HOST="+nodeName;
				result += "\nMYSQL_IP_ADDR="+nodeIpAddr;
				break;
			case 'pgsql':
				// As a pgsql Master, this node has already been pushed in first place, see upper.
				if(pgsqlHaRole == 'Mstr')break;
				if(pgsqlNodeName[VNFCindex] == undefined)	pgsqlNodeName[VNFCindex]=new Array();
				if(pgsqlNodeIp[VNFCindex] == undefined)		pgsqlNodeIp[VNFCindex]=new Array(); 
				pgsqlNodeName[VNFCindex].push(nodeName);
				pgsqlNodeIp[VNFCindex].push(nodeIpAddr);
				break;
			case 'oracle':
				result += "\n\n# Oracle database";
				result += "\nORACLE_HOST="+nodeName;
				result += "\nORACLE_IP_ADDR="+nodeIpAddr;
				result += "\n# Oracle database port";
				result += "\nORACLE_PORT="+nodePort;
				break;
			case 'redisVolatile':
			case 'redisSpare':
			case 'redisLazy':
			case 'redis':
				// all redis instances are to be concatenated in one vector
				// Known limitation on the instance Id, limited to 13 characters
				REDIS_INSTANCE_ID.push(nodeName.substr(0,12).split('.')[0]);
				REDIS_HOST['MGMT'].push(nodeName);
				REDIS_IP_ADDR['MGMT'].push(nodeIpAddr);
				REDIS_PERSISTENCE.push(dbRole == 'redis' || dbRole == 'redisSpare' ? 'enabled' : 'disabled');
				REDIS_SPARE.push(dbRole == 'redisSpare' || dbRole == 'redisLazy' ? 'true' : 'false');
				// The redis port can be a list of numbers, one for the resource, the second for the sentinel
				var redisPorts = nodePort.split(",");
				redisPorts.forEach(function(e,i,t){
					verfiedNumber = Number(e);
					if(Number.isNaN(verfiedNumber))Nodes.check += "\nNodes: "+nodeName + " has a non numerical Redis DB port number " + e;
					if(i > 1)Nodes.check += "\nNodes: "+nodeName + " useless Redis DB port number: " + e + "; max 2 ports expected: redis and sentinel";
				});
				if(redisPorts[0].trim() == "")redisPorts[0] = undefined;
				REDIS_PORT.push(redisPorts[0]);
				REDIS_SENTINEL_PORT.push(redisPorts[1]);
				if(!checkRedisNetworkConsistency())break;
				if(nodeHaName != "")REDIS_HOST['HA'].push(nodeHaName);
				if(nodeHaIpAddr != "")REDIS_IP_ADDR['HA'].push(nodeHaIpAddr);
				if(nodeAppName != "")REDIS_HOST['APP'].push(nodeAppName);
				if(nodeAppIpAddr != "")REDIS_IP_ADDR['APP'].push(nodeAppIpAddr);
				break;
			case 'mongo':
				result += "\n\n# Mongo database";
				result += "\nMONGODB_HOST="+nodeName;
				result += "\nMONGODB_IP_ADDR="+nodeIpAddr;
				result += "\nMONGODB_PORT="+nodePort;
				break;
			}
			switch(seeRole){
			case 'Spx':
				seeNetworks.forEach(function(n,i,t){
					if(nodeNames[n] != "")seeSimplexNames[n][VNFCindex] = nodeNames[n]; 
					if(nodeIpAddresses[n] != "")seeSimplexIpAddr[n][VNFCindex] = nodeIpAddresses[n];
				});
				
				// Record an emulated http LB on this VNF
				if(httpLb[VNFCindex] == undefined)httpLb[VNFCindex] = new Array();
				['MGMT', 'LBNAT'].forEach(function(n,i,t){
						if(nodeNames[n] != "")httpLbVipNames[n][VNFCindex] = nodeNames[n]; 
						if(nodeIpAddresses[n] != "")httpLbVipIpAddr[n][VNFCindex] = nodeIpAddresses[n];
						
					});
				break;
			case 'Pri':
				seeNetworks.forEach(function(n,i,t){
					if(nodeNames[n] != "")seePrimaryNames[n][VNFCindex] = nodeNames[n]; 
					if(nodeIpAddresses[n] != "")seePrimaryIpAddr[n][VNFCindex] = nodeIpAddresses[n];
				});
				break;
			case 'Sec':
				seeNetworks.forEach(function(n,i,t){
					if(nodeNames[n] != "")seeSecondaryNames[n][VNFCindex] = nodeNames[n]; 
					if(nodeIpAddresses[n] != "")seeSecondaryIpAddr[n][VNFCindex] = nodeIpAddresses[n];
				});
				break;
			default:
				if(seeRole == 'Wit' || seeRole == 'N+W'){
					seeNetworks.forEach(function(n,i,t){
						if(nodeNames[n] != "")seeWitnessNames[n][VNFCindex] = nodeNames[n]; 
						if(nodeIpAddresses[n] != "")seeWitnessIpAddr[n][VNFCindex] = nodeIpAddresses[n];
					});
				}
				if(seeRole == 'Nod' || seeRole == 'N+W'){
					seeNetworks.forEach(function(n,i,t){
						if(nodeNames[n] != ""){
							if(seeNodesNames[n][VNFCindex] == undefined)seeNodesNames[n][VNFCindex]=new Array();
							seeNodesNames[n][VNFCindex].push(nodeNames[n]); 
						}
						if(nodeIpAddresses[n] != ""){
							if(seeNodesIpAddr[n][VNFCindex] == undefined)seeNodesIpAddr[n][VNFCindex]=new Array();
							seeNodesIpAddr[n][VNFCindex].push(nodeIpAddresses[n]);
						}
					});
				}
				break;
		}
		switch(httpLbRole){
			case 'Pri': 
				httpLbNetworks.forEach(function(n,i,t){
					if(nodeNames[n] != "")httpLbPrimaryNames[n][VNFCindex] = nodeNames[n]; 
					if(nodeIpAddresses[n] != "")httpLbPrimaryIpAddr[n][VNFCindex] = nodeIpAddresses[n];
				});
				break;
			case 'Sec': 
				httpLbNetworks.forEach(function(n,i,t){
					if(nodeNames[n] != "")httpLbSecondaryNames[n][VNFCindex] = nodeNames[n]; 
					if(nodeIpAddresses[n] != "")httpLbSecondaryIpAddr[n][VNFCindex] = nodeIpAddresses[n];
				});
				break;
			case 'VIP':
				{
					// Definitions on the APP network have precedence on the MGMT network
					var vhttpName = nodeAppName;
					var vhttpIpAddr = nodeAppIpAddr;
					if(vhttpName == "" || vhttpIpAddr == ""){
						vhttpName = nodeName; vhttpIpAddr = nodeIpAddr;
					}
					// HTTP VIP between MGMT and LBNAT only
					nodeNames['MGMT']=vhttpName;
					nodeIpAddresses['MGMT']=vhttpIpAddr;
					['MGMT', 'LBNAT'].forEach(function(n,i,t){
						if(nodeNames[n] != "")httpLbVipNames[n][VNFCindex] = nodeNames[n]; 
						if(nodeIpAddresses[n] != "")httpLbVipIpAddr[n][VNFCindex] = nodeIpAddresses[n];
					});
					if(nodeNatIpAddr != undefined && nodeNatIpAddr != ""){
						result += "\n# HTTP virtual IP defined on the LBNAT interface: switch load balancer mode to nat";
						result += "\nLBMODE=nat";
					}
				}
				// Record a http LB on this VNF
				if(httpLb[VNFCindex] == undefined)httpLb[VNFCindex] = new Array();
				break;
		}

		switch(linuxHaRole){
			case 'Pri':
				result += "\n\n# Linux HA cluster primary node      #";
				result += getNameIpAddr("PRIMARY_LINUXHA", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PRIMARY_LINUXHA", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Sec':
				result += "\n\n# Linux HA cluster secondary node      #";
				result += getNameIpAddr("SECONDARY_LINUXHA", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("SECONDARY_LINUXHA", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
			case 'Qrm':
				result += "\n\n# Linux HA cluster quorum node      #";
				result += getNameIpAddr("QUORUM_LINUXHA", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("QUORUM_LINUXHA", "_HA_DEVICE", nodeHaName, nodeHaIpAddr);
				break;
		}
		switch(ocmpRole){
			case 'Spx': 
				result += "\n\n# Simplex OCMP, plays the SIP VIP role       #";
				result += getNameIpAddr("PRIMARY_OCMP", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PRIMARY_OCMP", "_APP_DEVICE", nodeAppName, nodeAppIpAddr);
				result += getNameIpAddr("PRIMARY_OCMP", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				if(nodePubIpAddr != "")result += "\nPRIMARY_OCMP_IP_NAT_ADDR="+nodePubIpAddr;
				result += "\nBRE_CLUSTER_NAME=${PRIMARY_OCMP_NAME}";
				if(!Nodes.search('OC SNF', 'VIP') && !Nodes.search('OC SNF', 'Spx')){
					result += "\n\n# No SIP balancer configured, OCMP simplex plays the SIP VIP role       #";
					result += getNameIpAddr("VSIP", "", nodeName, nodeIpAddr);
					vipSipRole.v = true;
				}
				break;
			case 'Pri': 
				ocmpVNFC.v = true;
				result += "\n\n# Primary OCMP       #";
				result += getNameIpAddr("PRIMARY_OCMP", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PRIMARY_OCMP", "_APP_DEVICE", nodeAppName, nodeAppIpAddr);
				result += getNameIpAddr("PRIMARY_OCMP", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				if(nodePubIpAddr != "")result += "\nPRIMARY_OCMP_IP_NAT_ADDR="+nodePubIpAddr;
				result += "\nBRE_CLUSTER_NAME=${PRIMARY_OCMP_NAME}";
				break;
			case 'Sec': 
				ocmpVNFC.v = true;
				result += "\n\n# Secondary OCMP       #";
				result += getNameIpAddr("SECONDARY_OCMP", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("SECONDARY_OCMP", "_APP_DEVICE", nodeAppName, nodeAppIpAddr);
				result += getNameIpAddr("SECONDARY_OCMP", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				if(nodePubIpAddr != "")result += "\nSECONDARY_OCMP_IP_NAT_ADDR="+nodePubIpAddr;
				break;
			case 'Nod':
				ocmpVNFC.v = true;
				ocmpNodesCount++;
				result += "\n\n# OCMP node "+ocmpNodesCount+"        #";
				result += getNameIpAddr("NODE_OCMP", ocmpNodesCount, nodeName, nodeIpAddr);
				result += getNameIpAddr("NODE_OCMP", ocmpNodesCount+"_APP_DEVICE", nodeAppName, nodeAppIpAddr);
				result += getNameIpAddr("NODE_OCMP", ocmpNodesCount+"_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
				if(nodePubIpAddr != "")result += "\nNODE_OCMP_IP_NAT_ADDR"+ocmpNodesCount+"="+nodePubIpAddr;
				break;
		}
		switch(uspmRole){
			case 'Pri':
				result += "\n\n# Primary USPM Middle ware       #";
				result += getNameIpAddr("PRIMARY_USPM", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("PRIMARY_USPM", "_DATA", nodeDataName, nodeDataIpAddr);
				result += getNameIpAddr("PRIMARY_USPM", "_M3UA1", nodeM3ua1Name, nodeM3ua1IpAddr);
				result += getNameIpAddr("PRIMARY_USPM", "_M3UA2", nodeM3ua2Name, nodeM3ua2IpAddr);
				result += "\nPRIMARY_USPM_NAME_VNFEXT=";
				result += "\nPRIMARY_USPM_IP_ADDR_VNFEXT=";
				break;
			case 'Sec': 
				result += "\n\n# Secondary USPM Middle ware       #";
				result += getNameIpAddr("SECONDARY_USPM", "", nodeName, nodeIpAddr);
				result += getNameIpAddr("SECONDARY_USPM", "_DATA", nodeDataName, nodeDataIpAddr);
				result += getNameIpAddr("SECONDARY_USPM", "_M3UA1", nodeM3ua1Name, nodeM3ua1IpAddr);
				result += getNameIpAddr("SECONDARY_USPM", "_M3UA2", nodeM3ua2Name, nodeM3ua2IpAddr);
				result += "\nSECONDARY_USPM_NAME_VNFEXT=";
				result += "\nSECONDARY_USPM_IP_ADDR_VNFEXT=";
				break;
			case 'BE':
				uspmBeNodesCount++;
				// Back End See nodes requires TCAP connectivity
				if(!seeConnectivities.contains('tcap'))seeConnectivities+="--tcap ";
				result += "\n\n# USPM Back end "+uspmBeNodesCount+"      #";
				result += getNameIpAddr("BACKEND_HOST"+uspmBeNodesCount, "", nodeName, nodeIpAddr);
				result += getNameIpAddr("BACKEND_HOST"+uspmBeNodesCount, "_DATA", nodeDataName, nodeDataIpAddr);
				break;
			case 'Simulap':
				// The simulap node is defined only on the management network in the MSE Descriptor
				// Addresses on other interfaces are guessed at run time from the network configuration
				// => pre requisite on the target node: data and m3ua1 networks are configured
				result += "\n\n# SIMULAP Tester";
				result += "\nSIMULAP_HOST="+nodeName;
				result += "\nSIMULAP_IP_ADDR="+nodeIpAddr;
				break;
		}
		if(isWrtcBE){
			result += "\n\n# WebRTC Back End node\n# Requires SEE running on this node";
			result += getNameIpAddr("WEBRTC_SIPGATEWAY", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("WEBRTC_SIPGATEWAY", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
			result += getNameIpAddr("WEBRTC_STORAGE", "", nodeName, nodeIpAddr);
		}
		if(isWrtcFE){
			result += "\n\n# WebRTC Front End node";
			result += "\n# WEBRTC_MEDIA: Media function, front end for WebRTC media#";
			result += getNameIpAddr("WEBRTC_SIGNALING", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("WEBRTC_SIGNALING", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
			result += getNameIpAddr("WEBRTC_MEDIA", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("WEBRTC_MEDIA", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
			if(nodePubIpAddr != "")result +="\nWEBRTC_MEDIA_IP_NAT_ADDR="+nodePubIpAddr;
		}
		if(isWrtcPxy){
			result += "\n\n# WebRTC SIP Proxy and Registrar node\n# Requires WebRTC Back end running on this node";
			result += getNameIpAddr("WEBRTC_SIPPROXY", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("WEBRTC_SIPPROXY", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
			result += getNameIpAddr("WEBRTC_SIPREGISTRAR", "", nodeName, nodeIpAddr);
			result += getNameIpAddr("WEBRTC_SIPREGISTRAR", "_SIP_DEVICE", nodeSipName, nodeSipIpAddr);
		}
		if(isWrtcTranscoder){
			result += "\n\n# OCMP used to transcode WebRTC media";
			result += getNameIpAddr("WEBRTC_OCMP_TRANSCODER", "", nodeName, nodeIpAddr);
		}
	}
	// End of for loop on the list of nodes
	
	// Build redis cluster
	if(REDIS_HOST['MGMT'].length != 0){
		result += "\n\n# Redis cluster";
		if(REDIS_INSTANCE_ID.length != 0)result += "\nREDIS_INSTANCE_ID=(" + REDIS_INSTANCE_ID.join(" ") + " )";
		result += "\nREDIS_HOST=(" + REDIS_HOST['MGMT'].join(" ") + " )";
		result += "\nREDIS_IP_ADDR=(" + REDIS_IP_ADDR['MGMT'].join(" ") + " )";
		if(REDIS_HOST['HA'].length != 0)result += "\nREDIS_HOST_HA_DEVICE=(" + REDIS_HOST['HA'].join(" ") + " )";
		if(REDIS_IP_ADDR['HA'].length != 0)result += "\nREDIS_IP_ADDR_HA_DEVICE=(" + REDIS_IP_ADDR['HA'].join(" ") + " )";
		if(REDIS_HOST['APP'].length != 0)result += "\nREDIS_HOST_APP_DEVICE=(" + REDIS_HOST['APP'].join(" ") + " )";
		if(REDIS_IP_ADDR['APP'].length != 0)result += "\nREDIS_IP_ADDR_APP_DEVICE=(" + REDIS_IP_ADDR['APP'].join(" ") + " )";
		if(REDIS_SENTINEL['MGMT'].length != 0)result += "\nREDIS_SENTINEL=(" + REDIS_SENTINEL['MGMT'].join(" ") + " )";
		if(REDIS_SENTINEL_IP_ADDR['MGMT'].length != 0)result += "\nREDIS_SENTINEL_IP_ADDR=(" + REDIS_SENTINEL_IP_ADDR['MGMT'].join(" ") + " )";
		if(REDIS_SENTINEL['HA'].length != 0)result += "\nREDIS_SENTINEL_HA_DEVICE=(" + REDIS_SENTINEL['HA'].join(" ") + " )";
		if(REDIS_SENTINEL_IP_ADDR['HA'].length != 0)result += "\nREDIS_SENTINEL_IP_ADDR_HA_DEVICE=(" + REDIS_SENTINEL_IP_ADDR['HA'].join(" ") + " )";
		if(REDIS_SENTINEL['APP'].length != 0)result += "\nREDIS_SENTINEL_APP_DEVICE=(" + REDIS_SENTINEL['APP'].join(" ") + " )";
		if(REDIS_SENTINEL_IP_ADDR['APP'].length != 0)result += "\nREDIS_SENTINEL_IP_ADDR_APP_DEVICE=(" + REDIS_SENTINEL_IP_ADDR['APP'].join(" ") + " )";
		fillArrays(REDIS_PORT);
		if(REDIS_PORT.length > 0)result += "\nREDIS_PORT=(" + REDIS_PORT.join(" ") + " )";
		fillArrays(REDIS_SENTINEL_PORT);
		if(REDIS_SENTINEL_PORT.length > 0)result += "\nREDIS_SENTINEL_PORT=(" + REDIS_SENTINEL_PORT.join(" ") + " )";
		if(REDIS_PERSISTENCE.length != 0)result += "\nREDIS_PERSISTENCE=(" + REDIS_PERSISTENCE.join(" ") + " )";
		if(REDIS_SPARE.length != 0)result += "\nREDIS_SPARE=(" + REDIS_SPARE.join(" ") + " )";
	}
	
	// Add SEE connectivities if any
	if(seeConnectivities != ""){
		result += "\n";
		result += "\n# ------------------------------- #";
		result += "\n# SEE connectivities options      #";
		result += "\n# ------------------------------- #";
		result += '\nAPP_SEECONNECTIVITIES_LIST="'+seeConnectivities+'"';
	}

	// USPM BE and Secondary requires a primary, and a primary requires at least a secondary
	Nodes.check += checkDependency(uspmBeNodesCount != 0 || Nodes.search('USPM role','Sec'), [Nodes.search('USPM role','Pri')], "Missing USPM primary role", " while secondary or backends are defined");
	Nodes.check += checkDependency(Nodes.search('USPM role','Pri'), [Nodes.search('USPM role','Sec')], "Missing USPM secondary role", " while primary is defined");

	// SEE clusters consistency
	VNFCnames.forEach(function(e,i,t){
		var VNFdisplayName = "the composed VNF";
		if(i != 0)VNFdisplayName = "the VNFC " + e;
		
		// Cannot mix SEE simplex and clusters on the same VNFC
		Nodes.check += checkUnicity([seeSimplexIpAddr['MGMT'][i] != undefined && seeSimplexIpAddr['MGMT'][i] != "", seePrimaryIpAddr['MGMT'][i] != undefined && seePrimaryIpAddr['MGMT'][i] != ""], "Nodes section: on "+VNFdisplayName+", SEE primary and simplex roles");
		
		// For each concerned network, if a primary is defined on this VNFC, make sure secondary and witness are defined as well, and the reverse
		seeNetworks.forEach(function(n,iNetwork,tNetwork){
		// Witness is required on MGMT and HA networks only, not APP, SIP...
		Nodes.check += checkDependency(seePrimaryIpAddr[n][i] != undefined && seePrimaryIpAddr[n][i] != "", [seeSecondaryIpAddr[n][i] != undefined && seeSecondaryIpAddr[n][i] != "" && (seeWitnessIpAddr[n][i] != undefined && seeWitnessIpAddr[n][i] != "" || n == 'APP' || n == 'SIP' || n == 'LBNAT')], "Nodes section: on interface "+n,", "+VNFdisplayName+" is missing SEE secondary or witness role");
		Nodes.check += checkDependency(seePrimaryIpAddr[n][i] == undefined || seePrimaryIpAddr[n][i] == "", [(seeSecondaryIpAddr[n][i] == undefined || seeSecondaryIpAddr[n][i] == "") && (seeWitnessIpAddr[n][i] == undefined || seeWitnessIpAddr[n][i] == "") && (seeNodesIpAddr[n][i] == undefined || seeNodesIpAddr[n][i].length == 0)], "Nodes section: on interface "+n,", "+VNFdisplayName+" is missing the SEE primary role");
		});
	});
	// The composed VNF must instantiate a SEE, either simplex or primary
	// But this is used as to instantiate only Redis instances... Commenting for now
	// Nodes.check += checkGroupConsistency([seeSimplexIpAddr['MGMT'][0] == undefined , seePrimaryIpAddr['MGMT'][0] != undefined ], "Nodes section:", " one SEE Cluster or Simplex is required on the composed VNF");
	
	// The current VNF implementation does not support a topology with a VNFC using an interface whereas the composed VNF does not use it
	seeNetworks.forEach(function(n,iNetwork,tNetwork){
		var VNFCusingInterface = false;
		var VNFusingInterface = false;
		VNFCnames.forEach(function(e,i,t){
			var usingInterface = true;
			if(seePrimaryIpAddr[n][i] == undefined || seePrimaryIpAddr[n][i] == "") usingInterface = false;
			if(i == 0)
				VNFusingInterface |= usingInterface;
			else
				VNFCusingInterface |= usingInterface;
		});
		Nodes.check += checkDependency(VNFCusingInterface, [VNFusingInterface], "Nodes section: Unsupported topology on interface "+n,"; the composed VNF should include an SEE Cluster using this interface since at least one VNFC uses it");
	});
	// Redis sentinel clusters cannot have 2 nodes, minimum 3
	Nodes.check += checkDependency(! Nodes.search('Redis HA', 'Pri'), [ (REDIS_SENTINEL['MGMT'].length+REDIS_HOST['MGMT'].length) != 2 ], "Nodes section: topology Redis Sentinel cluster with 2 nodes is not supported: ", "redis+sentinel should contain 3 or more nodes.");
	
	// Build the SEE clusters definition
	result += "\n";
	result += "\n# ------------------------------- #";
	result += "\n# SEE Clusters                    #";
	result += "\n# ------------------------------- #";
	// Fill missing arrays before the last defined for each interface
	seeNetworks.forEach(function(e,i,t){
	fillArrays(seeSimplexNames[e]);
	fillArrays(seeSimplexIpAddr[e]);
	fillArrays(seePrimaryNames[e]);
	fillArrays(seePrimaryIpAddr[e]);
	fillArrays(seeSecondaryNames[e]);
	fillArrays(seeSecondaryIpAddr[e]);
	fillArrays(seeWitnessNames[e]);
	fillArrays(seeWitnessIpAddr[e]);
	fillArrays(seeNodesNames[e]);
	fillArrays(seeNodesIpAddr[e]);
	});
	
	result += "\n# SEE Simplex      #";
	result += getNameIpAddr("SIMPLEX_SEE", "", seeSimplexNames['MGMT'], seeSimplexIpAddr['MGMT']);
	result += getNameIpAddr("SIMPLEX_SEE", "_APP_DEVICE", seeSimplexNames['APP'], seeSimplexIpAddr['APP']);
	result += getNameIpAddr("SIMPLEX_SEE", "_SIP_DEVICE", seeSimplexNames['SIP'], seeSimplexIpAddr['SIP']);
	result += "\n# SEE Primary      #";
	result += getNameIpAddr("PRIMARY_SEE", "", seePrimaryNames['MGMT'], seePrimaryIpAddr['MGMT']);
	result += getNameIpAddr("PRIMARY_SEE", "_APP_DEVICE", seePrimaryNames['APP'], seePrimaryIpAddr['APP']);
	result += getNameIpAddr("PRIMARY_SEE", "_SIP_DEVICE", seePrimaryNames['SIP'], seePrimaryIpAddr['SIP']);
	result += getNameIpAddr("PRIMARY_SEE", "_LBNAT_DEVICE", seePrimaryNames['LBNAT'], seePrimaryIpAddr['LBNAT']);
	result += getNameIpAddr("PRIMARY_SEE", "_HA_DEVICE", seePrimaryNames['HA'], seePrimaryIpAddr['HA']);
	result += "\n\n# SEE Secondary      #";
	result += getNameIpAddr("SECONDARY_SEE", "", seeSecondaryNames['MGMT'], seeSecondaryIpAddr['MGMT']);
	result += getNameIpAddr("SECONDARY_SEE", "_APP_DEVICE", seeSecondaryNames['APP'], seeSecondaryIpAddr['APP']);
	result += getNameIpAddr("SECONDARY_SEE", "_SIP_DEVICE", seeSecondaryNames['SIP'], seeSecondaryIpAddr['SIP']);
	result += getNameIpAddr("SECONDARY_SEE", "_LBNAT_DEVICE", seeSecondaryNames['LBNAT'], seeSecondaryIpAddr['LBNAT']);
	result += getNameIpAddr("SECONDARY_SEE", "_HA_DEVICE", seeSecondaryNames['HA'], seeSecondaryIpAddr['HA']);
	result += "\n\n# SEE Witness      #";
	result += getNameIpAddr("WITNESS_SEE", "", seeWitnessNames['MGMT'], seeWitnessIpAddr['MGMT']);
	result += getNameIpAddr("WITNESS_SEE", "_HA_DEVICE", seeWitnessNames['HA'], seeWitnessIpAddr['HA']);
	result += "\n\n# SEE additional nodes      #";
	result += getNameIpAddr("NODE_SEE", "", seeNodesNames['MGMT'], seeNodesIpAddr['MGMT']);
	result += getNameIpAddr("NODE_SEE", "_APP_DEVICE", seeNodesNames['APP'], seeNodesIpAddr['APP']);
	result += getNameIpAddr("NODE_SEE", "_SIP_DEVICE", seeNodesNames['SIP'], seeNodesIpAddr['SIP']);
	result += getNameIpAddr("NODE_SEE", "_LBNAT_DEVICE", seeNodesNames['LBNAT'], seeNodesIpAddr['LBNAT']);
	result += getNameIpAddr("NODE_SEE", "_HA_DEVICE", seeNodesNames['HA'], seeNodesIpAddr['HA']);


	// HTTP LB nodes
	// HTTP LB consistency
	VNFCnames.forEach(function(e,i,t){
		var VNFdisplayName = e == "" ? "the composed VNF" : "VNFC "+e;
		// For each concerned network, if a primary is defined on this VNFC, make sure secondary and VIP are defined as well, and the reverse
		httpLbNetworks.forEach(function(n,iNetwork,tNetwork){
			// Skip this check on SEE simplex VNFC, emulating the http load balancer
			if(seeSimplexIpAddr[n][i] != undefined)return;
			Nodes.check += checkDependency(httpLbPrimaryIpAddr[n][i] != undefined && httpLbPrimaryIpAddr[n][i] != "", [httpLbSecondaryIpAddr[n][i] != undefined && httpLbSecondaryIpAddr[n][i] != ""], "Nodes section: " + VNFdisplayName + " on interface "+n," is missing HTTP LB secondary role");
			Nodes.check += checkDependency(httpLbPrimaryIpAddr[n][i] == undefined || httpLbPrimaryIpAddr[n][i] == "", [(httpLbSecondaryIpAddr[n][i] == undefined || httpLbSecondaryIpAddr[n][i] == "") ], "Nodes section: " + VNFdisplayName + " on interface "+n," is missing the HTTP LB primary role");
		});
		// The VIP is defined between the MGMT and LBNAT interfaces only
		['MGMT', 'LBNAT'].forEach(function(n,iNetwork,tNetwork){
			// Skip this check on SEE simplex VNFC, emulating the http load balancer
			if(seeSimplexIpAddr[n][i] != undefined)return;
			Nodes.check += checkDependency(httpLbPrimaryIpAddr[n][i] != undefined && httpLbPrimaryIpAddr[n][i] != "", [httpLbVipIpAddr[n][i] != undefined && httpLbVipIpAddr[n][i] != ""], "Nodes section: " + VNFdisplayName + " on interface "+n," is missing HTTP LB Vip role");
			Nodes.check += checkDependency(httpLbPrimaryIpAddr[n][i] == undefined || httpLbPrimaryIpAddr[n][i] == "", [(httpLbVipIpAddr[n][i] == undefined || httpLbVipIpAddr[n][i] == "")], "Nodes section: " + VNFdisplayName + " on interface "+n," is missing the HTTP LB primary role");
		});
	});
	httpLbNetworks.forEach(function(e,i,t){
	fillArrays(httpLbPrimaryNames[e]);
	fillArrays(httpLbPrimaryIpAddr[e]);
	fillArrays(httpLbSecondaryNames[e]);
	fillArrays(httpLbSecondaryIpAddr[e]);
	fillArrays(httpLbVipNames[e]);
	fillArrays(httpLbVipIpAddr[e]);
	});
	result += "\n\n# HTTP Load Balancer Primary node   #";
	result += getNameIpAddr("PRIMARY_LB", "", httpLbPrimaryNames['MGMT'], httpLbPrimaryIpAddr['MGMT']);
	result += getNameIpAddr("PRIMARY_LB", "_APP_DEVICE", httpLbPrimaryNames['APP'], httpLbPrimaryIpAddr['APP']);
	result += getNameIpAddr("PRIMARY_LB", "_LBNAT_DEVICE", httpLbPrimaryNames['LBNAT'], httpLbPrimaryIpAddr['LBNAT']);
	result += "\n\n# HTTP Load Balancer Secondary node   #";
	result += getNameIpAddr("SECONDARY_LB", "", httpLbSecondaryNames['MGMT'], httpLbSecondaryIpAddr['MGMT']);
	result += getNameIpAddr("SECONDARY_LB", "_APP_DEVICE", httpLbSecondaryNames['APP'], httpLbSecondaryIpAddr['APP']);
	result += getNameIpAddr("SECONDARY_LB", "_LBNAT_DEVICE", httpLbSecondaryNames['LBNAT'], httpLbSecondaryIpAddr['LBNAT']);
	result += "\n\n# HTTP Load balancer virtual IP      #";
	result += getNameIpAddr("VHTTP", "", httpLbVipNames['MGMT'], httpLbVipIpAddr['MGMT']);
	result += getNameIpAddr("VHTTP", "_LBNAT_DEVICE", httpLbVipNames['LBNAT'], httpLbVipIpAddr['LBNAT']);
	result += "\nSEE_VIP_NAME=${VHTTP_NAME}";
	result += "\nRSLMF_VIP_NAME=${VHTTP_NAME}";
				
	// Build pgsql instances
	result += "\n\n# Pgsql database";
	result += "\n# -Standalone: one single entry pointing to the Pgsql node";
	result += "\n# -Linux HA: one single entry defining the VIP of the Pgsql resource";
	result += "\n# -Static cluster: list of SEE nodes co-locating Pgsql, the first being the initial master";
	// In case of static cluster (more than one element in the pgsql list), one set of pgsql nodes per VNFC
	pgsqlNodeName.forEach(function(e,i,t){
		if(e == undefined || e.length == 0)return;
		if(pgsqlNodeName[i].length > 1)result += ifVNFCopen(e,i);
		result += "\nPGSQL_HOST=( "+pgsqlNodeName[i].join(" ")+" )";
		result += "\nPGSQL_IP_ADDR=( "+pgsqlNodeIp[i].join(" ")+" )";
		if(pgsqlNodeName[i].length > 1)result += ifVNFCclose(e,i);
	});
	

	if(refreshGroups.length != 0){
		result += "\n\n#-------------------------------------------------#";
		result += "\n# Groups for service continuity upon upgrade";
		result += "\n# IP addresses preferred to address unresolved names";
		result += "\n#--------------------------------------------------#";
		result += "\nNIVR_REFRESH_SCHEDULE=("
		refreshGroups.forEach(function(e,i,t){
			if(e != undefined && e.length != 0){
				result += "\n\t"+e.join(",")+" \\";
			}
		});
		result += "\n)"
	}
	
	// Make the SIP groups available for SIP policy definition
	if(sipGroups != undefined)Nodes.sipGroups = sipGroups.slice();
	
	// Same for short names used for Heat template build
	Nodes.heatNodes = heatNodes.slice();
	
	// check the network width limitation compared to the number of non VIP heat nodes
	var nonVipHeatNodes = heatNodes.filter(function(e, i){return !e.isVIP;}).length;
	if(nonVipHeatNodes > Networks.heatMaxNodes)Nodes.check += "\nNodes vs Networks section: too many nodes for Heat deployments: found: "+nonVipHeatNodes+"; with a netmask "+Networks.heatMask+", the limit is : "+Networks.heatMaxNodes;
	
	// Same for SEE nodes not playing a USPM back end role, not supported by Messaging Gateway application
	Nodes.seeNodesNonUspmBackEnd = seeNodesNonUspmBackEnd.slice();
	
	// Same for the pgsql roles, used by native applications for EBRS TenantMP
	Nodes.pgsqlNodeIp = pgsqlNodeIp.slice();
	
	// Same for Redis sentinel mode, used by Redis Sentinel instances section
	Nodes.isRedisSentinel = isRedisSentinel.slice();
	
	// local check
	if(Nodes.check != "")result = Nodes.check;

	return result;
}

// Hides unused networks columns
Nodes.hideUnused = function(){
	['APP', 'SIP', 'LBNAT', 'PUBLIC', 'DATA', 'M3UA1', 'M3UA2', 'HA'].forEach(function(interface){
		// Check consistency first: reject hiding Networks interfaces with non empty columns in Nodes
		var fqdnColName=interface+' fqdn'; var ipAddrColName=interface+' IP addr';
		// Specific naming on LBNAT :-/
		if(interface == 'LBNAT'){fqdnColName='NAT fqdn'; ipAddrColName='NAT IP addr';}
		var nUsed=Nodes.count(fqdnColName)+Nodes.count(ipAddrColName) ; 
		var checkInterface = checkDependency(! Networks.search('network', interface), [nUsed== 0], 'Networks vs Nodes: ', 'Missing '+interface+' network interface definition : required '+nUsed+' times in the Nodes table.');
		if(checkInterface == ""){
			Nodes.display(fqdnColName, Networks.search('network', interface));
			Nodes.display(ipAddrColName, Networks.search('network', interface));
		}else Networks.check+=checkInterface;
	});
};

// Add one node by default
if(Nodes.isEmpty())Nodes.add();
Nodes.hideUnused();

// ===========================
// Security
// ===========================
var Security = new vnfResource("Security", [
	{name:'Property', width:'400px', type:'choice', choices:[ 
		'CERT_AUTH_ALIAS', 'CERT_AUTH_PASSWORD', 'NIVR_OCADMIN_PASSWORD', 'NIVRDB_LINUXHA_PASSWORD', 'NIVR_DISABLE_FIREWALL_TOOLS',
		'NIVRDB_ADMIN', 'NIVRDB_ADMIN_PASSWORD', 'NIVRDB_APP', 'NIVRDB_APP_PASSWORD', 'NIVRDB_OPER', 'NIVRDB_OPER_PASSWORD',
		'NIVRDB_SYSDBA', 'NIVRDB_SYSDBA_PASSWORD', 'NIVRDB_ORACLE_PASSWORD'
		]},
	{name:'Value', type:'text', width:'400px'}
	]
	);
	
// Comments for direct simple Security properties with no default value
var SecurityComment = new Array();
SecurityComment.CERT_AUTH_ALIAS="Certification authority for self signed certificates";
SecurityComment.CERT_AUTH_PASSWORD="Certification authority password";
SecurityComment.NIVR_OCADMIN_PASSWORD="ocadmin account password";
SecurityComment.NIVRDB_LINUXHA_PASSWORD="Password for Linux HA administrator account (hacluster) and Redis access control; enforced for all Redis resources, default value: hacluster";
SecurityComment.NIVR_DISABLE_FIREWALL_TOOLS="yes|no, default no: Optional property disabling firewall-tools on SEE nodes: requires that the firewall is configured externally or the service iptables is stopped.";
SecurityComment.NIVRDB_ADMIN="Oracle admin account name";
SecurityComment.NIVRDB_ADMIN_PASSWORD="Oracle admin account password";
SecurityComment.NIVRDB_APP="Oracle application account name";
SecurityComment.NIVRDB_APP_PASSWORD="Oracle application account password";
SecurityComment.NIVRDB_OPER="Oracle operator account name";
SecurityComment.NIVRDB_OPER_PASSWORD="Oracle operator account password";
SecurityComment.NIVRDB_SYSDBA="Oracle sys account name";
SecurityComment.NIVRDB_SYSDBA_PASSWORD="Oracle sys account password to instantiate a fresh database; database is left untouched if NIVRDB_SYSDBA_PASSWORD is undefined.";
SecurityComment.NIVRDB_ORACLE_PASSWORD="oracle account password";
// Default values for Security properties
var SecurityDefault = new Array();
SecurityDefault.CERT_AUTH_ALIAS='nfvCert';
SecurityDefault.CERT_AUTH_PASSWORD='nfvCert';
SecurityDefault.NIVR_OCADMIN_PASSWORD="ocadmin";
SecurityDefault.NIVRDB_LINUXHA_PASSWORD='hacluster';
SecurityDefault.NIVRDB_ADMIN="NIVRDB_ADMIN";
SecurityDefault.NIVRDB_ADMIN_PASSWORD="${NIVRDB_ADMIN}";
SecurityDefault.NIVRDB_APP="NIVRDB_APP";
SecurityDefault.NIVRDB_APP_PASSWORD="${NIVRDB_APP}";
SecurityDefault.NIVRDB_OPER="NIVRDB_OPER";
SecurityDefault.NIVRDB_OPER_PASSWORD="${NIVRDB_OPER}";
SecurityDefault.NIVRDB_SYSDBA="sys";
SecurityDefault.NIVRDB_ORACLE_PASSWORD='oracle';

Security.help = function(){
	return "Security settings" +
	"\n\nCertificate management"+
	"\nCERT_AUTH_ALIAS: " +SecurityComment.CERT_AUTH_ALIAS+
	"\nCERT_AUTH_PASSWORD: " + SecurityComment.CERT_AUTH_PASSWORD+
	"\n\nNIVR_OCADMIN_PASSWORD: " +SecurityComment.NIVR_OCADMIN_PASSWORD+
	"\n\nNIVRDB_LINUXHA_PASSWORD: " +SecurityComment.NIVRDB_LINUXHA_PASSWORD+
	"\n\nNIVR_DISABLE_FIREWALL_TOOLS: " +SecurityComment.NIVR_DISABLE_FIREWALL_TOOLS+
	"\n\nDatabase passwords for MSE applications" +
	"\nNIVRDB_ADMIN: " +SecurityComment.NIVRDB_ADMIN+
	"\nNIVRDB_ADMIN_PASSWORD: " +SecurityComment.NIVRDB_ADMIN_PASSWORD+
	"\nNIVRDB_APP: " +SecurityComment.NIVRDB_APP+
	"\nNIVRDB_APP_PASSWORD: " +SecurityComment.NIVRDB_APP_PASSWORD+
	"\nNIVRDB_OPER: " +SecurityComment.NIVRDB_OPER+
	"\nNIVRDB_OPER_PASSWORD: " +SecurityComment.NIVRDB_OPER_PASSWORD+
	"\nNIVRDB_ORACLE_PASSWORD: "+
	"\nNIVRDB_SYSDBA: " +SecurityComment.NIVRDB_SYSDBA+
	"\nNIVRDB_SYSDBA_PASSWORD: " +SecurityComment.NIVRDB_SYSDBA_PASSWORD;
}

Security.build = function(){
	var nameIndexes = Security.nameIndexes;
	var result = "\n";
	var table = document.getElementById("Security");
	var rowCount = table.rows.length;
	result += "\n# ------------------------------- #";
	result += "\n# Security                        #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var propertyName=Security.getAndSetSelection(row, nameIndexes, 'Property');
		switch(propertyName){
			case 'NIVRDB_SYSDBA':
				oracleRole.sysdba=Security.getAndSetValue(row, nameIndexes, 'Value', 'sys', 'NIVRDB_SYSDBA');
				result += "\n# Oracle sys account name";
				result += "\nNIVRDB_SYSDBA="+oracleRole.sysdba;
				break;
			case 'NIVRDB_ORACLE_PASSWORD':
				result += "\n# Oracle user password";
				result += "\nNIVRDB_ORACLE_PASSWORD="+Security.getAndSetValue(row, nameIndexes, 'Value', 'oracle', 'NIVRDB_ORACLE_PASSWORD');
				break;
			default:
				result += "\n# "+SecurityComment[propertyName];
				result += "\n"+propertyName+'="'+Security.getAndSetValue(row, nameIndexes, 'Value', SecurityDefault[propertyName], SecurityComment[propertyName])+'"';
				break;
		}
	}
	return result;
};
// Add two lines by default, typically for the CERT entries 
if(Security.isEmpty()){
	Security.add();Security.add();
}

// ===========================
// Miscellaneous settings
// (required before all sections using the SEE_INSTANCES_MAX property)
// ===========================
var Misc = new vnfResource("Misc", [
	{name:'Property', width:'400px', type:'choice', choices:[ 
		'DEFAULT_GATEWAY_IP_ADDR', 'SIP_DEFAULT_GATEWAY_IP_ADDR', 
		'SNMP_TRAP_DESTINATION', 'SNMP_TRAP_COMMUNITY', 'SEE_INSTANCES_MAX', 
		'VNF_CONFIG_DATA_FILE', 'NIVR_OTHER_HOSTS', 'REDIS_SENTINEL_PORT_OFFSET', 'REDIS_DOWNAFTER', 'REDIS_PARALLEL_SYNCS', 'REDIS_FAILOVER_TIMEOUT',
		'ORACLE_SERVICE', 'ORACLE_CONSOLE_PORT', 'ORACLE_PATH',
		'YUM_REPO_LIST', 'HA_PING_IP_ADDR', 'COROSYNC_UNICAST',
		'NFVD_ADDR', 'NFVD_TENANT_NAME', 'NFVD_APPLICATION', 'NFVD_DATACENTER',
		'NFVD_USERNAME', 'NFVD_PASSWORD', 'NFVD_STACK_NAME', 'NFVD_REST_ADDR', 'NFVD_SCALING_TEMPLATE',
		'NIVR_SCALING_ROLE','VNF_RETRY_POLICY_MAX_TIMEOUT'
		]},
	{name:'Value', type:'text', width:'400px'}
	]
	);
	
// Default values for misc properties
var MiscDefault = new Array();
MiscDefault.SNMP_TRAP_DESTINATION='${NIVR_EMS_IP_ADDR}';
MiscDefault.SNMP_TRAP_COMMUNITY='authCommunity.*public';
MiscDefault.ORACLE_SERVICE="OPCO0";
MiscDefault.ORACLE_PATH="/u01/app/oracle/oradata/${ORACLE_SERVICE}";
MiscDefault.ORACLE_CONSOLE_PORT="5500";
MiscDefault.VNF_CONFIG_DATA_FILE="/etc/opt/OC/hpoc-nivr-nfv/uspm-nfv-app.properties";
MiscDefault.COROSYNC_UNICAST="no";
MiscDefault.YUM_REPO_LIST="yum_repos";
MiscDefault.NFVD_REST_ADDR="${NFVD_ADDR}:5000/v2.0";
MiscDefault.REDIS_SENTINEL_PORT_OFFSET="20000";
MiscDefault.REDIS_PARALLEL_SYNCS="1";
MiscDefault.REDIS_FAILOVER_TIMEOUT="60000";
MiscDefault.REDIS_DOWNAFTER="5000";
// Comments for direct simple misc properties with no default value
var MiscComment = new Array();
MiscComment.SNMP_TRAP_DESTINATION="node collecting SNMP traps emitted by all the VNF members, typically the VNF EMS";
MiscComment.SNMP_TRAP_COMMUNITY="The SNMP Community name used for SNMP authentication";
MiscComment.DEFAULT_GATEWAY_IP_ADDR="Default gateway IP address; set a question mark for OpenStack deployments";
MiscComment.SEE_INSTANCES_MAX="Maximum number of instances deployed on an SEE";
MiscComment.SIP_DEFAULT_GATEWAY_IP_ADDR="Default gateway IP address used on nodes connected to a public SIP/RTP network; set a question mark for OpenStack deployments";
MiscComment.ORACLE_SERVICE="Oracle instance name(TNS_NAME)";
MiscComment.ORACLE_PATH="Absolute path to the Oracle instance on the Oracle server; default: "+MiscDefault.ORACLE_PATH;
MiscComment.ORACLE_CONSOLE_PORT="Port assigned to the Oracle console";
MiscComment.YUM_REPO_LIST="list of YUM repositories used as an alternative to ISO images for products installation";
MiscComment.NFVD_ADDR="SNMP Traps destination outside the VNF";
MiscComment.NFVD_TENANT_NAME="SNMP Traps attribute tenantId";
MiscComment.NFVD_APPLICATION="SNMP Traps attribute applicationId";
MiscComment.NFVD_DATACENTER="SNMP Traps attribute datacenterId";
MiscComment.NFVD_USERNAME="Scaling: account used to send REST requests to the orchestrator NFVD_ADDR";
MiscComment.NFVD_PASSWORD="Scaling: password used to send REST requests to the orchestrator NFVD_ADDR";
MiscComment.NFVD_STACK_NAME="Scaling: the existing stack to join by the new node";
MiscComment.NFVD_REST_ADDR="Scaling: the address listening to scaling REST requests";
MiscComment.NFVD_SCALING_TEMPLATE="Scaling: the stack template used to instantiate a scaling node";
MiscComment.VNF_CONFIG_DATA_FILE="USPM auxiliary descriptor: absolute path to the file on the target";
MiscComment.NIVR_OTHER_HOSTS="list of space separated pairs of IP address/fqdn to be added in /etc/hosts; Example: 192.168.11.56/repoOS.domain 93.184.220.20/lemonde.fr 16.17.94.84/cmsgvm04.gre.hpecorp.net"
MiscComment.REDIS_SENTINEL_PORT_OFFSET="The Sentinel associated port number offset compared to its related redis port number (default 20000)";
MiscComment.REDIS_DOWNAFTER="Number of milliseconds the master (or any attached slave or sentinel) should be unreachable in order to consider it in S_DOWN state (default 5000).";
MiscComment.REDIS_PARALLEL_SYNCS="How many slaves we can reconfigure to point to the new slave simultaneously during the failover (default 1)";
MiscComment.REDIS_FAILOVER_TIMEOUT="Specifies the failover timeout in milliseconds. It is used in many ways, for instance: the maximum time a failover in progress waits for all the slaves to be reconfigured as slaves of the new master (default 60000).";
MiscComment.COROSYNC_UNICAST="Use unicast for corosync management: yes/no, default is no, yes recommended on Helion";
MiscComment.VNF_RETRY_POLICY_MAX_TIMEOUT="Max timeout applied to all actions in the VNF; default 900s";

Misc.help = function(){
	return "Miscellaneous settings" +
	"\nSNMP:"+
	"\n\tSNMP_TRAP_DESTINATION: " +MiscComment.SNMP_TRAP_DESTINATION+
	"\n\tSNMP_TRAP_COMMUNITY: " +MiscComment.SNMP_TRAP_COMMUNITY+
	"\nSEE_INSTANCES_MAX: " +MiscComment.SEE_INSTANCES_MAX+
	"\n\nNIVR_OTHER_HOSTS: " +MiscComment.NIVR_OTHER_HOSTS+
	"\n\nREDIS_SENTINEL_PORT_OFFSET: " +MiscComment.REDIS_SENTINEL_PORT_OFFSET+
	"\nREDIS_DOWNAFTER: " +MiscComment.REDIS_DOWNAFTER+
	"\nREDIS_PARALLEL_SYNCS: " +MiscComment.REDIS_PARALLEL_SYNCS+
	"\nREDIS_FAILOVER_TIMEOUT: " +MiscComment.REDIS_FAILOVER_TIMEOUT+
	"\n\nVNF_CONFIG_DATA_FILE: " +MiscComment.VNF_CONFIG_DATA_FILE+
	"\n\tFor OpenStack deployments, click the button 'Import USPM descriptor' to push a local descriptor to the target."+
	"\n\tIn this descriptor, IP addresses are available as place holders on all nodes and interfaces conforming to the naming scheme ~<name>_<network>~"+
	"\n\tWhere name is the short node name and network identifies the network interface as one of mgmt app sip nat ha data m3ua1 m3ua2 pub"+
	"\n\tExamples: ~see1_mgmt~ ~uspm1_data~ ~simulap_m3ua1~"+
	"\n\nDefault gateways:" +
	"\n\tNOTE: declaration is mandatory on OpenStack deployments using multiple network interfaces to enable remote access; use a quetion mark ? to let the infrastructure set the appropriate address." +
	"\n\tDEFAULT_GATEWAY_IP_ADDR: Default gateway IP address: useful for topologies using multiple interfaces to set the gateway on the interface offering a public access" +
	"\n\tSIP_DEFAULT_GATEWAY_IP_ADDR: Default gateway IP address used on nodes connected to a public SIP/RTP network: useful to enable SIP calls from an external public network" +
	"\n\nDatabase for MSE applications" +
	"\nORACLE_SERVICE: " +MiscComment.ORACLE_SERVICE+
	"\nORACLE_PATH: " +MiscComment.ORACLE_PATH+
	"\nORACLE_CONSOLE_PORT: " +MiscComment.ORACLE_CONSOLE_PORT+
	"\n\nHA_PING_IP_ADDR: Reference IP address for LB HA" +
	"\nCOROSYNC_UNICAST: " +MiscComment.COROSYNC_UNICAST+
	"\nNFVD_ADDR, NFVD_TENANT_NAME, NFVD_APPLICATION, NFVD_DATACENTER:"+
	"\n\tif SNMP_TRAP_DESTINATION is the EMS, SNMP traps are bounced to NFV_ADDR address,"+
	"\n\tadding the NFVD_TENANT_NAME, NFVD_APPLICATION, NFVD_DATACENTER and NFVD_DATACENTER fields" + 
	"\n\nNFVD_USERNAME NFVD_PASSWORD NFVD_STACK_NAME NFVD_REST_ADDR NFVD_SCALING_TEMPLATE"+
	"\n\tif NFVD_ADDR, NFVD_USERNAME and NFVD_PASSWORD are defined:"+
	"\n\ta stop or start REST request is sent to the orchestrator at NFVD_ADDR to instantiate a new stack using"+
	"\n\tNFVD_SCALING_TEMPLATE template, with the credentials, targeting the tenant NFVD_TENANT_NAME, and joining"+
	"\n\tthe existing stack NFVD_STACK_NAME"+
	"\n\nNIVR_SCALING_ROLE: Scaling role: Override OCMP default scaling role : NODE_SEE"+
	"\nYUM_REPO_LIST: "+MiscComment.YUM_REPO_LIST+
	"\nVNF_RETRY_POLICY_MAX_TIMEOUT: "+MiscComment.VNF_RETRY_POLICY_MAX_TIMEOUT;
}

Misc.build = function(target){
	var nameIndexes = Misc.nameIndexes;
	var result = "\n";
	Misc.check="";
	Misc.heatUspmAuxDescPath="";
	var table = document.getElementById("Misc");
	var rowCount = table.rows.length;
	// Reset seeInstancesMax to the default value
	seeInstancesMax = 4; 
	// Reset oracle parameters
	oracleRole.service = oracleRole.path = undefined; 
	
	// Require DEFAULT_GATEWAY_IP_ADDR for Heat deployments on more than one network interface
	Misc.check+=checkDependency(target == 'Heat' && Networks.heatMaxNetwork > 0, [Misc.search('Property', 'DEFAULT_GATEWAY_IP_ADDR')], 'Misc section: ', 'Floating IPs on Heat deployments with '+ (Networks.heatMaxNetwork+1) +' network interfaces requires setting DEFAULT_GATEWAY_IP_ADDR; use a question mark (?) for an automatic setting on the external network.');
	result += "\n# ------------------------------- #";
	result += "\n# Miscellaneous properties        #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var propertyName=Misc.getAndSetSelection(row, nameIndexes, 'Property');
		switch(propertyName){
			case 'ORACLE_SERVICE':
				// Output in result deferred until both ORACLE_SERVICE and ORACLE_PATH are defined since the latter may depend on the first
				oracleRole.service=Misc.getAndSetValue(row, nameIndexes, 'Value', MiscDefault[propertyName], MiscComment[propertyName]);
				break;
			case 'ORACLE_PATH':
				oracleRole.path=Misc.getAndSetValue(row, nameIndexes, 'Value', MiscDefault[propertyName], MiscComment[propertyName]);
				break;
			case 'NIVR_SCALING_ROLE':
				result += "\n# Scaling role to override default OCMP scaling role";
				result += "\nNIVR_SCALING_ROLE="+Misc.getAndSetValue(row, nameIndexes, 'Value', 'NODE_SEE', 'NIVR_SCALING_ROLE');
				break;
			case 'HA_PING_IP_ADDR':
				result += "\n# Reference IP address for LB HA: default gateway";
				result += "\nHA_PING_IP_ADDR="+Misc.getAndSetValue(row, nameIndexes, 'Value', "$(/sbin/ip route | grep $MGMT_DEVICE | awk '/default/ { print $3 }' | tail -1)", 'HA_PING_IP_ADDR');
				break;
			case 'YUM_REPO_LIST':
				result += "\n# YUM repositories list";
				result += "\nYUM_REPO_LIST="+Misc.getAndSetValue(row, nameIndexes, 'Value', "'*'", 'YUM_REPO_LIST');
				result += '\n[ "$YUM_REPO_LIST" != "" ] && IS_YUM_REPO=yes || IS_YUM_REPO=no'
				break;
			case 'SEE_INSTANCES_MAX':
				var candidate=Misc.getAndSetValue(row, nameIndexes, 'Value', "4", MiscComment.SEE_INSTANCES_MAX);
				seeInstancesMax = Number(candidate);
				if(Number.isNaN(seeInstancesMax)){
					Misc.check += "Illegal value for SEE_INSTANCES_MAX: "+candidate+"; expecting integer";
					break;
				} 
				if(seeInstancesMax < 1 || seeInstancesMax > 8){
					Misc.check += "Illegal value for SEE_INSTANCES_MAX: "+candidate+"; expecting integer in the range 1 to 8";
					break;
				}
				result += "\n# "+MiscComment[propertyName];
				result += "\n"+propertyName+"="+seeInstancesMax;
				break;
			case 'DEFAULT_GATEWAY_IP_ADDR':
				var defaultValue='';
				if(target == 'Heat' && Networks.heatMaxNetwork > 0)defaultValue='?';
				var defaultGatewayIpAddr=Misc.getAndSetValue(row, nameIndexes, 'Value', defaultValue, MiscComment.DEFAULT_GATEWAY_IP_ADDR);
				// Heat deployment: prepare a place holder for replacement at deployment time
				if(defaultGatewayIpAddr == '?')defaultGatewayIpAddr='~pub_gateway~';
				result += "\n"+propertyName+"="+defaultGatewayIpAddr;
				break;
			case 'VNF_CONFIG_DATA_FILE':
				// Store the path to USPM descriptor for Heat template elaboration
				Misc.heatUspmAuxDescPath=Misc.getAndSetValue(row, nameIndexes, 'Value', MiscDefault[propertyName], MiscComment[propertyName]);
				result += "\n# "+MiscComment[propertyName];
				result += "\n"+propertyName+"="+Misc.heatUspmAuxDescPath;
				break;
			default:
				if(propertyName != ""){
				result += "\n# "+MiscComment[propertyName];
				result += "\n"+propertyName+'="'+Misc.getAndSetValue(row, nameIndexes, 'Value', MiscDefault[propertyName], MiscComment[propertyName])+'"';
				}
				break;
		}
	}
	
	// Ensure dependency between oracle parameters
	Misc.check += checkGroupConsistency([oracleRole.service != undefined, oracleRole.path != undefined], 'Misc section: ORACLE_SERVICE and ORACLE_PATH consistency:',' both or none should be defined.');
	if(oracleRole.service != undefined){
		result += "\n# Oracle instance name (TNS_NAME) and path";
		result += "\nORACLE_SERVICE="+oracleRole.service;
		result += "\nNIVRDB_ORACLE_PATH="+oracleRole.path;
	}

	if(Misc.check != "")return Misc.check;
	return result;
};

// Add 2 lines by default, typically for the default gateways
if(Misc.isEmpty()){
	Misc.add();Misc.add();
}

// ========================
// Redis Sentinel instances
// ========================
var RedisInstance = new vnfResource("RedisInstance", [
	{name:'VNFC', type:'text', width:'55px'}, 
	{name:'Name', type:'text', width: '80px'}, 
	{name:'Mode', type:'choice', width: '80px', choices:['redis', 'redisVolatile', 'redisSpare', 'redisLazy']}, 
	{name:'Instance Port', type:'text', width: '50px'}, 
	{name:'Sentinel Port', type:'text', width: '50px'}
	]);
RedisInstance.help = function(){return "Redis Sentinel instances:"+
	"\nList of Redis resources instantiated on the Redis Sentinel cluster defined in the Nodes section by Redis HA roles ServerSentinel and Sentinel"+
	"\nFour modes available:"+ 
	"\n- redis: persistency and active/active (both nodes are active and write to disk)"+
	"\n- redisVolatile: no persistency and active/active (both nodes are active but do not write to disk)"+
	"\n- redisSpare: persistency and active/spare (one node active at once and write to disk)"+
	"\n- redisLazy: no persistency and active/spare (one node active at once and no write to disk)"+
	"\nInstance Port: port used on the servers for this instance. Default: 6379"+
	"\nSentinel Port: port used on the servers/sentinels for this instance. Default value is the redis port number plus an offset defined as REDIS_SENTINEL_PORT_OFFSET in the Misc section (default 20000)"
}
RedisInstance.build = function(target){
	var nameIndexes = RedisInstance.nameIndexes;
	var result = '\n';
	RedisInstance.check = "";
	var table = document.getElementById('RedisInstance');
	var rowCount = table.rows.length;
	
	// How many VNFCs to manage?
	var nbVNFC = VNFCnames.length;
	
	var names = new Array(nbVNFC);
	var persistences = new Array(nbVNFC);
	var spares = new Array(nbVNFC);
	var instancePorts = new Array(nbVNFC);
	var sentinelPorts = new Array(nbVNFC);
		
	result += '\n# ------------------------ #';
	result += '\n# Redis Sentinel Instances #';
	result += '\n# ------------------------ #';
	for(var i=1; i < rowCount; i++){
		var VNFCName = RedisInstance.getAndSetValue(table.rows[i], nameIndexes, 'VNFC');
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex < 0){ RedisInstance.check += "\nRedisInstance section: "+VNFdisplayName+" is undefined in the nodes table"; continue; }
		
		if(Nodes.isRedisSentinel == undefined || Nodes.isRedisSentinel[VNFCindex] == undefined || ! Nodes.isRedisSentinel[VNFCindex] ){ 
			RedisInstance.check += "\nRedisInstance section: "+VNFdisplayName+" has no Redis Sentinel cluster defined in the nodes section"; 
			continue;
		}
		
		var name=RedisInstance.getAndSetValue(table.rows[i], nameIndexes, 'Name');
		var mode=RedisInstance.getAndSetSelection(table.rows[i], nameIndexes, 'Mode');
		var persistence = (mode == 'redis' || mode == 'redisSpare' ? 'enabled' : 'disabled');
		var spare = (mode == 'redisSpare' || mode == 'redisLazy' ? 'true' : 'false');
		var instancePort=RedisInstance.getAndSetValue(table.rows[i], nameIndexes, 'Instance Port');
		var sentinelPort=RedisInstance.getAndSetValue(table.rows[i], nameIndexes, 'Sentinel Port');
		
		if(name == ""){RedisInstance.check += 'RedisInstance section: instance name cannot be blank'; continue; }
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) >=0){RedisInstance.check += 'RedisInstance: instance name '+name+' in '+VNFdisplayName+' is duplicated'; continue; }
		var nameIndex=names[VNFCindex].length;
		names[VNFCindex].push(name);
		if(persistences[VNFCindex] == undefined)persistences[VNFCindex] = new Array(); 
		persistences[VNFCindex].push(persistence);
		if(spares[VNFCindex] == undefined)spares[VNFCindex] = new Array(); 
		spares[VNFCindex].push(spare);
		if(instancePort != ""){
			if(instancePorts[VNFCindex] == undefined)instancePorts[VNFCindex] = new Array();
			instancePorts[VNFCindex][nameIndex]=instancePort;
		}
		if(sentinelPort){
			if(sentinelPorts[VNFCindex] == undefined)sentinelPorts[VNFCindex] = new Array();
			sentinelPorts[VNFCindex][nameIndex]=sentinelPort;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(persistences[i]);
		fillArrays(spares[i]);
		fillArrays(instancePorts[i]);
		fillArrays(sentinelPorts[i]);
		result += ifVNFCopen(e,i);
		result += "\nREDIS_INSTANCE_ID=( "+names[i].join(" ")+" )";
		result += "\nREDIS_PERSISTENCE=( "+persistences[i].join(" ")+" )";
		result += "\nREDIS_SPARE=( "+spares[i].join(" ")+" )";
		if(instancePorts[i] != undefined)result += "\nREDIS_PORT=( "+instancePorts[i].join(" ")+" )";
		if(sentinelPorts[i] != undefined)result += "\nREDIS_SENTINEL_PORT=( "+sentinelPorts[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	// local check
	if(RedisInstance.check != "")result = RedisInstance.check;
	return result;
}

// ===========================
// OCSNF Policy
// ===========================
var OCSNFpolicy = new vnfResource("OCSNFpolicy", [
	{name:'Range', type:'choice', choices:[ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], width:'50px'},
	{name:'Algorithm', type:'choice', choices:[ 'round-robin', 'use first'], width:'120px'},
	{name:'Port', type:'text', width:'80px'},
	{name:'Service', type:'text', width:'80px'},
	{name:'1st', type:'choice', choices:[sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'2nd', type:'choice', choices:['', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'3rd', type:'choice', choices:['', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'4th', type:'choice', choices:['', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'5th', type:'choice', choices:['', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'6th', type:'choice', choices:['', sipGrpPrefix+'0', sipGrpPrefix+'1', sipGrpPrefix+'2', sipGrpPrefix+'3', sipGrpPrefix+'4', sipGrpPrefix+'5', sipGrpPrefix+'6', sipGrpPrefix+'7', sipGrpPrefix+'8', sipGrpPrefix+'9'], width:'50px'},
	{name:'Pattern A', type:'text', width:'300px'},
	{name:'Operator', type:'choice', choices:[ '', 'AND', 'OR'], width:'50px'},
	{name:'Pattern B', type:'text', width:'300px'}
	]
	);

OCSNFpolicy.help = function(){
	return "OCSNF SIP balancer dispatch policy: " +
	"\nRange: order of this entry in the list of policies for matching a SIP invite; must be unique" +
	"\nAlgorithm: used to select the destination address in the groups of back-ends"+
	"\n\tround-robin: use next to balance load"+
	"\n\tuse first: use first available in the list: good for fail over"+
	"\nPort: SIP port listening on this policy; default 5060"+
	"\nService: SIP service probed on the targets by the balancer for this policy; optional; 'probe' recommended on MRF adapters"+
	"\n1st to 6th back end groups: list of back end groups targets of this policy, defined in the nodes table."+
	"\nPattern A / B: any valid expression used to filter SIP requests, for example sip:play.* ; sip:ivr.*, .*, m=audio"+
	"\nOperator: logic applied between the two patterns to refine the match"+
	"\n\nExample: HA conference call balancing between SEE and OCMP primaries and secondaries based on the conference Id ; dispatch all other calls to any OCMP"+
	"\n5 groups in the nodes table"+
	"\n\tGrp0: SEE primary"+
	"\n\tGrp1: SEE secondary"+
	"\n\tGrp2: OCMP primary"+
	"\n\tGrp3: SEE secondary"+
	"\n\tGrp4: other OCMP nodes"+
	"\n5 rules in the OCSNF policy table"+
	"\n\tRange 0\tuse first\tport 5061\tGrp0 Grp1\tsip:.*[0-4]@.*:5061"+
	"\n\tRange 1\tuse first\tport 5061\tGrp1 Grp0\tsip:.*[5-9]@.*:5061"+
	"\n\tRange 2\tuse first\tport 5060\tGrp2 Grp3\tsip:conf=.*[0-4]@.*"+
	"\n\tRange 3\tuse first\tport 5060\tGrp3 Grp2\tsip:conf=.*[5-9]@.*"+
	"\n\tRange 4\tround-robin\tport 5060\tGrp2 Grp3 Grp4\t.*"+
	"\nThe default OCSNF policy dispatches any SIP INVITE to any OCMP and SEE node";
};

OCSNFpolicy.build = function(){
	var nameIndexes = OCSNFpolicy.nameIndexes;
	var result = "\n";
	
	var groups = new Array();
	var ports = new Array();
	var services = new Array();
	var patternAs = new Array();
	var patternBs  = new Array();
	var algorithms = new Array();
	var operators = new Array();
	
	OCSNFpolicy.check = "";
	var table = document.getElementById('OCSNFpolicy');
	var rowCount = table.rows.length;
	result += '\n# ------------------------------- #';
	result += '\n#    OCSNF policy                 #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var range=OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, 'Range');
		
		if(groups[range] != undefined)OCSNFpolicy.check += "OCSNF policy: range "+range+" duplicated";
		
		// Build the group by concatenating all definitions for this range got from the Nodes table
		var nodesGroups = new Array();
		// Record the group number in the Nodes table for each group definition, or -1 if undefined (substr returns -1 when not found)
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '1st').substr(sipGrpPrefix.length));
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '2nd').substr(sipGrpPrefix.length));
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '3rd').substr(sipGrpPrefix.length));
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '4th').substr(sipGrpPrefix.length));
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '5th').substr(sipGrpPrefix.length));
		nodesGroups.push(OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, '6th').substr(sipGrpPrefix.length));
		
		// Not all should be undefined 
		if(nodesGroups.every(function(e,i,t){return e == -1;}))OCSNFpolicy.check += 'OCSNF policy: range '+ range+' has no target group defined';
		// Concatenates the nodes defined in the Nodes table from all groups in one table
		var nodesList = new Array();
		nodesGroups.forEach(function(e,i,t){
			var eInt = parseInt(e);
			if(eInt != -1 && Nodes.sipGroups != undefined && Nodes.sipGroups[eInt] != undefined){
				nodesList = nodesList.concat(Nodes.sipGroups[eInt]);
			}
		});
		// The resulting table should not be empty
		if(nodesList.length == 0)OCSNFpolicy.check += '\nNodes vs OCSNF policy at range '+range+' : all groups are empty';

		// Record this list of nodes as a comma separated string, and all other attributes from the user definition
		// The algorithm is coded as an integer by OCSNF
		var algorithmCode = new Array()
		algorithmCode['round-robin'] = 4; 
		algorithmCode['use first'] = 8; 
				
		groups[range] = nodesList.join(",");
		algorithms[range] = algorithmCode[OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, 'Algorithm')];
		var port = 		OCSNFpolicy.getAndSetValue(table.rows[i], nameIndexes, 'Port');
		var service = 	OCSNFpolicy.getAndSetValue(table.rows[i], nameIndexes, 'Service');
		var patternA = 	OCSNFpolicy.getAndSetValue(table.rows[i], nameIndexes, 'Pattern A');
		var operator = 	OCSNFpolicy.getAndSetSelection(table.rows[i], nameIndexes, 'Operator');
		var patternB = 	OCSNFpolicy.getAndSetValue(table.rows[i], nameIndexes, 'Pattern B');
		if(port != '')		ports[range] = port;
		if(service != '')	services[range] = service;
		if(operator  != '')	operators[range]=operator;
		// Add quotes since a pattern may contain shell hostile characters like (|&*
		if(patternA != '')	patternAs[range]="'"+patternA+"'";
		if(patternB != '')	patternBs[range]="'"+patternB+"'";
	}

	fillArrays(groups);		if(groups.length > 0)		result += "\nOCSNF_DISPATCH_GROUP=( "+groups.join(" ")+" )";
	fillArrays(services);	if(services.length > 0)		result += "\nOCSNF_DISPATCH_SERVICE=( "+services.join(" ")+" )";
	fillArrays(algorithms);	if(algorithms.length > 0)	result += "\nOCSNF_DISPATCH_ALGORITHM=( "+algorithms.join(" ")+" )";
	fillArrays(ports);		if(ports.length > 0)		result += "\nOCSNF_DISPATCH_PORT=( "+ports.join(" ")+" )";
	fillArrays(patternAs);	if(patternAs.length > 0)	result += "\nOCSNF_DISPATCH_PATTERN_A=( "+patternAs.join(" ")+" )";
	fillArrays(operators);	if(operators.length > 0)	result += "\nOCSNF_DISPATCH_OPERATOR=( "+operators.join(" ")+" )";
	fillArrays(patternBs);	if(patternBs.length > 0)	result += "\nOCSNF_DISPATCH_PATTERN_B=( "+patternBs.join(" ")+" )";
	
	if(OCSNFpolicy.check != "")result=OCSNFpolicy.check;
	
	return result;
}

// ===========================
// Messaging Framework
// ===========================
var MessagingFramework = new vnfResource("MessagingFramework", [
	{name:'Property', type:'choice', choices:[ 
		'SERVICE_COMPONENT_NAME', 'INSTANCE_ID', 'TUNABLE', 
		'CONFIGURE_URL',
		'STORE_URL', 'QUEUE_URL', 'ROUTING_URL', 'FRONTEND_CACHE_URL',
		'ARCHIVER_URL', 'MCIF_URL', 'RCIF_URL', 
		'QMCIF_URL', 'MSC_SSN', 'HLR_SSN',
		'ADDRESSES',
		'SITE_ID',
		'TESTER', 'ROLE'], 
		width:'250px'},
	{name:'Value', type:'text', width:'600px'}
	]
	);

// Default values
var MessagingFrameworkDefault = new Array();
MessagingFrameworkDefault.SERVICE_COMPONENT_NAME="messaging-framework";
MessagingFrameworkDefault.INSTANCE_ID="1";
MessagingFrameworkDefault.TUNABLE="CoamServiceCfg.CONTEXT_PARAMS";
MessagingFrameworkDefault.CONFIGURE_URL="redis://${NIVRDB_LINUXHA_PASSWORD}@${REDIS_IP_ADDR}:${REDIS_PORT}";
MessagingFrameworkDefault.STORE_URL="redis://${NIVRDB_LINUXHA_PASSWORD}@${REDIS_IP_ADDR}:${REDIS_PORT}";
MessagingFrameworkDefault.QUEUE_URL="redis://${NIVRDB_LINUXHA_PASSWORD}@${REDIS_IP_ADDR}:${REDIS_PORT}";
MessagingFrameworkDefault.ROUTING_URL="redis://${NIVRDB_LINUXHA_PASSWORD}@${REDIS_IP_ADDR}:${REDIS_PORT}";
MessagingFrameworkDefault.FRONTEND_CACHE_URL="redis://${NIVRDB_LINUXHA_PASSWORD}@${REDIS_IP_ADDR}:${REDIS_PORT}";
MessagingFrameworkDefault.ARCHIVER_URL="mongodb://${MONGODB_HOST}:${MONGODB_PORT}/smsc?ssl=false";
MessagingFrameworkDefault.ADDRESSES="gtssn:0688888888.149,gt:12345678,gtssn:0672990000.150";

MessagingFramework.help = function(){
	return "Messaging Framework properties:"
	+ "\n SERVICE_COMPONENT_NAME: the name of the service created on the SEE application server to run MessagingFramework"
	+ "\n INSTANCE_ID: the SEE instance Ids assigned to the SEE service hosting this application, one per SEE node, as a list of comma separated integers, defaulting to the first in the list"
	+ "\n APPLICATION: supported values are TESTER or SMSC, default: TESTER"
	+ "\n\nEach Messaging Framework property falls in one of those categories:"
	+ "\n\t1.	Mandatory: missing such a parameter prevents building the descriptor and stops the deployment immediately"
	+ "\n\t2.	Required: missing such a parameter triggers a default value being sent to Messaging Framework"
	+ "\n\t3.	Optional: no value sent to Messaging Framework, "
	+ "\nMandatory properties:"
	+ "\n CONFIGURE_URL: URL of Redis Configuration Repository instance"
	+ "\n\teg: redis://[password@]host[:port] or redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId"
	+ "\n STORE_URL: URL of Redis Message Store instance - eg: redis://[password@]host[:port] or redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId"
	+ "\n QUEUE_URL: URL of Redis Message Queue instance - eg: redis://[password@]host[:port] "
	+ "\n ROUTING_URL: URL of Redis Routing Table instance - eg: redis://[password@]host[:port] or redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId"
	+ "\nRequired properties:"
	+ "\n SITE_ID: default: $(hostname -d)"
	+ "\n ARCHIVER_URL: URL of MongoDB Message History; required if a mongo role is defined in the nodes list, default: mongodb://${MONGODB_HOST}:${MONGODB_PORT}/smsc?ssl=false"
	+ "\n MSC_SSN: Default subsystem number for reaching MSCs; default: 10"
	+ "\n HLR_SSN: Default subsystem number for reaching HLRs; default: 10"
	+ "\n MCIF_URL: URL of Orchestration Application for processing MCIF sessions; required on backend nodes, default:<empty>"
	+ "\n RCIF_URL: URL of Orchestration Application for processing RCIF sessions; required on backend nodes, default:<empty>"
	+ "\n QMCIF_URL: URL of Orchestration Application for processing MCIF Query sessions; required on backend nodes, default:<empty>"
	+ "\n ROLE: force the Messaging Framework role on all nodes to MONOLITHIC or FRONTEND or BACKEND"
	+ "\n\tDefault: if UCP or SMPP provider is defined, or TCAP and the node is a USPM backend, the node is a Messaging Framework FRONTEND (MONOLITHIC if simplex)"
	+ "\n\tOtherwise the node is a Messaging Framework BACKEND." 
	+ "\nOptional properties:"
	+ "\n FRONTEND_CACHE_URL: URL of Redis Front End Cache instance; implies enableQuotaCorrection:true"
	+ "\n\teg: redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId"
	+ "\n ADDRESSES: Listening Addresses, as a list of comma separated addresses"
	;
};

MessagingFramework.build = function(){
	var nameIndexes = MessagingFramework.nameIndexes;
	var result = "\n";
	
	MessagingFramework.check = "";
	var table = document.getElementById('MessagingFramework');
	var rowCount = table.rows.length;
	result += '\n# ------------------------------- #';
	result += '\n#       Messaging Framework       #';
	result += '\n# ------------------------------- #';
	if(MessagingFramework.search('Property', 'SERVICE_COMPONENT_NAME')){
		// Activate Messaging Framework
		result += '\nACTIVATE_APPLI_MESSAGING_FRAMEWORK=yes';
		
		// Check mandatory parameters
		if(!MessagingFramework.search('Property', 'INSTANCE_ID'))MessagingFramework.check += "\nMessaging Framework: INSTANCE_ID is required";
		if(!MessagingFramework.search('Property', 'TUNABLE'))MessagingFramework.check += "\nMessaging Framework: TUNABLE is required";
		if(!MessagingFramework.search('Property', 'CONFIGURE_URL'))MessagingFramework.check += "\nMessaging Framework: CONFIGURE_URL is required";
		if(!MessagingFramework.search('Property', 'STORE_URL'))MessagingFramework.check += "\nMessaging Framework: STORE_URL is required";
		if(!MessagingFramework.search('Property', 'QUEUE_URL'))MessagingFramework.check += "\nMessaging Framework: QUEUE_URL is required";
		if(!MessagingFramework.search('Property', 'ROUTING_URL'))MessagingFramework.check += "\nMessaging Framework: ROUTING_URL is required";
	} else {
		if(rowCount > 1)MessagingFramework.check += "\nMessaging Framework: SERVICE_COMPONENT_NAME is required";
	}
	for(var i=1; i < rowCount; i++){
		var propertyName=MessagingFramework.getAndSetSelection(table.rows[i], nameIndexes, 'Property');
		var propertyValue=MessagingFramework.getAndSetValue(table.rows[i], nameIndexes, 'Value', MessagingFrameworkDefault[propertyName], propertyName);
		if(propertyName == 'INSTANCE_ID')MessagingFramework.check+=checkSeeInstanceId(propertyValue, "Messaging Framework");
		result += '\nMESSAGING_FRAMEWORK_'+propertyName+'="'+propertyValue+'"';
	}

	if(MessagingFramework.check != "")result = MessagingFramework.check;
	
	return result;
}

// ===============================
// Messaging Framework Application
// ===============================
var MessagingFrameworkApplication = new vnfResource("MessagingFrameworkApplication", [
	{name:'Name', type:'choice', choices:[ 'TESTER', 'SMSC'], width:'200px'},
	{name:'Type', type:'text', width:'200px'},
	{name:'Base', type:'text', width:'400px'},
	{name:'Diameter', type:'text', width:'200px'},
	{name:'Configuration', type:'text', width:'400px'}
	]
	);

// Default values and Descriptor names
var MessagingFrameworkApplicationDefaultTypes = new Array();
var MessagingFrameworkApplicationDefaultBases = new Array();
var MessagingFrameworkApplicationDefaultConfiguration=new Array();
MessagingFrameworkApplicationDefaultTypes['TESTER']="msgpf";
MessagingFrameworkApplicationDefaultTypes['SMSC']="MSGPF";
MessagingFrameworkApplicationDefaultBases['TESTER']="/opt/OC/share/java/hpe-messaging-framework/see-service-ear.ear";
MessagingFrameworkApplicationDefaultBases['SMSC']="/opt/OC/share/java/hpe-smsc/smsc.ear";
MessagingFrameworkApplicationDefaultConfiguration['SMSC']="/etc/opt/OC/hpoc-nivr-nfv/minConfig.json";
MessagingFrameworkApplicationDefaultConfiguration['TESTER']="";

MessagingFrameworkApplication.help = function(){
	return "Application running on top of Messaging Framework:"
	+ "\n Name: the name of the application to run on top of MessagingFramework: TESTER|SMSC"
	+ "\n Type: the SEE application type used for the SEE service hosting this application: default to msgpf for the TESTER and MSGPF for SMSC"
	+ "\n Base: (file  path) the full path to the ear delivering the MessagingFramework application" 
	+ "\n Diameter: (SMSC only) name of the Diameter provider the SMSC application should connect to"
	+ "\n\tA Diameter provider name has the form: <Diameter service name>_<Diameter provider type>, eg: diameter_RO, myservice_SH, mrf_RF" 
	+ "\n Configuration:(file path) the full path of the Messaging Framework Application Configuration file(typically .json format in SMSC case)"
	;
};

MessagingFrameworkApplication.build = function(){
	var nameIndexes = MessagingFrameworkApplication.nameIndexes;
	var result = "\n";
	
	MessagingFrameworkApplication.check = "";
	var table = document.getElementById('MessagingFrameworkApplication');
	var rowCount = table.rows.length;
	result += '\n# ------------------------------- #';
	result += '\n# Messaging Framework Application #';
	result += '\n# ------------------------------- #';
	if(MessagingFramework.search('Property', 'SERVICE_COMPONENT_NAME')){
		for(var i=1; i < rowCount; i++){
			if(i > 1){
				MessagingFrameworkApplication.check += "\nMessaging Framework application: only one application supported at a time";
				break;
			}
			var name=MessagingFrameworkApplication.getAndSetSelection(table.rows[i], nameIndexes, 'Name');
			var type=MessagingFrameworkApplication.getAndSetValue(table.rows[i], nameIndexes, 'Type', MessagingFrameworkApplicationDefaultTypes[name]);
			var base=MessagingFrameworkApplication.getAndSetValue(table.rows[i], nameIndexes, 'Base', MessagingFrameworkApplicationDefaultBases[name]);
			var diameter=MessagingFrameworkApplication.getAndSetValue(table.rows[i], nameIndexes, 'Diameter');
			var diameterName=diameter.split('_')[0] ;
			var configuration=MessagingFrameworkApplication.getAndSetValue(table.rows[i], nameIndexes, 'Configuration', MessagingFrameworkApplicationDefaultConfiguration[name]);
			MessagingFrameworkApplication.heatSmscAuxDescPath=configuration;
			MessagingFrameworkApplication.check += checkDependency(name == 'SMSC', [diameter != ""], 'Messaging Framework application ', name +' requires a Diameter provider');
			MessagingFrameworkApplication.check += checkDependency(name == 'SMSC', [Diameter.search('Name', diameterName)], 'Messaging Framework Application vs Diameter: SMSC misses the Diameter provider ', diameterName);
			result += '\nMESSAGING_FRAMEWORK_APPLICATION='+name;
			result += '\nMESSAGING_FRAMEWORK_APPLICATION_TYPE='+type;
			result += '\nMESSAGING_FRAMEWORK_APPLICATION_BASE='+base;
			result += '\nMESSAGING_FRAMEWORK_APPLICATION_CONFIGURATION='+configuration;
			if(diameter != "")result += '\nMESSAGING_FRAMEWORK_APPLICATION_DIAMETER_PROVIDER='+diameter;
		}
	} else {
		if(rowCount > 1)MessagingFrameworkApplication.check += "\nMessaging Framework: SERVICE_COMPONENT_NAME is required";
	}

	if(MessagingFrameworkApplication.check != "")result = MessagingFrameworkApplication.check;
	
	return result;
}

// ===========================
// Messaging Gateway
// ===========================
var MessagingGateway = new vnfResource("MessagingGateway", [
	{name:'Property', type:'choice', choices:[ 
		'SERVICE_COMPONENT_NAME', 'INSTANCE_ID',
		'POINTCODE', 'COUNTRY_CODE', 'NAT_PREFIX_LENGTH', 
		'GLOBAL_TITLE_SMS', 'GLOBAL_TITLE_USSD', 'GLOBAL_TITLE_MS',
		'SMSGW_APPLICATION_CTX_NAME_PRESENT', 'SMSGW_DIALOGPORTIONPRESENT_FOR_MTFWD', 'SMSGW_PID_SMS_TPDU_FIELD',
		'SMSGW_APP_HOST', 'SMSGW_APP_AVAILABILITY_PATH', 'SMSGW_SMPP_PORT',
		'T_POINTCODE', 'T_SSN', 'T_GLOBAL_TITLE'], 
		width:'250px'},
	{name:'Value', type:'text', width:'400px'}
	]
	);

// Default values
var MessagingGatewayDefault = new Array();
MessagingGatewayDefault.SERVICE_COMPONENT_NAME="MSGGW_GATEWAY";
MessagingGatewayDefault.POINTCODE="2050";
MessagingGatewayDefault.COUNTRY_CODE="49";
MessagingGatewayDefault.INSTANCE_ID="1";
MessagingGatewayDefault.NAT_PREFIX_LENGTH="1";
MessagingGatewayDefault.GLOBAL_TITLE_SMS="525549998068";
MessagingGatewayDefault.GLOBAL_TITLE_USSD="444444444411";
MessagingGatewayDefault.GLOBAL_TITLE_MS="525549998060";
MessagingGatewayDefault.SMSGW_APP_HOST="10.32.247.33";
MessagingGatewayDefault.SMSGW_APP_AVAILABILITY_PATH="9099/handset/fakeservice";
MessagingGatewayDefault.SMSGW_SMPP_PORT="2777";
MessagingGatewayDefault.T_POINTCODE="590";
MessagingGatewayDefault.T_SSN="6";
MessagingGatewayDefault.T_GLOBAL_TITLE="525549998066";

MessagingGateway.help = function(){
	return "Messaging Gateway properties:"
	+ "\n SERVICE_COMPONENT_NAME: the name of the service created on the SEE application server to run MessagingGateway"
	+ "\n Connectivity"
	+ "\n - Up to three TCAP providers are to be associated to this application SERVICE_COMPONENT_NAME, using the predefined names: USSD-TCAP-Provider SMS-TCAP-Provider MS-TCAP-Provider"
	+ "\n SMS part of Messaging Gateway"
	+ "\n - GLOBAL_TITLE_SMS: The Global Title should be a phone number including country code, for example 919845012345 or 33442343445"
	+ "\n - SMSGW_SMPP_PORT: SMPP Gateway (FDA-SMSC) properties"
	+ "\n - SMSGW_APP_HOST, SMSGW_APP_AVAILABILITY_PATH: SMS Gateway service parameters from the DSP application"
	+ "\n USSD part of Messaging Gateway"
	+ "\n - GLOBAL_TITLE_USSD"
	+ "\n MAP Services part of Messaging Gateway"
	+ "\n - GLOBAL_TITLE_MS"
	+ "\n Handset test tool properties"
	+ "\n - T_POINTCODE"
	+ "\n - T_SSN"
	+ "\n - T_GLOBAL_TITLE"
	;
};

MessagingGateway.build = function(){
	var nameIndexes = MessagingGateway.nameIndexes;
	var result = "\n";
	
	MessagingGateway.check = "";
	var table = document.getElementById('MessagingGateway');
	var rowCount = table.rows.length;
	result += '\n# ------------------------------- #';
	result += '\n#       Messaging Gateway       #';
	result += '\n# ------------------------------- #';
	if(MessagingGateway.search('Property', 'SERVICE_COMPONENT_NAME')){
		// Activate Messaging Gateway
		result += '\nACTIVATE_APPLI_MESSAGING_GATEWAY=yes';

		// Check mandatory parameters
		if(!MessagingGateway.search('Property', 'INSTANCE_ID'))MessagingGateway.check += "\nMessaging Gateway: INSTANCE_ID is required";
		if(!MessagingGateway.search('Property', 'POINTCODE'))MessagingGateway.check += "\nMessaging Gateway: POINTCODE is required";
		if(!MessagingGateway.search('Property', 'GLOBAL_TITLE_SMS'))MessagingGateway.check += "\nMessaging Gateway: GLOBAL_TITLE_SMS is required";
		if(!MessagingGateway.search('Property', 'GLOBAL_TITLE_USSD'))MessagingGateway.check += "\nMessaging Gateway: GLOBAL_TITLE_USSD is required";
		if(!MessagingGateway.search('Property', 'GLOBAL_TITLE_MS'))MessagingGateway.check += "\nMessaging Gateway: GLOBAL_TITLE_MS is required";
		if(!MessagingGateway.search('Property', 'SMSGW_APP_HOST'))MessagingGateway.check += "\nMessaging Gateway: SMSGW_APP_HOST is required";
		if(!MessagingGateway.search('Property', 'SMSGW_APP_AVAILABILITY_PATH'))MessagingGateway.check += "\nMessaging Gateway: SMSGW_APP_AVAILABILITY_PATH is required";
		if(!MessagingGateway.search('Property', 'SMSGW_SMPP_PORT'))MessagingGateway.check += "\nMessaging Gateway: SMSGW_SMPP_PORT is required";
		
		// Check mandatory parameters: at least one TCAP provider with the expected names
		if(!(TCAP.search('Provider name', 'USSD-TCAP-Provider') || TCAP.search('Provider name', 'SMS-TCAP-Provider') || TCAP.search('Provider name', 'MS-TCAP-Provider')))
			MessagingGateway.check += "\nMessaging Gateway : at least one TCAP provider named USSD-TCAP-Provider or SMS-TCAP-Provider or MS-TCAP-Provider is required";
			
		// Prevent instantiation on SEE with non USPM back end nodes
		if(Nodes.seeNodesNonUspmBackEnd != undefined && Nodes.seeNodesNonUspmBackEnd.length > 0)MessagingGateway.check+="\nMessaging Gateway: cannot instantiate on SEE cluster nodes not playing a USPM Back End role: "+Nodes.seeNodesNonUspmBackEnd.join(" ");
	} else {
		if(rowCount > 1)MessagingGateway.check += "\nMessaging Gateway: SERVICE_COMPONENT_NAME is required";
	}
	// Messaging Gateway cannot be instantiated on a specific VNFC, only on the composed VNF
	var VNFCindex = 0;	
	
	for(var i=1; i < rowCount; i++){
		var propertyName=MessagingGateway.getAndSetSelection(table.rows[i], nameIndexes, 'Property');
		var propertyValue=MessagingGateway.getAndSetValue(table.rows[i], nameIndexes, 'Value', MessagingGatewayDefault[propertyName], propertyName);
		// Legacy management: this application was designed with properties having a different prefix...
		var defaultPrefix='MSGGW_';
		if(propertyName.indexOf("SMSGW_", 0) == 0){
			defaultPrefix="";
		}
		if(propertyName  == 'SERVICE_COMPONENT_NAME' || propertyName == 'INSTANCE_ID'){
			defaultPrefix="MESSAGING_GATEWAY_";
		}
		
		// Make sure the service name is unchanged, not supported by Messaging Gateway
		if(propertyName  == 'SERVICE_COMPONENT_NAME' && propertyValue != MessagingGatewayDefault.SERVICE_COMPONENT_NAME){
			MessagingGateway.check += "\nMessaging Gateway service component name must be " + MessagingGatewayDefault.SERVICE_COMPONENT_NAME + "; the name " + propertyValue +" is not supported."; 
		}
		
		// Messaging Gateway is an application candidate to http load balancing: check conflict on instance id with other candidates
		if(propertyName  == 'INSTANCE_ID'){
			MessagingGateway.check+=checkSeeInstanceId(propertyValue, "Messaging Gateway");
			MessagingGateway.check += httpLbCheckAndGetSeeInstanceIds("Messaging Gateway", VNFCindex, propertyValue);
		}
	
		result += '\n'+defaultPrefix+propertyName+'="'+propertyValue+'"';
	}

	if(MessagingGateway.check != "")result = MessagingGateway.check;
	
	return result;
}

// ===========================
// Messaging Gateway Services
// ===========================
var MessagingGatewayServices = new vnfResource("MessagingGatewayServices", [
	{name:'Type', type:'choice', choices:[ 'Standard', 'SMPP' ], width:'80px'},
	{name:'Name', type:'text', width:'120x'},
	{name:'User', type:'text', width:'80px'},
	{name:'Password', type:'text', width:'80px'},
	{name:'Code', type:'text', width:'120px'},
	{name:'Service Path', type:'text', width:'400px'}
	]
	);

MessagingGatewayServices.help = function(){
	return "Messaging Gateway services to be provisioned: " +
	"\n\tname, user, password and service code are all required" +
	"\n\tTypical service names: SMS_MO SMS_MT SMPP..."+
	"\n\tService Path: <port number>/<path to the script on the server>, eg: 8080/ListeningUSSDEtSMSMOservice/smsmo.jsp (not supported on SMPP services)";
};

MessagingGatewayServices.build = function(){
	var nameIndexes = MessagingGatewayServices.nameIndexes;
	var result = "\n";
	
	var names = new Array();
	var users = new Array();
	var passwords = new Array();
	var codes = new Array();
	var paths = new Array();
	names['Standard'] = new Array();
	codes['Standard'] = new Array();
	users['Standard'] = new Array();
	passwords['Standard'] = new Array();
	paths['Standard'] = new Array();
	names['SMPP'] = new Array();
	users['SMPP'] = new Array();
	passwords['SMPP'] = new Array();
	codes['SMPP'] = new Array();
	paths['SMPP'] = new Array();

	MessagingGatewayServices.check = "";
	var table = document.getElementById('MessagingGatewayServices');
	var rowCount = table.rows.length;
	result += '\n# ------------------------------- #';
	result += '\n#    Messaging Gateway Services   #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var type=MessagingGatewayServices.getAndSetSelection(table.rows[i], nameIndexes, 'Type');
		var Name=MessagingGatewayServices.getAndSetValue(table.rows[i], nameIndexes, 'Name', 'msggw'+type + i);
		var User=MessagingGatewayServices.getAndSetValue(table.rows[i], nameIndexes, 'User', 'ocadmin');
		var Password=MessagingGatewayServices.getAndSetValue(table.rows[i], nameIndexes, 'Password', 'ocadmin');
		var Code=MessagingGatewayServices.getAndSetValue(table.rows[i], nameIndexes, 'Code', '1234567890');
		var Path=MessagingGatewayServices.getAndSetValue(table.rows[i], nameIndexes, 'Service Path', type != 'SMPP' ? '8080/ListeningUSSDEtSMSMOservice/smsmo.jsp' : '', 'Messaging Gateway Service Example:');
		
		MessagingGatewayServices.check += checkGroupConsistency([Name != "", User != "", Password != "", Code != ""], "Messaging Gateway service " + Name, " is missing User or Password or Code");
		MessagingGatewayServices.check += checkDependency(type == 'SMPP', [Path == ""], 'Service path ', Path+' not supported for SMPP service '+ Name);
		names[type].push(Name);
		users[type].push(User);
		passwords[type].push(Password);
		codes[type].push(Code);
		paths[type].push('"'+Path+'"');
	}

	if(MessagingGatewayServices.check != "")return MessagingGatewayServices.check;
	if(names['Standard'].length > 0){
		result += "\nSMSGW_APP_SERVICE=( "+			names['Standard'].join(" ")+" )";
		result += "\nSMSGW_APP_SERVICE_USERNAME=( "+users['Standard'].join(" ")+" )";
		result += "\nSMSGW_APP_SERVICE_PASSWORD=( "+passwords['Standard'].join(" ")+" )";
		result += "\nSMSGW_APP_SERVICE_CODE=( "		+codes['Standard'].join(" ")+" )";
		result += "\nSMSGW_APP_SERVICE_PATH=( "		+paths['Standard'].join(" ")+" )";
	}
	if(names['SMPP'].length > 0){
		result += "\nSMSGW_APP_SMPP_SERVICE=( "+		names['SMPP'].join(" ")+" )";
		result += "\nSMSGW_APP_SMPP_SERVICE_USERNAME=( "+users['SMPP'].join(" ")+" )";
		result += "\nSMSGW_APP_SMPP_SERVICE_PASSWORD=( "+passwords['SMPP'].join(" ")+" )";
		result += "\nSMSGW_APP_SMPP_SERVICE_CODE=( "	+codes['SMPP'].join(" ")+" )";
	}
	
	return result;
}

// ==================
// OCCP country
// ==================
var OCCPcountry = new vnfResource("OCCPcountry", [
	{name:'Name', type:'text'}, 
	{name:'Code', type:'text'}, 
	{name:'Prefix', type:'text'}, 
	{name:'International', type:'text'}
	]
	);
	
OCCPcountry.help = function(){
	return "OCCP countries definition" + 
	"\nName: country name"+
	"\nCode: code specific for this country."+
	"\nPrefix (network access code NAC): prefix for national number for the country."+
	"\nInternational (international access code IAC): prefix for calling outside of the country.";
}
	
OCCPcountry.build = function(){
	var nameIndexes = OCCPcountry.nameIndexes;
	var result = '\n';
	OCCPcountry.check = "";
	var table = document.getElementById('OCCPcountry');
	var rowCount = table.rows.length;
	
	var names = new Array();
	var codes = new Array();
	var prefixes = new Array();
	var internationals = new Array();
	
	result += '\n# ------------------------------- #';
	result += '\n# OCCP countries                  #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var name=OCCPcountry.getAndSetValue(table.rows[i], nameIndexes, 'Name', 'France');
		var code=OCCPcountry.getAndSetValue(table.rows[i], nameIndexes, 'Code', '33');
		var prefix=OCCPcountry.getAndSetValue(table.rows[i], nameIndexes, 'Prefix', '');
		var international=OCCPcountry.getAndSetValue(table.rows[i], nameIndexes, 'International', '');
		if(name == ""){OCCPcountry.check += "\nOCCP Country code "+code+": name cannot be blank"; }
		if(names.indexOf(name) != -1){OCCPcountry.check += "\nOCCPcountry: duplicated name "+name; }
		if(code == ""){OCCPcountry.check += "\nOCCP Country "+name+": code cannot be blank"; continue;}
		if(codes.indexOf(code) != -1){OCCPcountry.check += "\nOCCPcountry: duplicated code "+code; break;}
		names.push(name);
		codes.push(code);
		if(prefix != ""){prefixes[i-1]=prefix;}
		if(international != ""){internationals[i-1]=international;}
	}
	if(names.length > 0)		{result += "\nOCCP_COUNTRY=( "+names.join(" ")+" )";}
	if(codes.length > 0)		{result += "\nOCCP_COUNTRY_CC=( "+codes.join(" ")+" )";}
	if(prefixes.length > 0)		{fillArrays(prefixes);	result += "\nOCCP_COUNTRY_NAC=( "+prefixes.join(" ")+" )";}
	if(internationals.length > 0){fillArrays(internationals);	result += "\nOCCP_COUNTRY_IAC=( "+internationals.join(" ")+" )";}

	// local check
	if(OCCPcountry.check != "")result = OCCPcountry.check;
	return result;
}

// ====================
// OCCP switching point
// ====================
var OCCPswitchingPoint = new vnfResource("OCCPswitchingPoint", [
	{name:'Name', type:'text'}, 
	{name:'Country', type:'text'}, 
	{name:'Operator', type:'text'}, 
	{name:'Digits', type:'text'}, 
	{name:'TCAP flavor', type:'choice', width:'60px', choices:['', 'ITU93', 'ITU88']},
	{name:'SCCP flavor', type:'choice', width:'60px', choices:['', 'ITU', 'ANSI']},
	{name:'SSN', type:'text'}, 
	{name:'Point Code', type:'text'}, 
	{name:'Protocol', type:'choice', width:'90px', choices:['', 'CAMEL1', 'CAMEL2', 'CAMEL3', 'CAMEL4', 'INAP_CS1', 'S7MP_CS1', 'NOKIA_CS1', 'ITALTEL_CS1', 'HUAWEI_CS1', 'ECS1PLUS_CS1', 'SINAP5_CS1', 'ALCATEL_CS1', 'TINAP_CS1']}
	]
	);
	
OCCPswitchingPoint.help = function(){
	return "OCCP: switching points inside a telecom network" + 
	"\nName: switching point name"+
	"\nOperator: telecom operator owning this switching point"+
	"\nCountry: identify the network for multi countries operator."+
	"\nDigits: switching point address. The digits must conform to the E.164 numbering standard. The address is considered as a prefix for the switching point address."+
	"\nTCAP flavor: tcap protocol used by the switching point; mandatory when the switch implements BLUE BOOK Tcap (ITU-T Tcap 1988). Default to ITU93."+
	"\nSCCP flavor: sccp protocol used by the switching point; mandatory when defining tcap protocol ITU88."+
	"\nSSN: Tcap ITU88 only. Define the subsystem number identifying the application on the node."+
	"\nPoint Code: Tcap ITU88 only. Define the point code designing the node into the network."+
	"\nProtocol: Call  Control protocol used between the switch and the ocsac.";
}
	
OCCPswitchingPoint.build = function(){
	var nameIndexes = OCCPswitchingPoint.nameIndexes;
	var result = '\n';
	OCCPswitchingPoint.check = "";
	var table = document.getElementById('OCCPswitchingPoint');
	var rowCount = table.rows.length;
	
	var names = new Array();
	var countries = new Array();
	var operators = new Array();
	var digits = new Array();
	var tcaps = new Array();
	var sccps = new Array();
	var ssns = new Array();
	var pcs = new Array();
	var protocols = new Array();
	
	result += '\n# ------------------------------- #';
	result += '\n# OCCP switching points           #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var name=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'Name', 'switch-'+i);
		var country=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'Country', 'France');
		var operator=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'Operator', 'Orange');
		var digit=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'Digits', '10000'+i);
		var tcap=OCCPswitchingPoint.getAndSetSelection(table.rows[i], nameIndexes, 'TCAP flavor', 0);
		var sccp=OCCPswitchingPoint.getAndSetSelection(table.rows[i], nameIndexes, 'SCCP flavor', tcap == 'ITU88' ? 1 : 0);
		var ssn=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'SSN');
		var pc=OCCPswitchingPoint.getAndSetValue(table.rows[i], nameIndexes, 'Point Code');
		var protocol=OCCPswitchingPoint.getAndSetSelection(table.rows[i], nameIndexes, 'Protocol', 0);
		
		if(name == ""){OCCPswitchingPoint.check += "\nOCCP switching point "+country+" "+operator+": name cannot be blank"; continue;}
		if(names.indexOf(name) != -1){OCCPswitchingPoint.check += "\nOCCPswitchingPoint: duplicated name "+name; continue;}
		if(country == ""){OCCPswitchingPoint.check += "\nOCCP switching point "+name+": country cannot be blank"; }
		if(!OCCPcountry.search('Name', country)){OCCPswitchingPoint.check += "\nOCCP switching point "+name+": country "+country+" undefined in OCCPcountry section"; }
		if(operator == ""){OCCPswitchingPoint.check += "\nOCCP switching point "+name+": operator cannot be blank"; }
		if(digit == ""){OCCPswitchingPoint.check += "\nOCCP switching point "+name+": digit cannot be blank"; }
		if(tcap == 'ITU88' && sccp == ""){OCCPswitchingPoint.check += "\nOCCP switching point "+name+": SCCP flavor cannot be blank for tcap "+tcap; }

		names.push(name);
		countries.push(country);
		operators.push(operator);
		digits.push(digit);
		
		if(tcap != "")		{tcaps[i-1]=tcap;}
		if(sccp != "")		{sccps[i-1]=sccp;}
		if(ssn != "")		{ssns[i-1]=ssn;}
		if(pc != "")		{pcs[i-1]=pc;}
		if(protocol != "")	{protocols[i-1]=protocol;}
		
	}
	if(names.length > 0)	{result += "\nOCCP_SWITCHING_POINT=( "+names.join(" ")+" )";}
	if(countries.length > 0)	{result += "\nOCCP_SWITCHING_POINT_COUNTRY=( "+countries.join(" ")+" )";}
	if(operators.length > 0)	{result += "\nOCCP_SWITCHING_POINT_OPERATOR=( "+operators.join(" ")+" )";}
	if(digits.length > 0)	{result += "\nOCCP_SWITCHING_POINT_DIGITS=( "+digits.join(" ")+" )";}
	
	if(tcaps.length > 0)	{fillArrays(tcaps);		result += "\nOCCP_SWITCHING_POINT_TCAP_FLAVOR=( "+tcaps.join(" ")+" )";}
	if(sccps.length > 0)	{fillArrays(sccps);		result += "\nOCCP_SWITCHING_POINT_TCAP_SCCP_FLAVOR=( "+sccps.join(" ")+" )";}
	if(ssns.length > 0)		{fillArrays(ssns);		result += "\nOCCP_SWITCHING_POINT_TCAP_SSN=( "+ssns.join(" ")+" )";}
	if(pcs.length > 0)		{fillArrays(pcs);		result += "\nOCCP_SWITCHING_POINT_TCAP_POINT_CODE=( "+pcs.join(" ")+" )";}
	if(protocols.length > 0){fillArrays(protocols);	result += "\nOCCP_SWITCHING_POINT_PROTOCOL=( "+protocols.join(" ")+" )";}

	// local check
	if(OCCPswitchingPoint.check != "")result = OCCPswitchingPoint.check;
	return result;
}

// ====================
// OCCP media server
// ====================
var OCCPmediaServer = new vnfResource("OCCPmediaServer", [
	{name:'Name', type:'text'}, 
	{name:'Country', type:'text'}, 
	{name:'Operator', type:'text'}, 
	{name:'Mode', type:'choice', width:'90px', choices:['cs:direct', 'cs:relay', 'sip:netann', 'sip:mscml']},
	{name:'Type', type:'choice', width:'120px', choices:['IVR', 'ANNOUNCER', 'IVR,ANNOUNCER']},
	{name:'SIP URI', type:'text', width:'120px'},
	{name:'NAI', type:'choice', width:'120px', choices:['', 'UNKNOWN', 'INTERNATIONAL_NUMBER', 'NATIONAL_SIGNIFICANT_NUMBER', 'NETWORK_SPECIFIC_NUMBER', 'SUBSCRIBER_NUMBER', 'ABBREVIATED_NUMBER']},
	{name:'NPI', type:'choice', width:'90px', choices:['', 'UNKNOWN', 'E164', 'X121', 'F69', 'E212', 'NATIONAL', 'PRIVATE']}, 
	{name:'Address', type:'text'},
	{name:'Switching point', type:'text'},
	{name:'Weight', type:'text', width:'50px'},
	{name:'OCMP', type:'bool'},
	{name:'TCAP flavor', type:'choice', width:'60px', choices:['', 'ITU93', 'ITU88']},
	{name:'SCCP flavor', type:'choice', width:'60px', choices:['', 'ITU', 'ANSI']},
	{name:'SSN', type:'text'}, 
	{name:'Point Code', type:'text'}, 
	{name:'Protocol', type:'choice', width:'90px', choices:['', 'CAMEL1', 'CAMEL2', 'CAMEL3', 'CAMEL4', 'INAP_CS1', 'S7MP_CS1', 'NOKIA_CS1', 'ITALTEL_CS1', 'HUAWEI_CS1', 'ECS1PLUS_CS1', 'SINAP5_CS1', 'ALCATEL_CS1', 'TINAP_CS1']}
	]
	);
	
OCCPmediaServer.help = function(){
	return "OCCP: media servers inside a telecom network" + 
	"\nName: media server name"+
	"\nOperator: telecom operator owning this media server"+
	"\nCountry: identify the network for multi countries operator."+
	"\nMode: network technology used by the media server; it is of the form <tech>:<sub-tech>."+
	"\nType: type of media server; it can be any combination of IVR and ANNOUNCER"+
	"\nSIP URI: media server address in the form of a SIP URI. Refer to RFC3261 for the format of SIP/SIPS URI."+
	"\nNAI: nature of address indicator for IN address. The default value is INTERNATIONAL_NUMBER."+
	"\nNPI: numbering plan indicator for IN address. The default value is E164."+
	"\nAddress: media server address. The digits must conform to the E.164 numbering standard."+
	"\nSwitching point: for cs:relay mode: name of the corresponding switching point which supports the relay mode IVR procedures."+
	"\n\tThe switching point must have been previously configured and must be defined for the same network as this media server."+
	"\nWeight: relative weight for this media server for dispatching inside a group/PoP. A higher value for weight will result in more traffic being dispatched to this media server."+
	"\nOCMP: Specific media server implementing OCMP extensions"+
	"\nTCAP flavor: tcap protocol used by the switching point; mandatory when the switch implements BLUE BOOK Tcap (ITU-T Tcap 1988). Default to ITU93."+
	"\nSCCP flavor: sccp protocol used by the switching point; mandatory when defining tcap protocol ITU88."+
	"\nSSN: Tcap ITU88 only. Define the subsystem number identifying the application on the node."+
	"\nPoint Code: Tcap ITU88 only. Define the point code designing the node into the network."+
	"\nProtocol: Call  Control protocol used between the switch and the ocsac.";
}
	
OCCPmediaServer.build = function(){
	var nameIndexes = OCCPmediaServer.nameIndexes;
	var result = '\n';
	OCCPmediaServer.check = "";
	var table = document.getElementById('OCCPmediaServer');
	var rowCount = table.rows.length;
	
	var names = new Array();
	var countries = new Array();
	var operators = new Array();
	var modes = new Array();
	var types = new Array();
	var sipuris = new Array();
	var nais = new Array();
	var npis = new Array();
	var addresses = new Array();
	var swpoints = new Array();
	var weights = new Array();
	var ocmps = new Array();
	var tcaps = new Array();
	var sccps = new Array();
	var ssns = new Array();
	var pcs = new Array();
	var protocols = new Array();
	
	result += '\n# ------------------------------- #';
	result += '\n# OCCP media servers              #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var name=		OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Name', 'media-'+i);
		var country=	OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Country', 'France');
		var operator=	OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Operator', 'Orange');
		var mode=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'Mode', 0);
		var type=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'Type', 0);
		var sipuri=		OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'SIP URI');
		var nai=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'NAI');
		var npi=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'NPI');
		var address=	OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Address', sipuri == "" ? '10000'+i:"");
		var swpoint=	OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Switching point');
		var weight=		OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Weight');
		var ocmp=		OCCPmediaServer.getAndSetChecked(table.rows[i], nameIndexes, 'OCMP');
		var tcap=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'TCAP flavor', 0);
		var sccp=		OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'SCCP flavor', tcap == 'ITU88' ? 1 : 0);
		var ssn=		OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'SSN');
		var pc=			OCCPmediaServer.getAndSetValue(table.rows[i], nameIndexes, 'Point Code');
		var protocol=	OCCPmediaServer.getAndSetSelection(table.rows[i], nameIndexes, 'Protocol', 0);
		
		if(name == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+country+" "+operator+": name cannot be blank"; continue;}
		if(names.indexOf(name) != -1){OCCPmediaServer.check += "\nOCCPmediaServer: duplicated name "+name; continue;}
		if(country == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": country cannot be blank"; }
		if(!OCCPcountry.search('Name', country)){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": country "+country+" undefined in OCCPcountry section"; }
		if(operator == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": operator cannot be blank"; }
		if(mode == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": mode cannot be blank"; }
		if(type == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": mode cannot be blank"; }
		if(tcap == 'ITU88' && sccp == ""){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": SCCP flavor cannot be blank for tcap "+tcap; }
		if(swpoint != "")if(!OCCPswitchingPoint.search('Name', swpoint)){OCCPmediaServer.check += "\nOCCPmediaServer "+name+": switching point "+swpoint+" undefined in OCCPswitchingPoint section"; }

		names.push(name);
		countries.push(country);
		operators.push(operator);
		modes.push(mode);
		types.push(type);
		if(sipuri != "")	{sipuris[i-1]="'"+sipuri+"'";}
		if(nai != "")		{nais[i-1]=nai;}
		if(npi != "")		{npis[i-1]=npi;}
		if(address != "")	{addresses[i-1]=address;}
		if(swpoint != "")	{swpoints[i-1]=swpoint;}
		if(weight != "")	{weights[i-1]=weight;}
		if(ocmp)			{ocmps[i-1]='ocmp';}
		if(tcap != "")		{tcaps[i-1]=tcap;}
		if(sccp != "")		{sccps[i-1]=sccp;}
		if(ssn != "")		{ssns[i-1]=ssn;}
		if(pc != "")		{pcs[i-1]=pc;}
		if(protocol != "")	{protocols[i-1]=protocol;}
		
	}
	if(names.length > 0)	{result += "\nOCCP_MEDIA_SERVER=( "+names.join(" ")+" )";}
	if(countries.length > 0){result += "\nOCCP_MEDIA_SERVER_COUNTRY=( "+countries.join(" ")+" )";}
	if(operators.length > 0){result += "\nOCCP_MEDIA_SERVER_OPERATOR=( "+operators.join(" ")+" )";}
	if(modes.length > 0)	{result += "\nOCCP_MEDIA_SERVER_MODE=( "+modes.join(" ")+" )";}
	if(types.length > 0)	{result += "\nOCCP_MEDIA_SERVER_TYPE=( "+types.join(" ")+" )";}
	if(sipuris.length > 0)	{fillArrays(sipuris);	result += "\nOCCP_MEDIA_SERVER_SIPURI=( "+sipuris.join(" ")+" )";}
	if(nais.length > 0)		{fillArrays(nais);		result += "\nOCCP_MEDIA_SERVER_NAI=( "+nais.join(" ")+" )";}
	if(npis.length > 0)		{fillArrays(npis);		result += "\nOCCP_MEDIA_SERVER_NPI=( "+npis.join(" ")+" )";}
	if(addresses.length > 0){fillArrays(addresses);	result += "\nOCCP_MEDIA_SERVER_ADDRESS=( "+addresses.join(" ")+" )";}
	if(swpoints.length > 0)	{fillArrays(swpoints);	result += "\nOCCP_MEDIA_SERVER_SWITCHING_POINT=( "+swpoints.join(" ")+" )";}
	if(weights.length > 0)	{fillArrays(weights);	result += "\nOCCP_MEDIA_SERVER_WEIGHT=( "+weights.join(" ")+" )";}
	if(ocmps.length > 0)	{fillArrays(ocmps);		result += "\nOCCP_MEDIA_SERVER_TAG=( "+ocmps.join(" ")+" )";}
	if(tcaps.length > 0)	{fillArrays(tcaps);		result += "\nOCCP_MEDIA_SERVER_TCAP_FLAVOR=( "+tcaps.join(" ")+" )";}
	if(sccps.length > 0)	{fillArrays(sccps);		result += "\nOCCP_MEDIA_SERVER_TCAP_SCCP_FLAVOR=( "+sccps.join(" ")+" )";}
	if(ssns.length > 0)		{fillArrays(ssns);		result += "\nOCCP_MEDIA_SERVER_TCAP_SSN=( "+ssns.join(" ")+" )";}
	if(pcs.length > 0)		{fillArrays(pcs);		result += "\nOCCP_MEDIA_SERVER_TCAP_POINT_CODE=( "+pcs.join(" ")+" )";}
	if(protocols.length > 0){fillArrays(protocols);	result += "\nOCCP_MEDIA_SERVER_PROTOCOL=( "+protocols.join(" ")+" )";}

	// local check
	if(OCCPmediaServer.check != "")result = OCCPmediaServer.check;
	return result;
}

// ===========================
// TCAP connectivity provider
// ===========================
var TCAP = new vnfResource("TCAP", [
	{name:'VNFC', type:'text'}, 
	{name:'Provider name', type:'text', width:'150px'}, 
	{name:'Service name', type:'text', width:'200px'}, 
	{name:'Instance Id', type:'text'}, 
	{name:'App Id', type:'text'}, 
	{name:'SS7 stack', type:'text'}, 
	{name:'Flavor', type:'text'}, 
	{name:'SCCP flavor', type:'text'}, 
	{name:'SSN', type:'text'}, 
	{name:'Point code', type:'text'}, 
	{name:'App base',type:'text', width:'250px'}
	]
	);

TCAP.help = function(){
	return "TCAP connectivity provider properties:"
	+ "\nProvider name: the name of the TCAP provider created on the service; USSD-TCAP-Provider SMS-TCAP-Provider MS-TCAP-Provider are reserved names for Messaging Gateway application"
	+ "\nService name: the name of the service created on the SEE application server, using this/those TCAP providers; default to messaging framework one"
	+ "\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this TCAP provider, one per SEE node, as a list of comma separated integers, defaulting to the first in the list (default to messaging framework setting)"
	+ "\nApp Id: the application Id assigned to this TCAP provider, as a comma separated list per see node, so that application ids can be specific to each see node"
	+ "\nSS7 stack: the SS7 stack name used to create this TCAP provider, eg SS7_Stack_1"
	+ "\nFlavor: the flavor used to create this TCAP provider, eg ITU93"
	+ "\nSCCP flavor: the SCCP flavor used to create this TCAP provider"
	+ "\nSSN: subsystem number used to create this TCAP provider"
	+ "\nPoint code: the point code used to create this TCAP provider"
	+ "\nApp base: (file  path) the full path to the ear delivering the SEE application server using this/those TCAP providers (default to messaging framework one)"
	;
};

TCAP.build = function(){
	var nameIndexes = TCAP.nameIndexes;
	var result = "\n";
	
	TCAP.check = "";
	var currentVNFC = "";
	var table = document.getElementById('TCAP');
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array(nbVNFC);
	var serviceNames = new Array(nbVNFC);
	var instanceIds = new Array(nbVNFC);
	var appIds = new Array(nbVNFC);
	var sccpFlavors = new Array(nbVNFC);
	var flavors = new Array(nbVNFC);
	var pointCodes = new Array(nbVNFC);
	var appBases = new Array(nbVNFC);
	var stacks = new Array(nbVNFC);
	var SSNs = new Array(nbVNFC);
	

	result += '\n# ------------------------------- #';
	result += '\n#  TCAP connectivity providers    #';
	result += '\n# ------------------------------- #';
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = TCAP.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			TCAP.check += "\nTCAP section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}

		var name=TCAP.getAndSetValue(row, nameIndexes, 'Provider name', 'TCAP-'+i);
		// Suggest default values tuned for the Messaging Framework application if this application is defined already, except if we are defining a Messaging Gateway reserved provider
		var isReservedMessagingGateway = (name == 'USSD-TCAP-Provider' || name == 'SMS-TCAP-Provider' || name == 'MS-TCAP-Provider');
		var isMessagingFrameworkDefined = MessagingFramework.search('Property', 'SERVICE_COMPONENT_NAME');
		var serviceName=TCAP.getAndSetValue(row, nameIndexes, 'Service name', isReservedMessagingGateway ? "$MESSAGING_GATEWAY_SERVICE_COMPONENT_NAME" : (isMessagingFrameworkDefined ? "$MESSAGING_FRAMEWORK_SERVICE_COMPONENT_NAME" : "TCAP-service-"+i), 'Service name');
		var instanceId=TCAP.getAndSetValue(row, nameIndexes, 'Instance Id');
		var appId=TCAP.getAndSetValue(row, nameIndexes, 'App Id', "1,2,3,4,5,6", "Application IDs");
		var flavor=TCAP.getAndSetValue(row, nameIndexes, 'Flavor', "ITU93", "Flavor");
		var sccpFlavor=TCAP.getAndSetValue(row, nameIndexes, 'SCCP flavor');
		var pointCode=TCAP.getAndSetValue(row, nameIndexes, 'Point code', isReservedMessagingGateway ? "$MSGGW_POINTCODE" : MessagingGatewayDefault.POINTCODE, "Point code");
		var appBase=TCAP.getAndSetValue(row, nameIndexes, 'App base', isMessagingFrameworkDefined && ! isReservedMessagingGateway ? "$MESSAGING_FRAMEWORK_APPLICATION_BASE" : "", "Application base");
		var stack=TCAP.getAndSetValue(row, nameIndexes, 'SS7 stack', "SS7_Stack_1", "Stack name");
		var SSN=TCAP.getAndSetValue(row, nameIndexes, 'SSN', "149", "SSN");
		
		if(name == ""){
			TCAP.check += "\nTCAP section: provider name cannot be blank";
			continue;
		}
		// Reserved names for Messaging Gateway: USSD-TCAP-Provider SMS-TCAP-Provider MS-TCAP-Provider
		// TODO: this test needs to be more accurate so that the tested Value is actually the one associated to the SERVICE_COMPONENT_NAME property
		TCAP.check += checkDependency(isReservedMessagingGateway, [ MessagingGateway.search('Property', 'SERVICE_COMPONENT_NAME') && MessagingGateway.search('Value', serviceName), serviceName == "$MESSAGING_GATEWAY_SERVICE_COMPONENT_NAME" ], 'Reserved provider name ', name + ' requires a Messaging Gateway application named ' + serviceName);
		
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			TCAP.check += "\nTCAP section: provider name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this TCAP resource definition
		var nameIndex = names[VNFCindex].length -1;

		if(serviceName != ""){
			if(serviceNames[VNFCindex] == undefined)serviceNames[VNFCindex] = new Array();
			serviceNames[VNFCindex][nameIndex]=serviceName;
		}
		if(instanceId != ""){
			TCAP.check+=checkSeeInstanceId(instanceId, "TCAP section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
		if(appId != ""){
			if(appIds[VNFCindex] == undefined)appIds[VNFCindex] = new Array();
			appIds[VNFCindex][nameIndex]=appId;
		}
		if(flavor != ""){
			if(flavors[VNFCindex] == undefined)flavors[VNFCindex] = new Array();
			flavors[VNFCindex][nameIndex]=flavor;
		}
		if(sccpFlavor != ""){
			if(sccpFlavors[VNFCindex] == undefined)sccpFlavors[VNFCindex] = new Array();
			sccpFlavors[VNFCindex][nameIndex]=sccpFlavor;
		}
		if(pointCode != ""){
			if(pointCodes[VNFCindex] == undefined)pointCodes[VNFCindex] = new Array();
			pointCodes[VNFCindex][nameIndex]=pointCode;
		}
		if(appBase != ""){
			if(appBases[VNFCindex] == undefined)appBases[VNFCindex] = new Array();
			appBases[VNFCindex][nameIndex]=appBase;
		}
		if(stack != ""){
			if(stacks[VNFCindex] == undefined)stacks[VNFCindex] = new Array();
			stacks[VNFCindex][nameIndex]=stack;
		}
		if(SSN != ""){
			if(SSNs[VNFCindex] == undefined)SSNs[VNFCindex] = new Array();
			SSNs[VNFCindex][nameIndex]=SSN;
		}
	}

	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(serviceNames[i]);
		fillArrays(instanceIds[i]);
		fillArrays(appIds[i]);
		fillArrays(sccpFlavors[i]);
		fillArrays(flavors[i]);
		fillArrays(pointCodes[i]);
		fillArrays(appBases[i]);
		fillArrays(stacks[i]);
		fillArrays(SSNs[i]);
		result += ifVNFCopen(e,i);
		result += "\nTCAP_PROVIDER_NAME=( "+names[i].join(" ")+" )";
		if(serviceNames[i] != undefined)result += "\nTCAP_SERVICE_COMPONENT_NAME=( "+serviceNames[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nTCAP_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(appIds[i] != undefined)result += "\nTCAP_APPLICATION_ID=( "+appIds[i].join(" ")+" )";
		if(flavors[i] != undefined)result += "\nTCAP_FLAVOR=( "+flavors[i].join(" ")+" )";
		if(sccpFlavors[i] != undefined)result += "\nTCAP_SCCP_FLAVOR=( "+sccpFlavors[i].join(" ")+" )";
		if(pointCodes[i] != undefined)result += "\nTCAP_POINT_CODE=( "+pointCodes[i].join(" ")+" )";
		if(appBases[i] != undefined)result += "\nTCAP_APPLICATION_BASE=( "+appBases[i].join(" ")+" )";
		if(stacks[i] != undefined)result += "\nTCAP_SS7STACK_NAME=( "+stacks[i].join(" ")+" )";
		if(SSNs[i] != undefined)result += "\nTCAP_SSN=( "+SSNs[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});
	if(TCAP.check != "")result = TCAP.check;
	
	return result;
}

// ===========================
// MRF adapter
// ===========================
var MrfAdapter = new vnfResource("MrfAdapter", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Type', type:'choice', width:'90px', choices:['MrfAdapter', 'mmcc']},
	{name:'Name', type:'text', width:'90px'},
	{name:'Transport', type:'choice', width:'50px', choices:['UDP', 'TCP', 'TLS', 'SCTP']},
	{name:'Instance Id', type:'text', width:'50px'}, 
	{name:'Address', type:'text', width:'200px'},
	{name:'Port', type:'text', width:'50px'}, 
	{name:'MRF URI', type:'text', width:'150px'},
	{name:'Provisioning', type:'text', width:'150px'}, 
	{name:'Redis instance', type:'text', width:'50px'},
	{name:'Redis password', type:'text', width:'50px'}, 
	{name:'Redis hosts&ports', type:'text', width:'200px'},
	{name:'Resource URL', type:'text', width:'150px'},
	{name:'Tenants', type:'text', width:'150px'}
	]
	);
	
MrfAdapter.help = function(){
	return "MRF Adapter resources"+
	"\nName: service component name" +
	"\nTransport: The transport type on which the API's SIP provider is bound. One of UDP, TCP, TLS, SCTP. Default value = UDP"+
	"\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this MRF adapter, one per SEE node, as a list of comma separated integers, defaulting to the first in the list"+
	"\nAddress: IP address to listen to, as a list of comma separated values, one per SEE node; dash (-) to not assign this SEE node, defaults to SIP if defined, or management network otherwise" +
	"\nPort: SIP port number to listen to, as a list of comma separated values, one per SEE node, defaults to the first entry in the list, or 5060 if undefined"+
	"\nMRF URI: (optional) the URI of the MRF associated with the service."+
	"\nProvisioning: (optional) MRF provisioning file, one per instance, default:"+
	"\n\tMrfAdapter: /etc/opt/OC/hpe-mrf-adapter/sip.config"+
	"\n\tmmcc: /etc/opt/OC/hpoc-mmcc/sip.config"+
	"\nRedis instance: name of the redis instance, mandatory if HA feature is enabled"+
	"\nRedis password: password required to access the redis instance; default $NIVRDB_LINUXHA_PASSWORD"+
	"\nRedis hosts&ports: list of Redis sentinel IP addresses and ports, minimum three sentinel IPs are mandatory. Each value is separated by the comma delimiter."+
	"\n\tSample value: node1.hp.com:27379,node2.hp.com:27379,node3.hp.com:27379"+
	"\nResource URL: baseUrl to be presented to the client: example: http://host.example.com:8080/<path to servlet>"+
	"\nTenants: array of tenant records containing a tenandId (String) and a userPart (String). Regular expressions may be used for userPart."+
	'\n\tExample: {"tenantId":"aaa","userPart":"\\+3304.*"},{"tenantId":"tenantA","userPart":"aaa.*"},{"tenantId":"tenantC","userPart":"service"}'+
	"\n\tThe purpose of the array is to assign a tenant role to an incoming call. If no match can be found the call is rejected."+
	"\n\tThe userPart .* (dot star) will match any incoming call and may be used to route the calls to a default tenantId.";
}

MrfAdapter.build = function(){
	var nameIndexes = MrfAdapter.nameIndexes;
	var currentVNFC = "";

	MrfAdapter.check = "";
	var result = "\n";
	var table = document.getElementById("MrfAdapter");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var types = new Array();
	var adresses = new Array();
	var instanceIds = new Array();
	var ports = new Array();
	var provisionings = new Array();
	var transports = new Array();
	var uris = new Array();
	var redisInstances = new Array();
	var redisPasswords = new Array();
	var redisHosts = new Array();
	var servlets = new Array();
	var tenants = new Array();
	
	result += "\n# ------------------------------- #";
	result += "\n# MRF adapters                    #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = MrfAdapter.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			MrfAdapter.check += "\nMrfAdapter section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";
		
		var type=MrfAdapter.getAndSetSelection(row, nameIndexes, 'Type', 0);
		var name=MrfAdapter.getAndSetValue(row, nameIndexes, 'Name', type+"-"+i);
		MrfAdapter.check += checkDependency(name == 'MrfAdDRFOCC', [ type == 'MrfAdapter' ], 'MrfAdapter section: MrfAdapter with reserved name MrfAdDRFOCC requires', ' a type MrfAdapter');
		var address=MrfAdapter.getAndSetValue(row, nameIndexes, 'Address');
		var port=MrfAdapter.getAndSetValue(row, nameIndexes, 'Port');
		var instanceId=MrfAdapter.getAndSetValue(row, nameIndexes, 'Instance Id');
		var provisioning=MrfAdapter.getAndSetValue(row, nameIndexes, 'Provisioning');
		var transport=MrfAdapter.getAndSetSelection(row, nameIndexes, 'Transport', 0);
		var uri=MrfAdapter.getAndSetValue(row, nameIndexes, 'MRF URI');
		var redisInstance=MrfAdapter.getAndSetValue(row, nameIndexes, 'Redis instance');
		var redisPassword=MrfAdapter.getAndSetValue(row, nameIndexes, 'Redis password', redisInstance != "" ? '$NIVRDB_LINUXHA_PASSWORD' : "" );
		var redisHost=MrfAdapter.getAndSetValue(row, nameIndexes, 'Redis hosts&ports', redisInstance != "" ? "node1.hp.com:27379,node2.hp.com:27379,node3.hp.com:27379" : "" );
		var servlet=MrfAdapter.getAndSetValue(row, nameIndexes, 'Resource URL');
		var tenant=MrfAdapter.getAndSetValue(row, nameIndexes, 'Tenants');
		if(tenant.indexOf("'") != -1)MrfAdapter.check += "MrfAdapter section: "+name+" Tenant definition "+tenant+" should not contain any single quote character, reserved for regular expression handling; see online help for examples.";
		MrfAdapter.check += checkGroupConsistency([redisInstance != '', redisPassword != '', redisHost != '' ], 'MrfAdapter section: '+name, ' requires Redis instance, password and hosts definition');
	
		if(name == ""){
			MrfAdapter.check += "\nMrfAdapter section: " + type + " name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			MrfAdapter.check += "\n"+type+" section: " + name + " service component name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this resource definition
		var nameIndex = names[VNFCindex].length -1;
		
		if(types[VNFCindex] == undefined)types[VNFCindex] = new Array();
		// Only one mmcc per SEE cluster due to SIP provider name hard coded 
		var firstMMCC = types[VNFCindex].indexOf('mmcc');
		MrfAdapter.check += checkDependency(type == 'mmcc', [ firstMMCC == -1 ], "MrfAdapter section: mmcc type duplicated on services "+ name + " and " + names[VNFCindex][firstMMCC], ". Only one mmcc service per VNFC is allowed.");
		types[VNFCindex][nameIndex]=type;
		
		if(address != ""){
			if(adresses[VNFCindex] == undefined)adresses[VNFCindex] = new Array();
			adresses[VNFCindex][nameIndex]=address;
		}
		if(port != ""){
			if(ports[VNFCindex] == undefined)ports[VNFCindex] = new Array();
			ports[VNFCindex][nameIndex]=port;
		}
		if(instanceId != ""){
			MrfAdapter.check+=checkSeeInstanceId(instanceId, type+" section: ");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}else instanceId = "1"; // default instance Id for conflict checking here below
		if(provisioning != ""){
			if(provisionings[VNFCindex] == undefined)provisionings[VNFCindex] = new Array();
			provisionings[VNFCindex][nameIndex]=provisioning;
		}
		if(transport != ""){
			if(transports[VNFCindex] == undefined)transports[VNFCindex] = new Array();
			transports[VNFCindex][nameIndex]=transport;
		}
		if(uri != ""){
			if(uris[VNFCindex] == undefined)uris[VNFCindex] = new Array();
			uris[VNFCindex][nameIndex]=uri;
		}
		if(redisInstance != ""){
			if(redisInstances[VNFCindex] == undefined)redisInstances[VNFCindex] = new Array();
			redisInstances[VNFCindex][nameIndex]=redisInstance;
		}
		if(redisPassword != ""){
			if(redisPasswords[VNFCindex] == undefined)redisPasswords[VNFCindex] = new Array();
			redisPasswords[VNFCindex][nameIndex]=redisPassword;
		}
		if(redisHost != ""){
			if(redisHosts[VNFCindex] == undefined)redisHosts[VNFCindex] = new Array();
			redisHosts[VNFCindex][nameIndex]=redisHost;
		}
		if(servlet != ""){
			if(servlets[VNFCindex] == undefined)servlets[VNFCindex] = new Array();
			servlets[VNFCindex][nameIndex]=servlet;
		}
		if(tenant != ""){
			if(tenants[VNFCindex] == undefined)tenants[VNFCindex] = new Array();
			tenants[VNFCindex][nameIndex]=tenant;
		}
		
		// MRF adapter is an application candidate to http load balancing: check conflict on instance ids with other candidates
		MrfAdapter.check += httpLbCheckAndGetSeeInstanceIds("MRF adapter", VNFCindex, instanceId);
	}
					
	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(adresses[i]);
		fillArrays(ports[i]);
		fillArrays(instanceIds[i]);
		fillArrays(provisionings[i]);
		fillArrays(transports[i]);
		fillArrays(uris[i]);
		fillArrays(redisInstances[i]);
		fillArrays(redisPasswords[i]);
		fillArrays(redisHosts[i]);
		fillArrays(servlets[i]);
		fillArrays(tenants[i]);
		result += ifVNFCopen(e,i);
		result += "\nMRF_ADAPTER_SERVICE_COMPONENT_NAME=( "+names[i].join(" ")+" )";
		result += "\nMRF_ADAPTER_SERVICE_COMPONENT_TYPE=( "+types[i].join(" ")+" )";
		if(adresses[i] != undefined)result += "\nMRF_ADAPTER_IP_ADDR=( "+adresses[i].join(" ")+" )";
		if(ports[i] != undefined)result += "\nMRF_ADAPTER_PORT=( "+ports[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nMRF_ADAPTER_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(provisionings[i] != undefined)result += "\nMRF_ADAPTER_PROVISIONING=( "+provisionings[i].join(" ")+" )";
		if(transports[i] != undefined)result += "\nMRF_ADAPTER_TRANSPORT=( "+transports[i].join(" ")+" )";
		if(uris[i] != undefined)result += "\nMRF_ADAPTER_MRF_URI=( "+uris[i].join(" ")+" )";
		if(redisInstances[i] != undefined)result += "\nMRF_ADAPTER_REDIS_NAME=( "+redisInstances[i].join(" ")+" )";
		if(redisPasswords[i] != undefined)result += "\nMRF_ADAPTER_REDIS_PASSWORD=( "+redisPasswords[i].join(" ")+" )";
		if(redisHosts[i] != undefined)result += "\nMRF_ADAPTER_REDIS_HOST_PORTS=( "+redisHosts[i].join(" ")+" )";
		if(servlets[i] != undefined)result += "\nMRF_ADAPTER_SERVLET_URL=( "+servlets[i].join(" ")+" )";
		// tenants requires simple quote to protect regular expressions 
		if(tenants[i] != undefined)result += "\nMRF_ADAPTER_TENANTS=( '"+tenants[i].join("' '")+"' )";	
		result += ifVNFCclose(e,i);
	});

	if(MrfAdapter.check != "")result = MrfAdapter.check;

	return result;
};
	
// ===========================
// Diameter
// ===========================
var Diameter = new vnfResource("Diameter", [
	{name:'VNFC', type:'text'}, 
	{name:'Name', type:'text'},
	{name:'Type', type:'choice', width:'60px', choices:['RO', 'SH', 'RF', 'NAF', 'TpReg', 'BSF', 'XDM', 'MMTel']},
	{name:'Instance Id', type:'text', width:'60px'},
	{name:'Transp.', type:'choice', width:'60px', choices:['tcp', 'sctp']},
	{name:'Servers addresses', type:'text', width:'120px'},
	{name:'Servers Ports', type:'text', width:'120px'},
	{name:'Servers Realms', type:'text', width:'120px'},
	{name:'Remote addresses', type:'text', width:'120px'},
	{name:'Remote ports', type:'text', width:'120px'},
	{name:'Remote realms', type:'text', width:'120px'},
	{name:'Priority', type:'text', width:'60px', value:'1'}
	]
	);
	
Diameter.help = function(){
	return "Diameter providers"+
	"\nName: service component name; MrfAdDRFOCC is required and reserved for Diameter RF provider type" +
	"\nType: provider type: RO SH RF; up to 2 different RO/SH providers can be instantiated on the same service to offer one RO_SH service"+
	"\n\tTASAPPs types (experimental): NAF TpReg BSF XDM MMTel require the TASAPPs ISO image in /var/opt/OC/iso"+
	"\nInstanceId: SEE instances on which this resource has to be deployed, as a list of comma separated IDs, one per SEE node, default to 1" +
	"\nServers: Diameter providers" +
	"\n\tAddresses: list of comma separated listening IP addresses or hostnames, one per SEE node; default to the SEE node FQDN, dash '-' to *NOT* instantiate on this node" +
	"\n\tPorts: list of comma separated Diameter listening ports, one per SEE node; default to 3870" +
	"\n\tRealms: list of comma separated Diameter server realms, one per SEE node; default to the local domain name" +
	"\nRemote: Diameter routes: list of comma separated remote IP addresses or hostnames, ports and realms: one route added per entry"
	;
}

Diameter.build = function(){
	var nameIndexes = Diameter.nameIndexes;
	var currentVNFC = "";

	Diameter.check = "";
	var result = "\n";
	var table = document.getElementById("Diameter");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array(nbVNFC);
	var instanceIds = new Array(nbVNFC);
	var types = new Array(nbVNFC);
	var transports = new Array(nbVNFC);
	var addressServers = new Array(nbVNFC);
	var portServers = new Array(nbVNFC);
	var realmServers = new Array(nbVNFC);
	var addressClients = new Array(nbVNFC);
	var portClients = new Array(nbVNFC);
	var realmClients = new Array(nbVNFC);
	var priorities = new Array(nbVNFC);
		
	result += "\n# ------------------------------- #";
	result += "\n# Diameter     providers          #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = Diameter.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			Diameter.check += "\nDiameter section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		
		var type=Diameter.getAndSetSelection(row, nameIndexes, 'Type');
		var defaultName='diameter-'+type+'-'+i;
		var defaultPort='23000';
		// MrfAdapter for Diameter: required name for the provider
		if(type == 'RF')defaultName='MrfAdDRFOCC';
		var name=Diameter.getAndSetValue(row, nameIndexes, 'Name', defaultName);
		Diameter.check += checkGroupConsistency([type == 'RF', name == 'MrfAdDRFOCC' ], 'Diameter RF type requires to be named', ' MrfAdDRFOCC; this name should not be used out of Diameter RF');
		Diameter.check += checkDependency(type == 'RF', [ MrfAdapter.search('Name', 'MrfAdDRFOCC') ], 'Diameter RF type requires', ' an MrfAdapter named MrfAdDRFOCC');
		var instanceId=Diameter.getAndSetValue(row, nameIndexes, 'Instance Id');
		var transport=Diameter.getAndSetSelection(row, nameIndexes, 'Transp.');
		var addressServer=Diameter.getAndSetValue(row, nameIndexes, 'Servers addresses');
		var portServer=Diameter.getAndSetValue(row, nameIndexes, 'Servers Ports', addressServer != "" ? defaultPort : "");
		var realmServer=Diameter.getAndSetValue(row, nameIndexes, 'Servers Realms');
		var addressClient=Diameter.getAndSetValue(row, nameIndexes, 'Remote addresses');
		var portClient=Diameter.getAndSetValue(row, nameIndexes, 'Remote ports', addressClient != "" ? defaultPort : "");
		var realmClient=Diameter.getAndSetValue(row, nameIndexes, 'Remote realms');
		var priority = Diameter.getAndSetValue(row, nameIndexes, 'Priority');

		if(name == ""){
			Diameter.check += "\nDiameter section: " + type + " provider name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		// realm and port are mandatory
		Diameter.check += checkGroupConsistency([addressClient != "", portClient != "", realmClient != ""], "Diameter section: "+name, " remote definition is inconsistent (all of address/port/realm or none should be defined)");
		Diameter.check += checkGroupConsistency([addressServer != "", portServer != "", realmServer != ""], "Diameter section: "+name, " server definition is inconsistent (all of address/port/realm or none should be defined)");
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this Diameter resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(instanceId != ""){
			Diameter.check+=checkSeeInstanceId(instanceId, "Diameter section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
		if(transports[VNFCindex] == undefined)transports[VNFCindex] = new Array();
		transports[VNFCindex][nameIndex]=transport;
		if(types[VNFCindex] == undefined)types[VNFCindex] = new Array();
		types[VNFCindex][nameIndex]=type;
		if(addressServer != ""){
			if(addressServers[VNFCindex] == undefined)addressServers[VNFCindex] = new Array();
			addressServers[VNFCindex][nameIndex]=addressServer;
		}
		if(portServer != ""){
			if(portServers[VNFCindex] == undefined)portServers[VNFCindex] = new Array();
			portServers[VNFCindex][nameIndex]=portServer;
		}
		if(realmServer != ""){
			if(realmServers[VNFCindex] == undefined)realmServers[VNFCindex] = new Array();
			realmServers[VNFCindex][nameIndex]=realmServer;
		}
		if(addressClient != ""){
			if(addressClients[VNFCindex] == undefined)addressClients[VNFCindex] = new Array();
			addressClients[VNFCindex][nameIndex]=addressClient;
		}
		if(portClient != ""){
			if(portClients[VNFCindex] == undefined)portClients[VNFCindex] = new Array();
			portClients[VNFCindex][nameIndex]=portClient;
		}
		if(realmClient != ""){
			if(realmClients[VNFCindex] == undefined)realmClients[VNFCindex] = new Array();
			realmClients[VNFCindex][nameIndex]=realmClient;
		}
		if(priority){
			if(priorities[VNFCindex] == undefined)priorities[VNFCindex] = new Array();
			priorities[VNFCindex][nameIndex]=priority;
		}
	}
					
	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(instanceIds[i]);
		fillArrays(transports[i]);
		fillArrays(addressServers[i]);
		fillArrays(portServers[i]);
		fillArrays(realmServers[i]);
		fillArrays(addressClients[i]);
		fillArrays(portClients[i]);
		fillArrays(realmClients[i]);
		fillArrays(priorities[i]);
		result += ifVNFCopen(e,i);
		result += "\nDIAMETER_SERVICE_COMPONENT_NAME=( "+names[i].join(" ")+" )";
		if(types[i] != undefined)result += "\nDIAMETER_PROVIDER_TYPE=( "+types[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nDIAMETER_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(transports[i] != undefined)result += "\nDIAMETER_TRANSPORT=( "+transports[i].join(" ")+" )";
		if(addressServers[i] != undefined)result += "\nDIAMETER_APPLICATION_SERVER_NAME=( "+addressServers[i].join(" ")+" )";
		if(portServers[i] != undefined)result += "\nDIAMETER_LISTENER_PORT=( "+portServers[i].join(" ")+" )";
		if(realmServers[i] != undefined)result += "\nDIAMETER_LISTENER_REALM=( "+realmServers[i].join(" ")+" )";
		if(addressClients[i] != undefined)result += "\nDIAMETER_REMOTE_NODE=( "+addressClients[i].join(" ")+" )";
		if(realmClients[i] != undefined)result += "\nDIAMETER_REMOTE_REALM=( "+realmClients[i].join(" ")+" )";
		if(portClients[i] != undefined)result += "\nDIAMETER_REMOTE_PORT=( "+portClients[i].join(" ")+" )";
		if(priorities[i] != undefined)result += "\nDIAMETER_PRIORITY=( "+priorities[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});
	
	if(Diameter.check != "")result = Diameter.check;

	return result;
}

// ===========================
// UCP SMPP
// ===========================
var UcpSmpp = new vnfResource("UcpSmpp", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Type', type:'choice', width:'90px', choices:['UCP', 'SMPP']},
	{name:'Name', type:'text', width:'90px'},
	{name:'Address', type:'text', width:'200px'},
	{name:'Port', type:'text', width:'90px'}
	]
	);
	
UcpSmpp.help = function(){
	return "UCP and SMPP resources"+
	"\nName: provider's name" +
	"\nAddress: selected network CIDR to listen to, eg 192.168.69.0/24; default to any interface 0.0.0.0" +
	"\nPort: the port to listen to (no default)";
}

UcpSmpp.build = function(){
	var nameIndexes = UcpSmpp.nameIndexes;
	var currentVNFC = "";

	UcpSmpp.check = "";
	var result = "\n";
	var table = document.getElementById("UcpSmpp");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var adresses = new Array();
	var ports = new Array();
	names['UCP'] = new Array(nbVNFC);
	adresses['UCP'] = new Array(nbVNFC);
	ports['UCP'] = new Array(nbVNFC);
	names['SMPP'] = new Array(nbVNFC);
	adresses['SMPP'] = new Array(nbVNFC);
	ports['SMPP'] = new Array(nbVNFC);

	result += "\n# ------------------------------- #";
	result += "\n# Ucp and Smpp providers          #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = UcpSmpp.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			UcpSmpp.check += "\nUcp/Smpp section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		
		var type=UcpSmpp.getAndSetSelection(row, nameIndexes, 'Type', 0);
		var name=UcpSmpp.getAndSetValue(row, nameIndexes, 'Name', type+'-'+i);
		var address=UcpSmpp.getAndSetValue(row, nameIndexes, 'Address', '0.0.0.0');
		var port=UcpSmpp.getAndSetValue(row, nameIndexes, 'Port', '7800');
		if(name == "" || port == ""){
			UcpSmpp.check += "\n" + type + " provider name and port cannot be blank";
			continue;
		}
		if(names[type][VNFCindex] == undefined)names[type][VNFCindex] = new Array();
		if(names[type][VNFCindex].indexOf(name) != -1){
			UcpSmpp.check += "\n"+type+" section: " + name + " provider name is duplicated";
			continue;
		}
		names[type][VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this resource definition
		var nameIndex = names[type][VNFCindex].length -1;

		if(address != ""){
			if(adresses[type][VNFCindex] == undefined)adresses[type][VNFCindex] = new Array();
			adresses[type][VNFCindex][nameIndex]=address;
		}
		if(port != ""){
			if(ports[type][VNFCindex] == undefined)ports[type][VNFCindex] = new Array();
			ports[type][VNFCindex][nameIndex]=port;
		}
	}
					
	VNFCnames.forEach(function(e,i){
		['UCP', 'SMPP'].forEach(function(type,iType){
			if(names[type][i] == undefined || names[type][i].length == 0)return;
			fillArrays(adresses[type][i]);
			fillArrays(ports[type][i]);
			result += ifVNFCopen(e,i);
			result += "\n"+type+"_PROVIDER_NAME=( "+names[type][i].join(" ")+" )";
			if(adresses[type][i] != undefined)result += "\n"+type+"_IP_ADDR=( "+adresses[type][i].join(" ")+" )";
			if(ports[type][i] != undefined)result += "\n"+type+"_PORT=( "+ports[type][i].join(" ")+" )";
			result += ifVNFCclose(e,i);
		});
	});

	if(UcpSmpp.check != "")result = UcpSmpp.check;

	return result;
};

// =============================
// SMPP session
// =============================
var SMPPsession = new vnfResource("SMPPsession", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Service', type:'text', width:'90px'},
	{name:'Instance Id', type:'text', width:'60px'},
	{name:'Provider', type:'text', width:'90px'},
	{name:'Connector', type:'text', width:'90px'},
	{name:'Host', type:'text', width:'90px'},
	{name:'Port', type:'text', width:'90px'}, 
	{name:'System Id', type:'text', width:'90px'},
	{name:'Password', type:'text', width:'90px'},
	{name:'BindMode', type:'choice', width:'90px', choices:['Transmitter', 'Receiver', 'Transceiver']},
	{name:'SystemType', type:'text', width:'90px'},
	{name:'Interface', type:'text', width:'90px'},
	{name:'ConnTimeout', type:'text', width:'90px'},
	{name:'BindTimeout', type:'text', width:'90px'},
	{name:'WaitTimeout', type:'text', width:'90px'},
	{name:'MonitorInt', type:'text', width:'90px'},
	{name:'Use SSL', type:'choice', width:'90px', choices:['true', 'false']}
	]
	);
	
SMPPsession.help = function(){
	return "SMPP sessions: Messaging Sessions are configured within SMPP connector."+
	"\n\tIt is used to collect all session related information."+
	"\n\tEach messaging session will be created corresponding to each SMPP provider."+
	"\nName: Name of the SMPP session" +
	"\nService: Name of the SEE service hosting this session (one SEE service can host multiple sessions)" +
	"\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this session, one per SEE node, as a list of comma separated integers, defaulting to the first in the list"+
	"\nProvider: the name of the service provider created on the service"+
	"\nConnector: the name of the SMPP connector created on the service"+
	"\nHost and port: the remote host name or IP address and port for this session"+
	"\nSystem Id and password: credentials used to control the bind procedure at the SMSC level"+
	"\nBindMode: "+
	"\n\tTransmitter authorized to send short messages to the SMSC and to receive the corresponding SMPP responses from the SMSC."+
	"\n\tReceiver authorized to receive short messages from the SMSC and to return the corresponding SMPP message responses to the SMSC."+
	"\n\tTransceiver allowed to send messages to the SMSC and receive messages from the SMSC over a single SMPP session."+
	"\nSystemType: "+
	"\nInterface: SMPP specification version; Default value 3.4"+
	"\nBind timeout: DefaultValue=5000"+
	"\nConnection timeout: Connection to smsc will be expired after this interval; DefaultValue=10000"+
	"\nWait timeout: DefaultValue=60000"+
	"\nMonitor interval: "+
	"\nUse SSL: true to enhance security; default false";
}

SMPPsession.build = function(){
	var nameIndexes = SMPPsession.nameIndexes;
	var currentVNFC = "";

	SMPPsession.check = "";
	var result = "\n";
	var table = document.getElementById("SMPPsession");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	// Bind modes encoding
	var bindModeValues = new Array();
	bindModeValues['Transmitter'] = 't';
	bindModeValues['Receiver'] = 'r';
	bindModeValues['Transceiver'] = 'tr';
	
	var names = new Array(nbVNFC);
	var services = new Array(nbVNFC);
	var instanceIds = new Array(nbVNFC);
	var providers = new Array(nbVNFC);
	var connectors = new Array(nbVNFC);
	var hosts = new Array(nbVNFC);
	var ports = new Array(nbVNFC);
	var systemIds = new Array(nbVNFC);
	var passwords = new Array(nbVNFC);
	var bindModes = new Array(nbVNFC);
	var systemTypes = new Array(nbVNFC);
	var interfaces = new Array(nbVNFC);
	var connectionTOs = new Array(nbVNFC);
	var bindTOs = new Array(nbVNFC);
	var waitTOs = new Array(nbVNFC);
	var monitorIntervals = new Array(nbVNFC);
	var useSSLs = new Array(nbVNFC);
		
	result += "\n# ------------------------------- #";
	result += "\n# SMPP sessions                   #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SMPPsession.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SMPPsession.check += "\nSMPPsession section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
				
		var name=SMPPsession.getAndSetValue(row, nameIndexes, 'Name', 'smpp-'+i);
		var service=SMPPsession.getAndSetValue(row, nameIndexes, 'Service', 'smpp-'+i);
		var instanceId=SMPPsession.getAndSetValue(row, nameIndexes, 'Instance Id');
		var provider=SMPPsession.getAndSetValue(row, nameIndexes, 'Provider', 'smpp-'+i);
		var connector=SMPPsession.getAndSetValue(row, nameIndexes, 'Connector', 'smpp-'+i);
		var host=SMPPsession.getAndSetValue(row, nameIndexes, 'Host', 'smpp.host'+i);
		var port=SMPPsession.getAndSetValue(row, nameIndexes, 'Port', '34567');
		var systemId=SMPPsession.getAndSetValue(row, nameIndexes, 'System Id', 'smpp-'+i);
		var password=SMPPsession.getAndSetValue(row, nameIndexes, 'Password', 'password');
		var bindMode=bindModeValues[SMPPsession.getAndSetSelection(row, nameIndexes, 'BindMode')];
		var systemType=SMPPsession.getAndSetValue(row, nameIndexes, 'SystemType');
		var interface=SMPPsession.getAndSetValue(row, nameIndexes, 'Interface');
		var connectionTO=SMPPsession.getAndSetValue(row, nameIndexes, 'ConnTimeout');
		var bindTO=SMPPsession.getAndSetValue(row, nameIndexes, 'BindTimeout');
		var waitTO=SMPPsession.getAndSetValue(row, nameIndexes, 'WaitTimeout');
		var monitorInterval=SMPPsession.getAndSetValue(row, nameIndexes, 'MonitorInt');
		var useSSL=SMPPsession.getAndSetSelection(row, nameIndexes, 'Use SSL');
		
	
		if(name == "")		{SMPPsession.check += "\nSMPPsession section: session name cannot be blank"; continue;}
		if(service == "")	{SMPPsession.check += "\nSMPPsession section: service name cannot be blank";continue;}
		if(provider == "")	{SMPPsession.check += "\nSMPPsession section: provider name cannot be blank";continue;}
		if(connector == "")	{SMPPsession.check += "\nSMPPsession section: connector name cannot be blank";continue;}
		if(host == "")		{SMPPsession.check += "\nSMPPsession section: host name cannot be blank";continue;}
		if(port == "")		{SMPPsession.check += "\nSMPPsession section: port name cannot be blank";continue;}
		if(systemId == "")	{SMPPsession.check += "\nSMPPsession section: systemId name cannot be blank";continue;}
		if(password == "")	{SMPPsession.check += "\nSMPPsession section: password name cannot be blank";continue;}
		if(bindMode == "")	{SMPPsession.check += "\nSMPPsession section: bindMode name cannot be blank";continue;}
		
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SMPPsession.check += "\nSMPPsession section: " + name + " session name is duplicated";
			continue;
		}
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this SMPPsession resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(services[VNFCindex] == undefined)services[VNFCindex] = new Array();
		services[VNFCindex][nameIndex]=service;
		if(instanceId != ""){
			SMPPsession.check+=checkSeeInstanceId(instanceId, "SMPPsession section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
		if(providers[VNFCindex] == undefined)providers[VNFCindex] = new Array();
		providers[VNFCindex][nameIndex]=provider;
		if(connectors[VNFCindex] == undefined)connectors[VNFCindex] = new Array();
		connectors[VNFCindex][nameIndex]=connector;
		if(hosts[VNFCindex] == undefined)hosts[VNFCindex] = new Array();
		hosts[VNFCindex][nameIndex]=host;
		if(ports[VNFCindex] == undefined)ports[VNFCindex] = new Array();
		ports[VNFCindex][nameIndex]=port;
		if(systemIds[VNFCindex] == undefined)systemIds[VNFCindex] = new Array();
		systemIds[VNFCindex][nameIndex]=systemId;
		if(passwords[VNFCindex] == undefined)passwords[VNFCindex] = new Array();
		passwords[VNFCindex][nameIndex]=password;
		if(bindModes[VNFCindex] == undefined)bindModes[VNFCindex] = new Array();
		bindModes[VNFCindex][nameIndex]=bindMode;
		if(systemType != ""){
		if(systemTypes[VNFCindex] == undefined)systemTypes[VNFCindex] = new Array();
		systemTypes[VNFCindex][nameIndex]=systemType;
		}
		if(interface != ""){
		if(interfaces[VNFCindex] == undefined)interfaces[VNFCindex] = new Array();
		interfaces[VNFCindex][nameIndex]=interface;
		}
		if(connectionTO != ""){
		if(connectionTOs[VNFCindex] == undefined)connectionTOs[VNFCindex] = new Array();
		connectionTOs[VNFCindex][nameIndex]=connectionTO;
		}
		if(bindTO != ""){
		if(bindTOs[VNFCindex] == undefined)bindTOs[VNFCindex] = new Array();
		bindTOs[VNFCindex][nameIndex]=bindTO;
		}
		if(waitTO != ""){
		if(waitTOs[VNFCindex] == undefined)waitTOs[VNFCindex] = new Array();
		waitTOs[VNFCindex][nameIndex]=waitTO;
		}
		if(monitorInterval != ""){
		if(monitorIntervals[VNFCindex] == undefined)monitorIntervals[VNFCindex] = new Array();
		monitorIntervals[VNFCindex][nameIndex]=monitorInterval;
		}
		if(useSSL != ""){
		if(useSSLs[VNFCindex] == undefined)useSSLs[VNFCindex] = new Array();
		useSSLs[VNFCindex][nameIndex]=useSSL;
		}
	}
	
	// Make the SMPP providers and connectors available, useful for SMPP profiles and pairs consistency checks
	SMPPsession.providers = providers.slice();
	SMPPsession.connectors = connectors.slice();
	
	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(services[i]);
		fillArrays(instanceIds[i]);
		fillArrays(providers[i]);
		fillArrays(connectors[i]);
		fillArrays(hosts[i]);
		fillArrays(ports[i]);
		fillArrays(systemIds[i]);
		fillArrays(passwords[i]);
		fillArrays(bindModes[i]);
		fillArrays(systemTypes[i]);
		fillArrays(interfaces[i]);
		fillArrays(connectionTOs[i]);
		fillArrays(bindTOs[i]);
		fillArrays(waitTOs[i]);
		fillArrays(monitorIntervals[i]);
		fillArrays(useSSLs[i]);
		result += ifVNFCopen(e,i);
		result += "\nSMPP_SESSION=( "+names[i].join(" ")+" )";
		if(services[i] != undefined)result += "\nSMPP_SESSION_SERVICE_COMPONENT_NAME=( "+services[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nSMPP_SESSION_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(providers[i] != undefined)result += "\nSMPP_SESSION_PROVIDER_NAME=( "+providers[i].join(" ")+" )";
		if(connectors[i] != undefined)result += "\nSMPP_SESSION_CONNECTOR_NAME=( "+connectors[i].join(" ")+" )";
		if(hosts[i] != undefined)result += "\nSMPP_SESSION_HOST=( "+hosts[i].join(" ")+" )";
		if(ports[i] != undefined)result += "\nSMPP_SESSION_PORT=( "+ports[i].join(" ")+" )";
		if(systemIds[i] != undefined)result += "\nSMPP_SESSION_SYSTEM_ID=( "+systemIds[i].join(" ")+" )";
		if(passwords[i] != undefined)result += "\nSMPP_SESSION_PASSWORD=( "+passwords[i].join(" ")+" )";
		if(bindModes[i] != undefined)result += "\nSMPP_SESSION_BIND_MODE=( "+bindModes[i].join(" ")+" )";
		if(systemTypes[i] != undefined)result += "\nSMPP_SESSION_SYSTEM_TYPE=( "+systemTypes[i].join(" ")+" )";
		if(interfaces[i] != undefined)result += "\nSMPP_SESSION_INTERFACE_VERSION=( "+interfaces[i].join(" ")+" )";
		if(connectionTOs[i] != undefined)result += "\nSMPP_SESSION_CONNNECTION_TIMEOUT=( "+connectionTOs[i].join(" ")+" )";
		if(bindTOs[i] != undefined)result += "\nSMPP_SESSION_BIND_TIMEOUT=( "+bindTOs[i].join(" ")+" )";
		if(waitTOs[i] != undefined)result += "\nSMPP_SESSION_WAIT_TIMEOUT=( "+waitTOs[i].join(" ")+" )";
		if(monitorIntervals[i] != undefined)result += "\nSMPP_SESSION_MONITOR_INTERVAL=( "+monitorIntervals[i].join(" ")+" )";
		if(useSSLs[i] != undefined)result += "\nSMPP_SESSION_USE_SSL=( "+useSSLs[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(SMPPsession.check != "")result = SMPPsession.check;

	return result;
}

// =============================
// SMPP profile
// =============================
var SMPPprofile = new vnfResource("SMPPprofile", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Connector', type:'text', width:'100px'},
	{name:'Profile Id', type:'text', width:'60px'},
	{name:'Dest Add', type:'text', width:'90px'},
	{name:'Encoding', type:'text', width:'60px'},
	{name:'Data coding', type:'text', width:'60px'},
	{name:'ESM class', type:'text', width:'60px'},
	{name:'Protocol Id', type:'text', width:'60px'}, 
	{name:'Timeout', type:'text', width:'60px'},
	{name:'Source Add', type:'text', width:'90px'},
	{name:'Source TON', type:'choice', width:'90px', choices:['Unknown', 'International', 'National', 'Network Specific', 'Subscriber number', 'Alphanumeric', 'Abbreviated']},
	{name:'NPI', type:'choice', width:'90px', choices:['Unknown', 'ISDN', 'Data', 'Telex', 'Land Mobile', 'National', 'Private', 'ERMES', 'Internet', 'WAP']},
	{name:'Dest TON', type:'choice', width:'90px', choices:['Unknown', 'International', 'National', 'Network Specific', 'Subscriber number', 'Alphanumeric', 'Abbreviated']},
	{name:'Service type', type:'choice', width:'90px', choices:['', 'CMT', 'CPT', 'VMN', 'VMA', 'WAP', 'USSD']},
	{name:'Priority', type:'choice', width:'90px', choices:['Normal', 'Interactive', 'Urgent', 'Emergency']},
	{name:'Delivery', type:'choice', width:'90px', choices:['None', 'Always', 'Failure']},
	{name:'Response policy', type:'choice', width:'90px', choices:['After', 'Before']},
	{name:'Balancing policy', type:'bool'},
	{name:'Validity period', type:'text', width:'90px'},
	{name:'URL', type:'text', width:'130px'}
	]
	);
	
SMPPprofile.help = function(){
	return "SMPP profiles: The SMPP Profile is used to configure the settings to use when sending an SMPP message."+
	"\n\tIt defines the parameters for the payload data sending and the load-balancing settings."+
	"\n\tAn SMPP Profile is attached to an HPE MSE SEE SMPP Messaging Connector."+
	"\nName: Name of the SMPP profile" +
	"\nConnector: SMPP connector to connect to this profile" +
	"\nProfile Id: Profile Id identifying the profile to be used as the default profile"+
	"\nDest Add: Specifies the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS."+
	"\n\tNOTE: An IP address is specified in the aaa.bbb.ccc.ddd notation. IP version 6.0 is not supported in V3.4 of the SMPP protocol."+
	"\n\tThis is overridden if specified by the VXML script"+
	"\nEncoding: Java Character encoding applied to the messages payload; possible values:"+
	"\n\tGSM 7-bit unpacked, Ascii, Cp 1252, Windows Latin=1, ISO 8859-1, Latin alphabet No. 1, 16-bit Unicode, big-endian, byte-order mark, 16-bit Unicode, big-endian, unmarked"+
	"\n\t16-bit Unicode, little-endian, byte-order, mark, 16-bit Unicode, little-endian, unmarked, 8-bit Unicode, 16-bit Unicode, initial byte order mark."+
	"\nData coding: Defines the encoding scheme of the short message user data: Refer to SMPP 3.4 standard, section 5.2.19."+
	"\nESM class: indicates the Message Mode and the Message Type; it is used to indicate special message attributes associated with the short message. "+
	"\n\tRefer to SMPP 3.4, section 5.2.12."+
	"\nProtocol Id: Protocol Identifier.Network specific field. GSM: set according to GSM 03.40"+
	"\n\tANSI-136 (TDMA): for mobile terminated messages, this field is not used and is, thus, ignored by the SMSC. For ANSI-136 mobile originated messages, the SMSC must set this value to NULL."+
	"\n\tIS-95 (CDMA): for mobile terminated messages, this field is not used and is, thus, ignored by the SMSC. For IS-95 mobile originated messages, the SMSC must set this value to NULL."+
	"\nTimeout: specifies the time lapse allowed between an SMPP request and the corresponding SMPP response. (0 = unlimited)"+
	"\nSource Add: Specifies the address of SME that originated this message."+
	"\n\tAn ESME implemented as a single SME address, can set this field to NULL to allow the SMSC to default the source address of the submitted message."+
	"\n\tNOTE: An IP address is specified in the aaa.bbb.ccc.ddd notation. IP version 6.0 is not supported in V3.4 of the SMPP protocol."+
	"\n\tThis is overridden if specified by the VXML script."+
	"\nSource ton: source Type of Number (TON)"+
	"\nNPI: Numbering Plan Indicator: Connection to smsc will be expired after this interval; DefaultValue=10000"+
	"\nDest TON: destination Type of Number (TON)"+
	"\nService type: used to indicate the SMS Application service associated with the message: "+
	"\n\t(NULL) Default CMT Cellular Messaging CPT Cellular Paging VMN Voice Mail Notification VMA Voice Mail Alerting"+
	"\n\tWAP Wireless Application Protocol USSD Unstructured Supplementary Services Data"+
	"\nPriority: Levels supported:0 (lowest) to 3 (highest)."+
	"\nDelivery: SMSC Delivery Receipt: Indicator to signify if an SMSC delivery receipt is required."+
	"\nResponse policy: It indicates if the response must be sent back before dispatching to the client or after dispatching to the client."+
	"\nBalancing policy: indicates if the SMS-C Load-balancing Weighted round-robin policy must be applied."+
	"\nValidity period: Scheduled delivery times and expiry times are specified in their global UTC format, including the quarter hour offset and direction symbol 'p':'+' or '-'. "+
	"\n\tRelative Time can be indicated by setting the UTC orientation flag to 'R' instead of '+' or '-'. "+
	"\n\tPossible values"+
	"\n\tnull = SMSC default"+
	"\n\tYYMMDDhhmmsstnnp"+
	"\n\tExample: 7 days would be 000007000000000R"+
	"\nURL: the SMPP profile URL; example: http://127.0.0.1:8080/contextRootName";
}

SMPPprofile.build = function(){
	var nameIndexes = SMPPprofile.nameIndexes;
	var currentVNFC = "";

	SMPPprofile.check = "";
	var result = "\n";
	var table = document.getElementById("SMPPprofile");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	// Reference: https://docs.aerialink.net/api/smpp/ton-npi-settings/
	// Encoding types of numbers
	var tonValues = new Array();
	tonValues['']='';
	tonValues['Unknown']='TON_UNKNOWN';
	tonValues['International']='TON_INTERNATIONAL';
	tonValues['National']='TON_NATIONAL';
	tonValues['Network Specific']='TON_NETWORK_SPECIFIC';
	tonValues['Subscriber number']='TON_SUBSCRIBER_NUMBER';
	tonValues['Alphanumeric']='TON_ALPHANUMERIC';
	tonValues['Abbreviated']='TON_ABBREVIATED';
	// Encoding numbering plan identifications
	var npiValues = new Array();
	npiValues['']='';
	npiValues['Unknown']='NPI_UNKNOWN';
	npiValues['ISDN']='NPI_E164';
	npiValues['Data']='NPI_DATA';
	npiValues['Telex']='NPI_TELEX';
	npiValues['Land Mobile']='NPI_LAND_MOBILE';
	npiValues['National']='NPI_NATIONAL';
	npiValues['Private']='NPI_PRIVATE';
	npiValues['ERMES']='NPI_ERMES';
	npiValues['Internet']='NPI_INTERNET';
	npiValues['WAP']='NPI_WAP';
	// Encoding priorities
	var priorityValues = new Array();
	priorityValues['Normal'] = 'PRIORITY_NORMAL';
	priorityValues['Interactive'] = 'PRIORITY_NON';
	priorityValues['Urgent'] = 'PRIORITY_URGENT';
	priorityValues['Emergency'] = 'PRIORITY_VERY_URGENT';
	// Encoding of deliveries
	var deliveryValues = new Array();
	deliveryValues['None'] = 'REGISTERED_DELIVERY_NONE';
	deliveryValues['Always'] = 'REGISTERED_DELIVERY_ALWAYS';
	deliveryValues['Failure'] = 'REGISTERED_DELIVERY_FAILURE';
	// Encoding reponse policies
	var responseValues = new Array();
	responseValues['After'] = 'SEND_RESP_AFTER_EVENT_DISPATCH';
	responseValues['Before'] = 'SEND_RESP_BEFORE_EVENT_DISPATCH';
	
	
	var names = new Array(nbVNFC);
	var connectors = new Array(nbVNFC);
	var ids= new Array(nbVNFC);
	var destAddrs= new Array(nbVNFC);
	var encodings= new Array(nbVNFC);
	var dataCodings= new Array(nbVNFC);
	var esmClasses= new Array(nbVNFC);
	var protocolIds= new Array(nbVNFC);
	var timeouts= new Array(nbVNFC);
	var sourceAddrs= new Array(nbVNFC);
	var sourceTons= new Array(nbVNFC);
	var npis= new Array(nbVNFC);
	var destTons= new Array(nbVNFC);
	var serviceTypes= new Array(nbVNFC);
	var priorities= new Array(nbVNFC);
	var deliveries= new Array(nbVNFC);
	var responsePolicies= new Array(nbVNFC);
	var balancingPolicies= new Array(nbVNFC);
	var validityPeriods= new Array(nbVNFC);
	var urls= new Array(nbVNFC);
		
	result += "\n# ------------------------------- #";
	result += "\n# SMPP profiles                   #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SMPPprofile.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SMPPprofile.check += "\nSMPPprofile section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";
				
		var defaultConnector='smpp-'+i;
		if(SMPPsession.connectors != undefined && SMPPsession.connectors[VNFCindex] != undefined && SMPPsession.connectors[VNFCindex].length > 0)defaultConnector=SMPPsession.connectors[VNFCindex][0]
		
		var name=SMPPprofile.getAndSetValue(row, nameIndexes, 'Name', 'smpp-'+i);
		var connector=SMPPprofile.getAndSetValue(row, nameIndexes, 'Connector', defaultConnector);
		var id=SMPPprofile.getAndSetValue(row, nameIndexes, 'Profile Id', 'smpp'+i);
		var destAddr=SMPPprofile.getAndSetValue(row, nameIndexes, 'Dest Add', '0476145888'+i);
		var encoding=SMPPprofile.getAndSetValue(row, nameIndexes, 'Encoding', 'ASCII');
		var dataCoding=SMPPprofile.getAndSetValue(row, nameIndexes, 'Data coding', '0');
		var esmClass=SMPPprofile.getAndSetValue(row, nameIndexes, 'ESM class', '0');
		var protocolId=SMPPprofile.getAndSetValue(row, nameIndexes, 'Protocol Id', '0');
		var timeout=SMPPprofile.getAndSetValue(row, nameIndexes, 'Timeout', '0');
		var sourceAddr=SMPPprofile.getAndSetValue(row, nameIndexes, 'Source Add');
		var sourceTon=tonValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'Source TON')];
		var npi=npiValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'NPI')];
		var destTon=tonValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'Dest TON')];
		var serviceType=SMPPprofile.getAndSetSelection(row, nameIndexes, 'Service type');
		var priority=priorityValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'Priority')];
		var delivery=deliveryValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'Delivery')];
		var responsePolicy=responseValues[SMPPprofile.getAndSetSelection(row, nameIndexes, 'Response policy')];
		var balancingPolicy=SMPPprofile.getAndSetChecked(row, nameIndexes, 'Balancing policy') ? '1' : '0';
		var validityPeriod=SMPPprofile.getAndSetValue(row, nameIndexes, 'Validity period');
		var url=SMPPprofile.getAndSetValue(row, nameIndexes, 'URL');
		
		if(name == "")		{SMPPprofile.check += "\nSMPPprofile section: profile name cannot be blank"; continue;}
		if(connector == "")	{SMPPprofile.check += "\nSMPPprofile section: connector name cannot be blank";continue;}
		if(SMPPsession.connectors == undefined || SMPPsession.connectors[VNFCindex] == undefined || SMPPsession.connectors[VNFCindex].length == 0 || SMPPsession.connectors[VNFCindex].indexOf(connector) < 0)	
			{SMPPprofile.check += "\nSMPPprofile vs SMPPsession sections: connector "+connector+" is undefined in the SMPPsession table for the "+VNFdisplayName;continue;}
		if(id == "")	{SMPPprofile.check += "\nSMPPprofile section: profile id cannot be blank";continue;}
		if(destAddr == "")	{SMPPprofile.check += "\nSMPPprofile section: destAddr cannot be blank";continue;}
		if(encoding == "")		{SMPPprofile.check += "\nSMPPprofile section: encoding cannot be blank";continue;}
		if(dataCoding == "")		{SMPPprofile.check += "\nSMPPprofile section: dataCoding cannot be blank";continue;}
		if(esmClass == "")	{SMPPprofile.check += "\nSMPPprofile section: esmClass cannot be blank";continue;}
		if(protocolId == "")	{SMPPprofile.check += "\nSMPPprofile section: protocolId cannot be blank";continue;}
		if(timeout == "")	{SMPPprofile.check += "\nSMPPprofile section: timeout cannot be blank";continue;}
		
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SMPPprofile.check += "\nSMPPprofile section: " + name + " session name is duplicated";
			continue;
		}
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this SMPPprofile resource definition
		var nameIndex = names[VNFCindex].length -1;

		if(connectors[VNFCindex] == undefined)connectors[VNFCindex] = new Array();
		connectors[VNFCindex][nameIndex]=connector;
		if(ids[VNFCindex] == undefined)ids[VNFCindex] = new Array();
		ids[VNFCindex][nameIndex]=id;
		if(destAddrs[VNFCindex] == undefined)destAddrs[VNFCindex] = new Array();
		destAddrs[VNFCindex][nameIndex]=destAddr;
		if(encodings[VNFCindex] == undefined)encodings[VNFCindex] = new Array();
		encodings[VNFCindex][nameIndex]=encoding;
		if(dataCodings[VNFCindex] == undefined)dataCodings[VNFCindex] = new Array();
		dataCodings[VNFCindex][nameIndex]=dataCoding;
		if(esmClasses[VNFCindex] == undefined)esmClasses[VNFCindex] = new Array();
		esmClasses[VNFCindex][nameIndex]=esmClass;
		if(protocolIds[VNFCindex] == undefined)protocolIds[VNFCindex] = new Array();
		protocolIds[VNFCindex][nameIndex]=protocolId;
		if(timeouts[VNFCindex] == undefined)timeouts[VNFCindex] = new Array();
		timeouts[VNFCindex][nameIndex]=timeout;
		if(sourceAddr != ""){
		if(sourceAddrs[VNFCindex] == undefined)sourceAddrs[VNFCindex] = new Array();
		sourceAddrs[VNFCindex][nameIndex]=sourceAddr;
		}
		if(sourceTon != ""){
		if(sourceTons[VNFCindex] == undefined)sourceTons[VNFCindex] = new Array();
		sourceTons[VNFCindex][nameIndex]=sourceTon;
		}
		if(npi != ""){
		if(npis[VNFCindex] == undefined)npis[VNFCindex] = new Array();
		npis[VNFCindex][nameIndex]=npi;
		}
		if(destTon != ""){
		if(destTons[VNFCindex] == undefined)destTons[VNFCindex] = new Array();
		destTons[VNFCindex][nameIndex]=destTon;
		}
		if(serviceType != ""){
		if(serviceTypes[VNFCindex] == undefined)serviceTypes[VNFCindex] = new Array();
		serviceTypes[VNFCindex][nameIndex]='SERVICE_TYPE_'+serviceType;
		}
		if(priority != ""){
		if(priorities[VNFCindex] == undefined)priorities[VNFCindex] = new Array();
		priorities[VNFCindex][nameIndex]=priority;
		}
		if(delivery != ""){
		if(deliveries[VNFCindex] == undefined)deliveries[VNFCindex] = new Array();
		deliveries[VNFCindex][nameIndex]=delivery;
		}
		if(responsePolicy != ""){
		if(responsePolicies[VNFCindex] == undefined)responsePolicies[VNFCindex] = new Array();
		responsePolicies[VNFCindex][nameIndex]=responsePolicy;
		}
		if(balancingPolicies[VNFCindex] == undefined)balancingPolicies[VNFCindex] = new Array();
		balancingPolicies[VNFCindex][nameIndex]=balancingPolicy;
		if(validityPeriod != ""){
		if(validityPeriods[VNFCindex] == undefined)validityPeriods[VNFCindex] = new Array();
		validityPeriods[VNFCindex][nameIndex]=validityPeriod;
		}
		if(url != ""){
		if(urls[VNFCindex] == undefined)urls[VNFCindex] = new Array();
		urls[VNFCindex][nameIndex]=url;
		}
		
	}
	
	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(connectors[i]);
		fillArrays(ids[i]);
		fillArrays(destAddrs[i]);
		fillArrays(encodings[i]);
		fillArrays(dataCodings[i]);
		fillArrays(esmClasses[i]);
		fillArrays(protocolIds[i]);
		fillArrays(timeouts[i]);
		fillArrays(sourceAddrs[i]);
		fillArrays(sourceTons[i]);
		fillArrays(npis[i]);
		fillArrays(destTons[i]);
		fillArrays(serviceTypes[i]);
		fillArrays(priorities[i]);
		fillArrays(deliveries[i]);
		fillArrays(responsePolicies[i]);
		fillArrays(balancingPolicies[i]);
		fillArrays(validityPeriods[i]);
		fillArrays(urls[i]);
		result += ifVNFCopen(e,i);
		result += "\nSMPP_PROFILE=( "+names[i].join(" ")+" )";
		if(connectors[i] != undefined)result += "\nSMPP_PROFILE_CONNECTOR=( "+connectors[i].join(" ")+" )";
		if(ids[i] != undefined)result += "\nSMPP_PROFILE_ID=( "+ids[i].join(" ")+" )";
		if(destAddrs[i] != undefined)result += "\nSMPP_PROFILE_DEST_ADD=( "+destAddrs[i].join(" ")+" )";
		if(encodings[i] != undefined)result += "\nSMPP_PROFILE_ENCODING=( "+encodings[i].join(" ")+" )";
		if(dataCodings[i] != undefined)result += "\nSMPP_PROFILE_DATA_CODING=( "+dataCodings[i].join(" ")+" )";
		if(esmClasses[i] != undefined)result += "\nSMPP_PROFILE_ESM_CLASS=( "+esmClasses[i].join(" ")+" )";
		if(protocolIds[i] != undefined)result += "\nSMPP_PROFILE_PROTOCOL_ID=( "+protocolIds[i].join(" ")+" )";
		if(timeouts[i] != undefined)result += "\nSMPP_PROFILE_TIMEOUT=( "+timeouts[i].join(" ")+" )";
		if(sourceAddrs[i] != undefined)result += "\nSMPP_PROFILE_SOURCE_ADD=( "+sourceAddrs[i].join(" ")+" )";
		if(sourceTons[i] != undefined)result += "\nSMPP_PROFILE_SOURCE_TON=( "+sourceTons[i].join(" ")+" )";
		if(npis[i] != undefined)result += "\nSMPP_PROFILE_NPI=( "+npis[i].join(" ")+" )";
		if(destTons[i] != undefined)result += "\nSMPP_PROFILE_DEST_TON=( "+destTons[i].join(" ")+" )";
		if(serviceTypes[i] != undefined)result += "\nSMPP_PROFILE_SERVICE_TYPE=( "+serviceTypes[i].join(" ")+" )";
		if(priorities[i] != undefined)result += "\nSMPP_PROFILE_PRIORITY=( "+priorities[i].join(" ")+" )";
		if(deliveries[i] != undefined)result += "\nSMPP_PROFILE_DELIVERY=( "+deliveries[i].join(" ")+" )";
		if(responsePolicies[i] != undefined)result += "\nSMPP_PROFILE_RESPONSE_POLICY=( "+responsePolicies[i].join(" ")+" )";
		if(balancingPolicies[i] != undefined)result += "\nSMPP_PROFILE_BALANCING_POLICY=( "+balancingPolicies[i].join(" ")+" )";
		if(validityPeriods[i] != undefined)result += "\nSMPP_PROFILE_VALIDITY_PERIOD=( "+validityPeriods[i].join(" ")+" )";
		if(urls[i] != undefined)result += "\nSMPP_PROFILE_URL=( "+urls[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	// Make the SMPP profiles available, useful for SMPP pairs consistency checks
	SMPPprofile.names = names.slice();
	
	if(SMPPprofile.check != "")result = SMPPprofile.check;

	return result;
}

// =============================
// SMPP pair
// =============================
var SMPPpair = new vnfResource("SMPPpair", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Provider', type:'text', width:'90px'},
	{name:'Profile', type:'text', width:'90px'},
	{name:'Connector', type:'text', width:'90px'},
	{name:'Primary', type:'text', width:'90px'},
	{name:'Secondary', type:'text', width:'90px'},
	{name:'Weight', type:'text', width:'60px'}
	]
	);
	
SMPPpair.help = function(){
	return "SMPP pairs:"+
	"\n\tA primary SMPP provider and an optional secondary SMPP provider define a Provider Pair."+
	"\n\tAn SMPP Provider can be referenced in more than one provider pairs (as primary or secondary), as long as these pairs belong to the same profile."+
	"\nName: Name of the SMPP pair" +
	"\nProvider: SMPP provider part of this pair" +
	"\nProfile: SMPP Profile owning this pair"+
	"\nConnector: SMPP connector attached to this pair."+
	"\nPrimary: SMPP provider playing the primary role in this pair"+
	"\nSecondary: SMPP provider playing the secondary role in this pair"+
	"\nWeight: ";
}

SMPPpair.build = function(){
	var nameIndexes = SMPPpair.nameIndexes;
	var currentVNFC = "";

	SMPPpair.check = "";
	var result = "\n";
	var table = document.getElementById("SMPPpair");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array(nbVNFC);
	var providers = new Array(nbVNFC);
	var profiles = new Array(nbVNFC);
	var connectors = new Array(nbVNFC);
	var primaries = new Array(nbVNFC);
	var secondaries = new Array(nbVNFC);
	var weights = new Array(nbVNFC);
		
	result += "\n# ------------------------------- #";
	result += "\n# SMPP pairs                      #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SMPPpair.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SMPPpair.check += "\nSMPPpair section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";
				
		var defaultConnector='smpp-'+i;
		if(SMPPsession.connectors != undefined && SMPPsession.connectors[VNFCindex] != undefined && SMPPsession.connectors[VNFCindex].length > 0)defaultConnector=SMPPsession.connectors[VNFCindex][0]
		var defaultProvider='smpp-'+i;
		if(SMPPsession.providers != undefined && SMPPsession.providers[VNFCindex] != undefined && SMPPsession.providers[VNFCindex].length > 0)defaultProvider=SMPPsession.providers[VNFCindex][0]
		
		var name=SMPPpair.getAndSetValue(row, nameIndexes, 'Name', 'smpp-'+i);
		var provider=SMPPpair.getAndSetValue(row, nameIndexes, 'Provider', defaultProvider);
		var profile=SMPPpair.getAndSetValue(row, nameIndexes, 'Profile', 'smpp-'+i);
		var connector=SMPPpair.getAndSetValue(row, nameIndexes, 'Connector', defaultConnector);
		var primary=SMPPpair.getAndSetValue(row, nameIndexes, 'Primary', defaultProvider);
		var secondary=SMPPpair.getAndSetValue(row, nameIndexes, 'Secondary');
		var weight=SMPPpair.getAndSetValue(row, nameIndexes, 'Weight', '20');
		
		if(name == "")		{SMPPpair.check += "\nSMPPpair section: profile name cannot be blank"; }
		if(provider == "")	{SMPPpair.check += "\nSMPPpair section: provider cannot be blank";}
		if(profile == "")	{SMPPpair.check += "\nSMPPpair section: profile cannot be blank";}
		if(SMPPprofile.names == undefined || SMPPprofile.names[VNFCindex] == undefined || SMPPprofile.names[VNFCindex].length == 0 || SMPPprofile.names[VNFCindex].indexOf(profile) < 0)	
			{SMPPpair.check += "\nSMPPprofile vs SMPPpair sections: profile "+profile+" is undefined in the SMPPprofile table for the "+VNFdisplayName;}
		if(connector == "")	{SMPPpair.check += "\nSMPPpair section: connector name cannot be blank";}
		if(primary == "")	{SMPPpair.check += "\nSMPPpair section: primary cannot be blank";}
		if(SMPPsession.providers == undefined || SMPPsession.providers[VNFCindex] == undefined || SMPPsession.providers[VNFCindex].length == 0 || SMPPsession.providers[VNFCindex].indexOf(primary) < 0)	
			{SMPPpair.check += "\nSMPPsession vs SMPPpair sections: primary provider "+primary+" is undefined in the SMPPsession table for the "+VNFdisplayName;}
		if(weight == "")	{SMPPpair.check += "\nSMPPpair section: weight cannot be blank";}
		
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SMPPpair.check += "\nSMPPpair section: " + name + " session name is duplicated";
			continue;
		}
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this SMPPpair resource definition
		var nameIndex = names[VNFCindex].length -1;

		if(providers[VNFCindex] == undefined)providers[VNFCindex] = new Array();
		providers[VNFCindex][nameIndex]=provider;
		if(profiles[VNFCindex] == undefined)profiles[VNFCindex] = new Array();
		profiles[VNFCindex][nameIndex]=profile;
		if(connectors[VNFCindex] == undefined)connectors[VNFCindex] = new Array();
		connectors[VNFCindex][nameIndex]=connector;
		if(primaries[VNFCindex] == undefined)primaries[VNFCindex] = new Array();
		primaries[VNFCindex][nameIndex]=primary;
		if(secondary != ""){
			if(SMPPsession.providers == undefined || SMPPsession.providers[VNFCindex] == undefined  || SMPPsession.providers[VNFCindex].length == 0 || SMPPsession.providers[VNFCindex].indexOf(secondary) < 0)	
				{SMPPpair.check += "\nSMPPsession vs SMPPpair sections: secondary provider "+secondary+" is undefined in the SMPPsession table for the "+VNFdisplayName;}
			if(secondaries[VNFCindex] == undefined)secondaries[VNFCindex] = new Array();
			secondaries[VNFCindex][nameIndex]=secondary;
		}
		if(weight != ""){
			if(weights[VNFCindex] == undefined)weights[VNFCindex] = new Array();
			weights[VNFCindex][nameIndex]=weight;
		}
	}
	
	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(providers[i]);
		fillArrays(profiles[i]);
		fillArrays(connectors[i]);
		fillArrays(primaries[i]);
		fillArrays(secondaries[i]);
		fillArrays(weights[i]);
		result += ifVNFCopen(e,i);
		result += "\nSMPP_PAIR=( "+names[i].join(" ")+" )";
		if(providers[i] != undefined)result += "\nSMPP_PAIR_PROVIDER_NAME=( "+providers[i].join(" ")+" )";
		if(profiles[i] != undefined)result += "\nSMPP_PAIR_PROFILE_NAME=( "+profiles[i].join(" ")+" )";
		if(connectors[i] != undefined)result += "\nSMPP_PAIR_CONNECTOR_NAME=( "+connectors[i].join(" ")+" )";
		if(primaries[i] != undefined)result += "\nSMPP_PAIR_PRIMARY_PROVIDER=( "+primaries[i].join(" ")+" )";
		if(secondaries[i] != undefined)result += "\nSMPP_PAIR_SECONDARY_PROVIDER=( "+secondaries[i].join(" ")+" )";
		if(weights[i] != undefined)result += "\nSMPP_PAIR_WEIGHT=( "+weights[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(SMPPpair.check != "")result = SMPPpair.check;

	return result;
}
		
// =============================
// Datasources
// =============================
var Datasource = new vnfResource("Datasource", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Type', type:'choice', width:'90px', choices:['jdbc', 'ldap']},
	{name:'Name', type:'text', width:'90px'},
	{name:'Service', type:'text', width:'90px'},
	{name:'User', type:'text', width:'90px'},
	{name:'Password', type:'text', width:'90px'},
	{name:'Instance Id', type:'text', width:'90px'}, 
	{name:'URL', type:'text', width:'250px'},
	{name:'Document', type:'text', width:'250px'},
	{name:'AutoDetect', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'AuthMode', type:'choice', width:'100px', choices:['none', 'simple', 'MD5-DIGEST']},
	{name:'Driver', type:'text', width:'250px'}
	]
	);
	
Datasource.help = function(){
	return "JDBC and LDAP data sources:"+
	"\nType: Data source type, either jdbc or ldap" +
	"\nName: Data source name, eg mysql, oracle..." +
	"\nService: Name of the SEE service hosting this data source (one SEE service can host multiple data sources of the same type)" +
	"\nUser (jdbc): The connection username provided for the JDBC driver to establish a connection."+
	"\n\tIf the DB user has a defined role, include that here. For example, for the Oracle sys user, the value of this field is: sys as sysdba" +
	"\nPassword (jdbc): The connection password given to the JDBC driver to establish a connection." +
	"\nPassword (ldap): Password for the None and Simple authentication bind methods." +
	"\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this data source, one per SEE node, as a list of comma separated integers, defaulting to the first in the list"+
	"\nURL: data source listening URL, defining the protocole, FQDN or IP address and TCP port of the host running the server to connect to; examples:"+
	"\n\tldap: ldap://10.0.3.62:389"+
	"\n\tjdbc: jdbc:mysql://localhost/test"+
	"\nDocument (jdbc): The full path to the filename that contains the JDBC profile document, eg file:///var/opt/OC/hpoc-see/tests/sample_profile_mysql.xml"+
	"\nAutoDetect (jdbc): This boolean determines whether to automatically detect the data type of the marker substitutions in the prepared statement."+
	"\n\tThis detection is done by inspecting the actual values that are passed in the HTTP URL. The value is first tested for INT, then for DOUBLE."+
	"\n\tIf neither tests pass, it is treated as a VARCHAR. If the boolean is set with the 'false' value, the connector returns the 400 HTTP error response code, if the profile does not explicitly provide the data types in the <parameter> tag. If the boolean is set with the 'true' value, the connector determines the data type first by using the data type as specified in the <parameter> tag in the JDBC profile document, or by using automatic detection in case it is not specified."+
	"\nAuthMode (ldap): The Bind operation authenticates the client for the server; the connection must be protected using Transport Layer Security (TLS) or SASL (Simple Authentication and Security Layer)."+
	"\n\t- None: the DN and password of the user are sent in plain text"+
	"\n\t- Simple: Simple TLS handshake"+
	"\n\t- MD5-DIGEST: HTTP Digest compatible challenge-response scheme based on MD5"+
	"\nDriver: the fully qualified Java class name of the JDBC driver to be used"+
	"\n\tExamples: com.mysql.jdbc.Driver, oracle.jdbc.OracleDriver; default: com.mysql.jdbc.Driver";
}

Datasource.build = function(){
	var nameIndexes = Datasource.nameIndexes;
	var currentVNFC = "";

	Datasource.check = "";
	var result = "\n";
	var table = document.getElementById("Datasource");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array(nbVNFC);
	var services = new Array(nbVNFC);
	var instanceIds = new Array(nbVNFC);
	var types = new Array(nbVNFC);
	var users = new Array(nbVNFC);
	var passwords = new Array(nbVNFC);
	var urls = new Array(nbVNFC);
	var jdbcdocuments = new Array(nbVNFC);
	var autodetects = new Array(nbVNFC);
	var authmodes = new Array(nbVNFC);
	var drivers = new Array(nbVNFC);
		
	result += "\n# ------------------------------- #";
	result += "\n# JDBC and LDAP data sources      #";
	result += "\n# ------------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = Datasource.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			Datasource.check += "\nDatasource section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
				
		var type=Datasource.getAndSetSelection(row, nameIndexes, 'Type', 0);
		var name=Datasource.getAndSetValue(row, nameIndexes, 'Name', type+'-'+i);
		var service=Datasource.getAndSetValue(row, nameIndexes, 'Service', 'Service-'+type+'-'+i);
		var instanceId=Datasource.getAndSetValue(row, nameIndexes, 'Instance Id');
		var url=Datasource.getAndSetValue(row, nameIndexes, 'URL', type == 'jdbc' ? 'jdbc:mysql://192.168.66.45:3306/here' : 'url=ldap://10.0.3.62:389');
		var jdbcdocument=Datasource.getAndSetValue(row, nameIndexes, 'Document', type == 'jdbc' ? 'file:///var/opt/OC/hpoc-see/tests/sample_profile_mysql.xml' : '');
		var autodetect=Datasource.getAndSetSelection(row, nameIndexes, 'AutoDetect', 0);
		var authmode=Datasource.getAndSetSelection(row, nameIndexes, 'AuthMode', 0);
		var user=Datasource.getAndSetValue(row, nameIndexes, 'User', authmode != 'MD5-DIGEST' ? 'ocadmin' : '');
		var password=Datasource.getAndSetValue(row, nameIndexes, 'Password', authmode != 'MD5-DIGEST' ? 'ocadmin' : '');
		var driver=Datasource.getAndSetValue(row, nameIndexes, 'Driver');
	
		if(name == ""){
			Datasource.check += "\nDatasource section: " + type + " data source name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			Datasource.check += "\nDatasource section: " + name + " data source name is duplicated";
			continue;
		}
		// user and password are mandatory, except for MD5 authentication mode, URL and service mandatory, document required for jdbc 
		Datasource.check += checkDependency(authmode != 'MD5-DIGEST', [user != "" && password != ""], "Datasource "+name, ": user and password are required for "+authmode+" authentication mode");
		Datasource.check += checkDependency(true, [url != ""], "Datasource "+name, ": URL is required");
		Datasource.check += checkDependency(true, [service != ""], "Datasource "+name, ": service is required");
		Datasource.check += checkDependency(type == 'jdbc', [jdbcdocument != ""], "Datasource "+name, ": document is required for "+type+" data source");
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this Datasource resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(instanceId != ""){
			Datasource.check+=checkSeeInstanceId(instanceId, "Datasource section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
		if(services[VNFCindex] == undefined)services[VNFCindex] = new Array();
		services[VNFCindex][nameIndex]=service;
		if(types[VNFCindex] == undefined)types[VNFCindex] = new Array();
		types[VNFCindex][nameIndex]=type;
		if(urls[VNFCindex] == undefined)urls[VNFCindex] = new Array();
		urls[VNFCindex][nameIndex]=url;
		
		// Ensure that all data sources hosted by one service share the same type for one VNFC
		Datasource.check += checkDependency(true, [ types[VNFCindex][service] == undefined , types[VNFCindex][service] == type ],  "Datasource "+name, ": service "+service + " cannot concurrently host data sources of types " + type+" and "+types[VNFCindex][service]);
		// Record the type used for this service
		types[VNFCindex][service] = type;

		if(jdbcdocument != ""){
			if(jdbcdocuments[VNFCindex] == undefined)jdbcdocuments[VNFCindex] = new Array();
			jdbcdocuments[VNFCindex][nameIndex]=jdbcdocument;
		}
		if(autodetects[VNFCindex] == undefined)autodetects[VNFCindex] = new Array();
		autodetects[VNFCindex][nameIndex]=autodetect;
		if(authmodes[VNFCindex] == undefined)authmodes[VNFCindex] = new Array();
		authmodes[VNFCindex][nameIndex]=authmode;

		if(user != ""){
			if(users[VNFCindex] == undefined)users[VNFCindex] = new Array();
			users[VNFCindex][nameIndex]=user;
		}
		if(password != ""){
			if(passwords[VNFCindex] == undefined)passwords[VNFCindex] = new Array();
			passwords[VNFCindex][nameIndex]=password;
		}
		if(driver != ""){
			if(drivers[VNFCindex] == undefined)drivers[VNFCindex] = new Array();
			drivers[VNFCindex][nameIndex]=driver;
		}
	}
	
	// Make the data source names, services and types available, useful for ldap profiles consistency checks
	Datasource.names = names.slice();
	Datasource.services = services.slice();
	Datasource.types = types.slice();
	
	VNFCnames.forEach(function(e,i,t){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(instanceIds[i]);
		fillArrays(types[i]);
		fillArrays(services[i]);
		fillArrays(users[i]);
		fillArrays(passwords[i]);
		fillArrays(urls[i]);
		fillArrays(jdbcdocuments[i]);
		fillArrays(autodetects[i]);
		fillArrays(authmodes[i]);
		fillArrays(drivers[i]);
		result += ifVNFCopen(e,i);
		result += "\nDATASOURCE_NAME=( "+names[i].join(" ")+" )";
		if(services[i] != undefined)result += "\nDATASOURCE_SERVICE_COMPONENT_NAME=( "+services[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nDATASOURCE_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(types[i] != undefined)result += "\nDATASOURCE_SERVICE_COMPONENT_TYPE=( "+types[i].join(" ")+" )";
		if(users[i] != undefined)result += "\nDATASOURCE_USER=( "+users[i].join(" ")+" )";
		if(passwords[i] != undefined)result += "\nDATASOURCE_PASS=( "+passwords[i].join(" ")+" )";
		if(urls[i] != undefined)result += "\nDATASOURCE_URL=( "+urls[i].join(" ")+" )";
		if(jdbcdocuments[i] != undefined)result += "\nDATASOURCE_DOCUMENT=( "+jdbcdocuments[i].join(" ")+" )";
		if(autodetects[i] != undefined)result += "\nDATASOURCE_DETECT=( "+autodetects[i].join(" ")+" )";
		if(authmodes[i] != undefined)result += "\nDATASOURCE_AUTHMODE=( "+authmodes[i].join(" ")+" )";
		if(drivers[i] != undefined)result += "\nDATASOURCE_DRIVER=( "+drivers[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(Datasource.check != "")result = Datasource.check;

	return result;
}
	
// =============================
// LDAP profiles
// =============================
var LDAPprofile = new vnfResource("LDAPprofile", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Data source', type:'text', width:'90px'},
	{name:'Base DN', type:'text', width:'200px'},
	{name:'Scope', type:'choice', width:'90px', choices:['Object', 'OneLevel', 'Subtree']},
	{name:'Time limit', type:'text', width:'90px'},
	{name:'Filter', type:'text', width:'400px'}
	]
	);
	
LDAPprofile.help = function(){
	return "LDAP profiles:"+
	"\nName: name of the LDAP profile" +
	"\nData source: name of the data source running this profile (one data source can run multiple profiles)." +
	"\nBase DN: the baseObject = the DN (Distinguished Name) of the entry where the search must be started, eg 'dc=nivr,dc=com'"+
	"\nScope: The elements to be searched within the baseObject.It has 3 possible values:"+
	"\n\t- Object: search just the named entry, typically used to read one entry"+
	"\n\t- OneLevel: entries immediately under the base DN"+
	"\n\t- Subtree: the entire subtree starting at the base DN"+
	"\nTime limit: maximum time allowed for the search request. Any number can be given in milliseconds, defaulting to 0, which means infinite."+
	"\nFilter: criteria to use in selecting elements within the scope."+
	"\n\tExample: (&(objectClass=person)(|(givenName=John)(mail=john*))) selects the 'persons' having the given name 'John' or an e-mail address that begins with the string 'john'.";
}

LDAPprofile.build = function(){
	var nameIndexes = LDAPprofile.nameIndexes;
	var currentVNFC = "";

	LDAPprofile.check = "";
	var result = "\n";
	var table = document.getElementById("LDAPprofile");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var services = new Array();
	var datasources = new Array();
	var DNs= new Array();
	var scopes = new Array();
	var timelimits = new Array();
	var filters = new Array();

	result += "\n# ------------- #";
	result += "\n# LDAP profiles #";
	result += "\n# ------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = LDAPprofile.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			LDAPprofile.check += "\nLDAPprofile section: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var name=LDAPprofile.getAndSetValue(row, nameIndexes, 'Name', 'profile-'+i);
		// check for data sources on this VNFC
		if(!Datasource.search('VNFC',VNFCName)){
			LDAPprofile.check += "\nLDAPprofile "+name+" vs nodes: "+VNFdisplayName+" has no data source defined";
			continue;
		}
		
		// check for an LDAP data source on this VNFC
		// Dependency on the datasource definitions
		Datasource.build();
		var defaultLdapDataSourceIndex=Datasource.types[VNFCindex].indexOf('ldap');
		if(defaultLdapDataSourceIndex < 0){
			LDAPprofile.check += "\nLDAPprofile "+name+" vs Datasource: "+VNFdisplayName+" has no ldap data source defined";
			continue;
		}
		
		var datasource=LDAPprofile.getAndSetValue(row, nameIndexes, 'Data source', Datasource.names[VNFCindex][defaultLdapDataSourceIndex]);
		var DN=LDAPprofile.getAndSetValue(row, nameIndexes, 'Base DN', 'dc=nivr,dc=com');
		var scope=LDAPprofile.getAndSetSelection(row, nameIndexes, 'Scope', 'Subtree');
		var timelimit=LDAPprofile.getAndSetValue(row, nameIndexes, 'Time limit');
		var filter=LDAPprofile.getAndSetValue(row, nameIndexes, 'Filter');
		
		if(name == ""){
			LDAPprofile.check += "\nLDAPprofile section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			LDAPprofile.check += "\nLDAPprofile section: " + name + " name is duplicated";
			continue;
		}
		// service data source DN and scope are mandatory 
		var dataSourceIndex = Datasource.names[VNFCindex].indexOf(datasource);
		if(dataSourceIndex < 0){
			LDAPprofile.check += "LDAPprofile "+name+ ": data source "+datasource+" does not exist on "+VNFdisplayName+".";
			continue;
		}
		var service=Datasource.services[VNFCindex][dataSourceIndex];
		LDAPprofile.check += checkDependency(true, [ Datasource.types[VNFCindex][dataSourceIndex] == 'ldap'], "LDAPprofile  "+name, " is attached to a "+Datasource.types[VNFCindex][dataSourceIndex]+" data source; ldap expected.");
		LDAPprofile.check += checkDependency(true, [DN != ""], "LDAPprofile "+name, ": DN is required");
		LDAPprofile.check += checkDependency(true, [scope != ""], "LDAPprofile "+name, ": scope is required");
		
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this Datasource resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(services[VNFCindex] == undefined)services[VNFCindex] = new Array();
		services[VNFCindex][nameIndex]=service;
		if(datasources[VNFCindex] == undefined)datasources[VNFCindex] = new Array();
		datasources[VNFCindex][nameIndex]=datasource;
		if(DNs[VNFCindex] == undefined)DNs[VNFCindex] = new Array();
		DNs[VNFCindex][nameIndex]=DN;
		if(scopes[VNFCindex] == undefined)scopes[VNFCindex] = new Array();
		scopes[VNFCindex][nameIndex]=scope;
		if(timelimit != ""){
			if(timelimits[VNFCindex] == undefined)timelimits[VNFCindex] = new Array();
			timelimits[VNFCindex][nameIndex]=timelimit;
		}
		if(filter != ""){
			if(filters[VNFCindex] == undefined)filters[VNFCindex] = new Array();
			// Add quotes since a filter may contain shell hostile characters like (|&*
			filters[VNFCindex][nameIndex]="'"+filter+"'";
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(services[i]);
		fillArrays(datasources[i]);
		fillArrays(services[i]);
		fillArrays(DNs[i]);
		fillArrays(scopes[i]);
		fillArrays(timelimits[i]);
		fillArrays(filters[i]);
		result += ifVNFCopen(e,i);
		result += "\nLDAP_PROFILE_NAME=( "+names[i].join(" ")+" )";
		if(services[i] != undefined)result += "\nLDAP_PROFILE_SERVICE_COMPONENT_NAME=( "+services[i].join(" ")+" )";
		if(datasources[i] != undefined)result += "\nLDAP_PROFILE_DATASOURCE=( "+datasources[i].join(" ")+" )";
		if(DNs[i] != undefined)result += "\nLDAP_PROFILE_BASEDN=( "+DNs[i].join(" ")+" )";
		if(scopes[i] != undefined)result += "\nLDAP_PROFILE_SCOPE=( "+scopes[i].join(" ")+" )";
		if(timelimits[i] != undefined)result += "\nLDAP_PROFILE_TIME_LIMIT=( "+timelimits[i].join(" ")+" )";
		if(filters[i] != undefined)result += "\nLDAP_PROFILE_FILTER=( "+filters[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(LDAPprofile.check != "")result = LDAPprofile.check;

	return result;
};
	
// =============================
// SOAP connectors
// =============================
var SOAPconnector = new vnfResource("SOAPconnector", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Instance Id', type:'text', width:'90px'}, 
	{name:'Request validation', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'Response validation', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'Timeout', type:'text', width:'90px'},
	{name:'Remove empty header', type:'choice', width:'90px', choices:['true', 'false']}
	]
	);
	
SOAPconnector.help = function(){
	return "SOAP connectors:"+
	"\nName: name of the SEE service hosting the SOAP connector" +
	"\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this connector, one per SEE node, as a list of comma separated integers, defaulting to the first in the list, defaulting to 1"+
	"\nRequest validation [true|false]: switch the validation of the SOAP Request created by the SOAP Connector. When this value is not set, the validation of the SOAP Request is disabled."+
	"\n\tStarting with MSE SOAP 2.2.0, setting this value validates SOAP response received from the back end server."+
	"\nResponse validation [true|false]: switch the validation of the SOAP Response received from the Back end SOAP Web Service. When this value is not set, the validation of the SOAP Response is disabled."+
	"\n\tStarting with MSE SOAP 2.2.0, setting this value validates SOAP request created by connector."+
	"\nTimeout: Set the back end connection timeout in milliseconds. Default: 3000 milliseconds."+
	"\nRemove empty header [true|false]: If true, empty SOAP header in SOAP responses received from the back end are deleted from the SOAP envelope. Default: true.";
}

SOAPconnector.build = function(){
	var nameIndexes = SOAPconnector.nameIndexes;
	var currentVNFC = "";

	SOAPconnector.check = "";
	var result = "\n";
	var table = document.getElementById("SOAPconnector");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var instanceIds = new Array();
	var validateRequests = new Array();
	var validateResponses= new Array();
	var timeouts = new Array();
	var removeHeaders = new Array();
	
	result += "\n# --------------- #";
	result += "\n# SOAP connectors #";
	result += "\n# --------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SOAPconnector.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SOAPconnector.check += "\nSOAPconnector vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var name=SOAPconnector.getAndSetValue(row, nameIndexes, 'Name', 'soap-'+i);
		var instanceId=SOAPconnector.getAndSetValue(row, nameIndexes, 'Instance Id');
		var validateRequest=SOAPconnector.getAndSetSelection(row, nameIndexes, 'Request validation', 0);
		var validateResponse=SOAPconnector.getAndSetSelection(row, nameIndexes, 'Response validation', 0);
		var timeout=SOAPconnector.getAndSetValue(row, nameIndexes, 'Timeout');
		var removeHeader=SOAPconnector.getAndSetSelection(row, nameIndexes, 'Remove empty header', 0);
		
		if(name == ""){
			SOAPconnector.check += "\nSOAPconnector section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SOAPconnector.check += "\nSOAPconnector section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this connector resource definition
		var nameIndex = names[VNFCindex].length -1;
		
		if(instanceId != ""){
			SOAPconnector.check+=checkSeeInstanceId(instanceId, "SOAPconnector section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
		if(validateRequest != ""){
			if(validateRequests[VNFCindex] == undefined)validateRequests[VNFCindex] = new Array();
			validateRequests[VNFCindex][nameIndex]=validateRequest;
		}
		if(validateResponse != ""){
			if(validateResponses[VNFCindex] == undefined)validateResponses[VNFCindex] = new Array();
			validateResponses[VNFCindex][nameIndex]=validateResponse;
		}
		if(timeout != ""){
			if(timeouts[VNFCindex] == undefined)timeouts[VNFCindex] = new Array();
			timeouts[VNFCindex][nameIndex]=timeout;
		}
		if(removeHeader != ""){
			if(removeHeaders[VNFCindex] == undefined)removeHeaders[VNFCindex] = new Array();
			removeHeaders[VNFCindex][nameIndex]=removeHeader;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(instanceIds[i]);
		fillArrays(validateRequests[i]);
		fillArrays(validateResponses[i]);
		fillArrays(timeouts[i]);
		fillArrays(removeHeaders[i]);
		result += ifVNFCopen(e,i);
		result += "\nSOAP_SERVICE_COMPONENT_NAME=( "+names[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nSOAP_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		if(validateRequests[i] != undefined)result += "\nSOAP_VALIDATE_SOAP_REQUEST=( "+validateRequests[i].join(" ")+" )";
		if(validateResponses[i] != undefined)result += "\nSOAP_VALIDATE_SOAP_RESPONSE=( "+validateResponses[i].join(" ")+" )";
		if(timeouts[i] != undefined)result += "\nSOAP_BACKEND_CONNECTION_TIMEOUT=( "+timeouts[i].join(" ")+" )";
		if(removeHeaders[i] != undefined)result += "\nSOAP_REMOVE_EMPTY_HEADER=( "+removeHeaders[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	// Save the list of SOAP Connectors names for Web Services check
	SOAPconnector.names = names.slice();
	
	if(SOAPconnector.check != "")result = SOAPconnector.check;

	return result;
};

// =============================
// SOAP Web Services Servers
// =============================
var SOAPWebServiceServer = new vnfResource("SOAPWebServiceServer", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Hostname', type:'text', width:'200px'}, 
	{name:'Protocol', type:'choice', width:'90px', choices:['http', 'https']},
	{name:'Service Port', type:'text', width:'90px'},
	{name:'WSDL port', type:'text', width:'90px'},
	{name:'Retry URL timeout', type:'text', width:'90px'},
	{name:'Max connections', type:'text', width:'90px'}
	]
	);
	
SOAPWebServiceServer.help = function(){
	return "SOAP Web Services Servers:"+
	"\nName: name of the SOAP web services server" +
	"\nHostname: FQDN or IP address of the host running a SOAP server to connect to: the host name of the server hosting the service or a gateway to the servers hosting the service."+
	"\nProtocol: Protocol to connect to web service server. To secure the communication between the HPE MSE SEE SOAP Connector and the web service server, https must be used to connect to web service server. Default http."+
	"\nService Port: Port on this server the SOAP services can be accessed from."+
	"\n\tExample: http://<hostname>:<service-port><-targetservice-url-suffix>"+
	"\nWSDL port: Port on this server the WSDL can be accessed from."+
	"\n\tExample: http://<hostname>:<wsdl-port><wsdl-url-suffix>"+
	"\nRetry URL timeout: This value is used when the SOAP connector encounters a failure when sending a SOAP request to this WSS."+
	"\n\tIn this case, further requests to this WSS are not sent until the Retry URL Timeout expires. A value of '0' means this timeout is not set."+
	"\n\tNote that, for this WSS to be considered for sending another SOAP request after a failure, both the Retry Skip Count must have exceeded, and the Retry URL Timeout must have expired."+
	"\n\tValue is given in milliseconds. The default value is 0."+
	"\nMax connections: The maximum number of active back end connections at any point in time during HPE MSE SEE SOAP Connector life cycle with this web service server."+
	"\n\tA value of 0 is treated as unlimited number of connections with this web service server.";
}

SOAPWebServiceServer.build = function(){
	var nameIndexes = SOAPWebServiceServer.nameIndexes;
	var currentVNFC = "";

	SOAPWebServiceServer.check = "";
	var result = "\n";
	var table = document.getElementById("SOAPWebServiceServer");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var hostnames = new Array();
	var protocols = new Array();
	var servicePorts= new Array();
	var WSDLports = new Array();
	var retryURLs= new Array();
	var maxConnections = new Array();
	// The protocol is expected as an integer, not a string
	var protocolEncoder = new Array(2);
	protocolEncoder['http']=0;protocolEncoder['https']=1;
	
	result += "\n# ------------------------- #";
	result += "\n# SOAP Web Services Servers #";
	result += "\n# ------------------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SOAPWebServiceServer.check += "\nSOAPWebServiceServer vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var name=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'Name', 'soapWSS-'+i);
		var hostname=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'Hostname', 'google.com');
		var protocol=SOAPWebServiceServer.getAndSetSelection(row, nameIndexes, 'Protocol', 0);
		var servicePort=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'Service Port', '8080');
		var WSDLport=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'WSDL port', '8080');
		var retryURL=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'Retry URL timeout');
		var maxConnection=SOAPWebServiceServer.getAndSetValue(row, nameIndexes, 'Max connections', 0);
		
		if(name == ""){
			SOAPWebServiceServer.check += "\nSOAPWebServiceServer section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SOAPWebServiceServer.check += "\nSOAPWebServiceServer section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this connector resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(hostname != ""){
			if(hostnames[VNFCindex] == undefined)hostnames[VNFCindex] = new Array();
			hostnames[VNFCindex][nameIndex]=hostname;
		}
		if(protocol != ""){
			if(protocols[VNFCindex] == undefined)protocols[VNFCindex] = new Array();
			protocols[VNFCindex][nameIndex]=protocolEncoder[protocol];
		}
		if(servicePort != ""){
			if(servicePorts[VNFCindex] == undefined)servicePorts[VNFCindex] = new Array();
			servicePorts[VNFCindex][nameIndex]=servicePort;
		}
		if(WSDLport != ""){
			if(WSDLports[VNFCindex] == undefined)WSDLports[VNFCindex] = new Array();
			WSDLports[VNFCindex][nameIndex]=WSDLport;
		}
		if(retryURL != ""){
			if(retryURLs[VNFCindex] == undefined)retryURLs[VNFCindex] = new Array();
			retryURLs[VNFCindex][nameIndex]=retryURL;
		}
		if(maxConnection != ""){
			if(maxConnections[VNFCindex] == undefined)maxConnections[VNFCindex] = new Array();
			maxConnections[VNFCindex][nameIndex]=maxConnection;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(hostnames[i]);
		fillArrays(protocols[i]);
		fillArrays(servicePorts[i]);
		fillArrays(WSDLports[i]);
		fillArrays(retryURLs[i]);
		fillArrays(maxConnections[i]);
		result += ifVNFCopen(e,i);
		result += "\nSOAP_WSS_NAME=( "+names[i].join(" ")+" )";
		if(hostnames[i] != undefined)result += "\nSOAP_WSS_HOSTNAME=( "+hostnames[i].join(" ")+" )";
		if(protocols[i] != undefined)result += "\nSOAP_WSS_PROTOCOL=( "+protocols[i].join(" ")+" )";
		if(servicePorts[i] != undefined)result += "\nSOAP_WSS_SERVICE_PORT=( "+servicePorts[i].join(" ")+" )";
		if(WSDLports[i] != undefined)result += "\nSOAP_WSS_WSDL_PORT=( "+WSDLports[i].join(" ")+" )";
		if(retryURLs[i] != undefined)result += "\nSOAP_WSS_RETRY_URL_TIMEOUT=( "+retryURLs[i].join(" ")+" )";
		if(maxConnections[i] != undefined)result += "\nSOAP_WSS_MAX_CONNECTIONS=( "+maxConnections[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(SOAPWebServiceServer.check != "")result = SOAPWebServiceServer.check;
	
	// Save the list of WSS names for Web Services check
	SOAPWebServiceServer.names = names.slice();

	return result;
};

// =============================
// SOAP Security Policies
// =============================
var SOAPsecurity = new vnfResource("SOAPsecurity", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'User', type:'text', width:'90px'},
	{name:'Password', type:'text', width:'90px'}, 
	{name:'Keystore', type:'text', width:'300px'},
	{name:'Keystore password', type:'text', width:'90px'},
	{name:'Public key', type:'text', width:'90px'},
	{name:'Private key', type:'text', width:'90px'},
	{name:'Private key password', type:'text', width:'90px'}
	]
	);
	
SOAPsecurity.help = function(){
	return "SOAP Security Policies"+
	"\nName: name of the SOAP Security Policy" +
	"\nTwo token profiles are supported: Username and X.509 Certificate" +
	"\nUsername profile:" +
	"\n\tUser: username."+
	"\n\tPassword: password." +
	"\nX.509 profile:" +
	"\n\tKeystore: The absolute path to the jdk keystore. Example: /var/opt/OC/hpoc-see/tests/SOAP/clientKeystore.jks"+
	"\n\tKeystore password: The password to access jdk keystore."+
	"\n\tPublic key: The alias for the public key stored in the keystore."+
	"\n\tPrivate key: The alias for the private key stored in the keystore."+
	"\n\tPrivate key password: The password for accessing private key referred by the alias as defined in the security.signature.username parameter.";
}

SOAPsecurity.build = function(){
	var nameIndexes = SOAPsecurity.nameIndexes;
	var currentVNFC = "";

	SOAPsecurity.check = "";
	var result = "\n";
	var table = document.getElementById("SOAPsecurity");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var users = new Array();
	var passwords = new Array();
	var keystores= new Array();
	var keystorePasswords= new Array();
	var publicKeys = new Array();
	var privateKeys= new Array();
	var privateKeyPasswords = new Array();
	
	result += "\n# -----------------------#";
	result += "\n# SOAP Security Policies #";
	result += "\n# -----------------------#";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SOAPsecurity.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SOAPsecurity.check += "\nSOAPsecurity vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var name=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Name', 'soapSecurity-'+i);
		var user=SOAPsecurity.getAndSetValue(row, nameIndexes, 'User');
		var password=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Password');
		var keystore=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Keystore', user == "" ? "/var/opt/OC/hpoc-see/tests/SOAP/clientKeystore.jks" : "");
		var keystorePassword=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Keystore password', user == "" ? "keystorepwd" : "");
		var publicKey=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Public key', user == "" ? "myservicekey" : "");
		var privateKey=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Private key', user == "" ? "myclientkey" : "");
		var privateKeyPassword=SOAPsecurity.getAndSetValue(row, nameIndexes, 'Private key password', user == "" ? "ckpass" : "");
		// Check consistency: username or X509
		SOAPsecurity.check += checkGroupConsistency([ user == "", password == "", keystore != "", keystorePassword != "", publicKey != "", privateKey != "", privateKeyPassword != ""], "SOAPsecurity " + name, " inconsistency: either user/password or keystore should be defined"); 

		if(name == ""){
			SOAPsecurity.check += "\nSOAPsecurity section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SOAPsecurity.check += "\nSOAPsecurity section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this connector resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(user != ""){
			if(users[VNFCindex] == undefined)users[VNFCindex] = new Array();
			users[VNFCindex][nameIndex]=user;
		}
		if(password != ""){
			if(passwords[VNFCindex] == undefined)passwords[VNFCindex] = new Array();
			passwords[VNFCindex][nameIndex]=password;
		}
		if(keystore != ""){
			if(keystores[VNFCindex] == undefined)keystores[VNFCindex] = new Array();
			keystores[VNFCindex][nameIndex]=keystore;
		}
		if(keystorePassword != ""){
			if(keystorePasswords[VNFCindex] == undefined)keystorePasswords[VNFCindex] = new Array();
			keystorePasswords[VNFCindex][nameIndex]=keystorePassword;
		}
		if(publicKey != ""){
			if(publicKeys[VNFCindex] == undefined)publicKeys[VNFCindex] = new Array();
			publicKeys[VNFCindex][nameIndex]=publicKey;
		}
		if(privateKey != ""){
			if(privateKeys[VNFCindex] == undefined)privateKeys[VNFCindex] = new Array();
			privateKeys[VNFCindex][nameIndex]=privateKey;
		}
		if(privateKeyPassword != ""){
			if(privateKeyPasswords[VNFCindex] == undefined)privateKeyPasswords[VNFCindex] = new Array();
			privateKeyPasswords[VNFCindex][nameIndex]=privateKeyPassword;
		}
		
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(users[i]);
		fillArrays(passwords[i]);
		fillArrays(keystores[i]);
		fillArrays(keystorePasswords[i]);
		fillArrays(publicKeys[i]);
		fillArrays(privateKeys[i]);
		fillArrays(privateKeyPasswords[i]);
		result += ifVNFCopen(e,i);
		result += "\nSOAP_SECURITY_NAME=( "+names[i].join(" ")+" )";
		if(users[i] != undefined)result += "\nSOAP_SECURITY_USERNAME=( "+users[i].join(" ")+" )";
		if(passwords[i] != undefined)result += "\nSOAP_SECURITY_PASSWORD=( "+passwords[i].join(" ")+" )";
		if(keystores[i] != undefined)result += "\nSOAP_SECURITY_KEYSTORE=( "+keystores[i].join(" ")+" )";
		if(keystorePasswords[i] != undefined)result += "\nSOAP_SECURITY_KEYSTORE_PASSWORD=( "+keystorePasswords[i].join(" ")+" )";
		if(publicKeys[i] != undefined)result += "\nSOAP_SECURITY_PUBLIC_KEY=( "+publicKeys[i].join(" ")+" )";
		if(privateKeys[i] != undefined)result += "\nSOAP_SECURITY_PRIVATE_KEY=( "+privateKeys[i].join(" ")+" )";
		if(privateKeyPasswords[i] != undefined)result += "\nSOAP_SECURITY_PRIVATE_KEY_PASSWORD=( "+privateKeyPasswords[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(SOAPsecurity.check != "")result = SOAPsecurity.check;
	
	// Save the list of SOAP Security Policy names for Web Services check
	SOAPsecurity.names = names.slice();

	return result;
};

// =============================
// SOAP Web Services
// =============================
var SOAPWebService = new vnfResource("SOAPWebService", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Servers', type:'text', width:'200px'}, 
	{name:'WSDL Servers', type:'text', width:'200px'},
	{name:'Name space', type:'text', width:'200px'},
	{name:'WSDL URL suffix', type:'text', width:'200px'},
	{name:'Service URL suffix', type:'text', width:'200px'},
	{name:'Security policy', type:'text', width:'90px'},
	{name:'Probe URL timeout', type:'text', width:'90px'},
	{name:'Retry URL timeout', type:'text', width:'90px'},
	{name:'Include header', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'Include namespace', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'Response remove', type:'choice', width:'90px', choices:['false', 'true']},
	{name:'Error code translation', type:'choice', width:'90px', choices:['true', 'false']}
	]
	);
	
SOAPWebService.help = function(){
	return "SOAP Web Services:"+
	"\nName: name of the SOAP web service" +
	"\nServers: The list of web service servers that can deliver this service."+
	"\n\tMultiple servers can be configured by providing a comma separated list."+
	"\nWSDL Servers: The list of web service servers that can deliver this service WSDL. If file system based WSDL is used, select created filesystempath as the WSDL server."+
	"\n\tMultiple servers can be configured by providing a comma separated list."+
	"\nName space: Specify the name space used for SOAP messages. This parameter must be set to the value of targetnamespace as defined in the WSDL."+
	"\n\tExample: http://myserviceprovider.com/billing/"+
	"\n\tNot supported in MSE SOAP 2.2.0"+
	"\nWSDL URL suffix: Suffix to frame the URL for accessing WSDL from the web service server."+
	"\n\tExample: http://<host-name>:<wsdlport><wsdl-url-suffix> Or /<local path to service WSDL>/<service name>.wsdl"+
	"\nService URL suffix: Suffix to frame the URL for accessing SOAP web service on the web service server."+
	"\n\tExample: http://<hostname>:<service-port><-target-service-url-suffix>"+
	"\nSecurity policy: Security Policy to be applied on this Web Service request/answer. If set to 'Default', no security policy is applied."+
	"\nProbe URL timeout: used only when the WSDL is fetched from a remote back end and not the local file system. The number of milliseconds to wait before trying to probe an unreachable service using WSDL URL suffix."+
	"\n\tIf this value is set to 0, probing is disabled. Default value is '0'."+
	"\nRetry URL timeout: Timeout value in milliseconds to wait for a response from this web service when an http WSDL request is sent using the WSDL URL suffix. Default value is '0'."+
	"\nInclude header [true|false]: When enabled, SOAP requests contain the security header elements. Not supported in MSE SOAP 2.2.0"+
	"\nInclude namespace [true|false]: When enabled the namespace prefix is appended to the SOAP Request, otherwise it is not present in the payload. Not supported in MSE SOAP 2.2.0"+
	"\nResponse remove [true|false]: When enabled, empty elements in response returned by the web service are removed."+
	"\n\tEmpty elements are whitespace and newline characters that can occur between elements in a SOAP response. Not supported in MSE SOAP 2.2.0"+
	"\nError code translation [true|false]: Translation of error codes returned by the web service to a HTTP response code."+
	"\n\tIf translation is enabled, the error codes of web service are returned to the http response, otherwise the http response codes are retained.";
}

SOAPWebService.build = function(){
	var nameIndexes = SOAPWebService.nameIndexes;
	var currentVNFC = "";

	SOAPWebService.check = "";
	var result = "\n";
	var table = document.getElementById("SOAPWebService");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var servers = new Array();
	var WSDLservers = new Array();
	var namespaces = new Array();
	var WSDLURLs = new Array();
	var serviceURLs = new Array();
	var securityPolicies = new Array();
	var probeURLs = new Array();
	var retryURLs = new Array();
	var includeHeaders = new Array();
	var includeNamespaces = new Array();
	var removeResponses = new Array();
	var errorTranslations = new Array();
	
	result += "\n# ----------------- #";
	result += "\n# SOAP Web Services #";
	result += "\n# ----------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = SOAPWebService.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			SOAPWebService.check += "\nSOAPWebService vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		// Need at least one web service server before defining a Web Service
		if(SOAPWebServiceServer.names == undefined || SOAPWebServiceServer.names.length == 0 || SOAPWebServiceServer.names[VNFCindex].length == 0){
			SOAPWebService.check += "\nSOAPWebService vs SOAPWebServiceServer sections: no Web Service Server defined for "+VNFdisplayName;
			continue;
		}
		
		// Need at least one SOAPconnector before defining a Web Service
		if(SOAPconnector.names == undefined || SOAPconnector.names.length == 0 || SOAPconnector.names[VNFCindex].length == 0){
			SOAPWebService.check += "\nSOAPWebService vs SOAPconnector sections: no SOAP connector defined for "+VNFdisplayName;
			continue;
		}
		
		var name=SOAPWebService.getAndSetValue(row, nameIndexes, 'Name', 'soapWS-'+i);
		// Use the first defined Web Service Server on this VNFC as the default value for all servers, or nothing
		var defaultWSS = SOAPWebServiceServer.names != undefined && SOAPWebServiceServer.names[VNFCindex] != undefined && SOAPWebServiceServer.names[VNFCindex].length > 0 ? SOAPWebServiceServer.names[VNFCindex][0] : ''; 
		var server=SOAPWebService.getAndSetValue(row, nameIndexes, 'Servers', defaultWSS);
		var WSDLserver=SOAPWebService.getAndSetValue(row, nameIndexes, 'WSDL Servers', defaultWSS);
		var namespace=SOAPWebService.getAndSetValue(row, nameIndexes, 'Name space', 'http://myserviceprovider.com/billing/');
		var WSDLURL=SOAPWebService.getAndSetValue(row, nameIndexes, 'WSDL URL suffix', 'http://myserviceprovider.com:10090/wsdl-url-suffix');
		var serviceURL=SOAPWebService.getAndSetValue(row, nameIndexes, 'Service URL suffix', 'http://myserviceprovider.com:10090/wsdl-service-url-suffix');
		// Use the first defined Security policy as the default value for all servers, or nothing
		var securityPolicy=SOAPWebService.getAndSetValue(row, nameIndexes, 'Security policy', (SOAPsecurity.names != undefined && SOAPsecurity.names[VNFCindex].length > 0) ? SOAPsecurity.names[VNFCindex][0] : '', 'Recommended security policy');
		var probeURL=SOAPWebService.getAndSetValue(row, nameIndexes, 'Probe URL timeout');
		var retryURL=SOAPWebService.getAndSetValue(row, nameIndexes, 'Retry URL timeout');
		var includeHeader=SOAPWebService.getAndSetSelection(row, nameIndexes, 'Include header', 1);
		var includeNamespace=SOAPWebService.getAndSetSelection(row, nameIndexes, 'Include namespace', 1);
		var removeResponse=SOAPWebService.getAndSetSelection(row, nameIndexes, 'Response remove', 0);
		var errorTranslation=SOAPWebService.getAndSetSelection(row, nameIndexes, 'Error code translation', 0);
		
		if(name == ""){
			SOAPWebService.check += "\nSOAPWebService section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			SOAPWebService.check += "\nSOAPWebService section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this connector resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(server != ""){
			// Check that all servers are defined in the WSS section
			server.split(",").forEach(function(e,i,t){
				if(SOAPWebServiceServer.names == undefined || SOAPWebServiceServer.names[VNFCindex].indexOf(e) < 0)SOAPWebService.check += "\nSOAPWebService "+name+": Web Services Server " + e + " is not defined in the SOAPWebServiceServer table for "+VNFdisplayName;
				}
			);
			if(servers[VNFCindex] == undefined)servers[VNFCindex] = new Array();
			servers[VNFCindex][nameIndex]=server;
		} else {SOAPWebService.check += "\nSOAPWebService: Web Services Server "+name+": Web Services Server is required";}
		if(WSDLserver != ""){
			// Check that all servers are defined in the WSS section
			WSDLserver.split(",").forEach(function(e,i,t){
				if(SOAPWebServiceServer.names == undefined || SOAPWebServiceServer.names[VNFCindex].indexOf(e) < 0)SOAPWebService.check += "\nSOAPWebService "+name+": WSDL Web Services Server " + e + " is not defined in the SOAPWebServiceServer table for "+VNFdisplayName;
				}
			);
			if(WSDLservers[VNFCindex] == undefined)WSDLservers[VNFCindex] = new Array();
			WSDLservers[VNFCindex][nameIndex]=WSDLserver;
		} else {SOAPWebService.check += "\nSOAPWebService: Web Services Server "+name+": WSDL Web Services Server is required";}
		if(namespace != ""){
			if(namespaces[VNFCindex] == undefined)namespaces[VNFCindex] = new Array();
			namespaces[VNFCindex][nameIndex]=namespace;
		}
		if(WSDLURL != ""){
			if(WSDLURLs[VNFCindex] == undefined)WSDLURLs[VNFCindex] = new Array();
			WSDLURLs[VNFCindex][nameIndex]=WSDLURL;
		}
		if(serviceURL != ""){
			if(serviceURLs[VNFCindex] == undefined)serviceURLs[VNFCindex] = new Array();
			serviceURLs[VNFCindex][nameIndex]=serviceURL;
		}
		if(securityPolicy != ""){
			// Check that this policy is defined 
			if(SOAPsecurity.names ==  undefined || SOAPsecurity.names[VNFCindex].indexOf(securityPolicy) < 0)SOAPWebService.check += "\nSOAPWebService "+name+": security policy "+securityPolicy+" is undefined in the SOAPsecurity table for "+VNFdisplayName;
			if(securityPolicies[VNFCindex] == undefined)securityPolicies[VNFCindex] = new Array();
			securityPolicies[VNFCindex][nameIndex]=securityPolicy;
		}
		if(probeURL != ""){
			if(probeURLs[VNFCindex] == undefined)probeURLs[VNFCindex] = new Array();
			probeURLs[VNFCindex][nameIndex]=probeURL;
		}
		if(retryURL != ""){
			if(retryURLs[VNFCindex] == undefined)retryURLs[VNFCindex] = new Array();
			retryURLs[VNFCindex][nameIndex]=retryURL;
		}
		if(includeHeader != ""){
			if(includeHeaders[VNFCindex] == undefined)includeHeaders[VNFCindex] = new Array();
			includeHeaders[VNFCindex][nameIndex]=includeHeader;
		}
		if(includeNamespace != ""){
			if(includeNamespaces[VNFCindex] == undefined)includeNamespaces[VNFCindex] = new Array();
			includeNamespaces[VNFCindex][nameIndex]=includeNamespace;
		}
		if(removeResponse != ""){
			if(removeResponses[VNFCindex] == undefined)removeResponses[VNFCindex] = new Array();
			removeResponses[VNFCindex][nameIndex]=removeResponse;
		}
		if(errorTranslation != ""){
			if(errorTranslations[VNFCindex] == undefined)errorTranslations[VNFCindex] = new Array();
			errorTranslations[VNFCindex][nameIndex]=errorTranslation;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(servers[i]);
		fillArrays(WSDLservers[i]);
		fillArrays(namespaces[i]);
		fillArrays(WSDLURLs[i]);
		fillArrays(serviceURLs[i]);
		fillArrays(securityPolicies[i]);
		fillArrays(probeURLs[i]);
		fillArrays(retryURLs[i]);
		fillArrays(includeHeaders[i]);
		fillArrays(includeNamespaces[i]);
		fillArrays(removeResponses[i]);
		fillArrays(errorTranslations[i]);
		result += ifVNFCopen(e,i);
		result += "\nSOAP_WS_NAME=( "+names[i].join(" ")+" )";
		if(servers[i] != undefined)result += "\nSOAP_WS_SERVERS=( "+servers[i].join(" ")+" )";
		if(WSDLservers[i] != undefined)result += "\nSOAP_WS_WSDL_SERVERS=( "+WSDLservers[i].join(" ")+" )";
		if(namespaces[i] != undefined)result += "\nSOAP_WS_NAMESPACE=( "+namespaces[i].join(" ")+" )";
		if(WSDLURLs[i] != undefined)result += "\nSOAP_WS_WSDL_URL_SUFFIX=( "+WSDLURLs[i].join(" ")+" )";
		if(serviceURLs[i] != undefined)result += "\nSOAP_WS_SERVICE_URL_SUFFIX=( "+serviceURLs[i].join(" ")+" )";
		if(securityPolicies[i] != undefined)result += "\nSOAP_WS_SECURITY_POLICY=( "+securityPolicies[i].join(" ")+" )";
		if(probeURLs[i] != undefined)result += "\nSOAP_WS_PROBE_URL_TIMEOUT=( "+probeURLs[i].join(" ")+" )";
		if(retryURLs[i] != undefined)result += "\nSOAP_WS_RETRY_URL_TIMEOUT=( "+retryURLs[i].join(" ")+" )";
		if(includeHeaders[i] != undefined)result += "\nSOAP_WS_INCLUDE_HEADER=( "+includeHeaders[i].join(" ")+" )";
		if(includeNamespaces[i] != undefined)result += "\nSOAP_WS_INCLUDE_NAMESPACE=( "+includeNamespaces[i].join(" ")+" )";
		if(removeResponses[i] != undefined)result += "\nSOAP_WS_RESPONSE_REMOVE=( "+removeResponses[i].join(" ")+" )";
		if(errorTranslations[i] != undefined)result += "\nSOAP_WS_ERROR_CODE_TRANSLATION=( "+errorTranslations[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(SOAPWebService.check != "")result = SOAPWebService.check;

	return result;
};

// =============================
// XMLRPC connectors
// =============================
var XMLRPCconnector = new vnfResource("XMLRPCconnector", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Instance Id', type:'text', width:'90px'}
	]
	);
	
XMLRPCconnector.help = function(){
	return "XMLRPC connector: an XMLRPC Connector must be associated to a SEE service. It is used as a container of profiles."+
	"\nName: name of the SEE service hosting the XMLRPC connector" +
	"\nInstance Id: the SEE instance Ids assigned to the SEE service hosting this connector, one per SEE node, as a list of comma separated integers, defaulting to the first in the list, defaulting to 1";
}

XMLRPCconnector.build = function(){
	var nameIndexes = XMLRPCconnector.nameIndexes;
	var currentVNFC = "";

	XMLRPCconnector.check = "";
	var result = "\n";
	var table = document.getElementById("XMLRPCconnector");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var instanceIds = new Array();
	
	result += "\n# ----------------- #";
	result += "\n# XMLRPC connectors #";
	result += "\n# ----------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = XMLRPCconnector.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			XMLRPCconnector.check += "\nXMLRPCconnector vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var name=XMLRPCconnector.getAndSetValue(row, nameIndexes, 'Name', 'xmlrpc-'+i);
		var instanceId=XMLRPCconnector.getAndSetValue(row, nameIndexes, 'Instance Id');
		
		if(name == ""){
			XMLRPCconnector.check += "\nXMLRPCconnector section: name cannot be blank";
			continue;
		}
		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			XMLRPCconnector.check += "\nXMLRPCconnector section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		// New elements should be pushed at index names.length -1 to match this connector resource definition
		var nameIndex = names[VNFCindex].length -1;
		
		if(instanceId != ""){
			XMLRPCconnector.check+=checkSeeInstanceId(instanceId, "XMLRPCconnector section");
			if(instanceIds[VNFCindex] == undefined)instanceIds[VNFCindex] = new Array();
			instanceIds[VNFCindex][nameIndex]=instanceId;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(instanceIds[i]);
		result += ifVNFCopen(e,i);
		result += "\nXMLRPC_SERVICE_COMPONENT_NAME=( "+names[i].join(" ")+" )";
		if(instanceIds[i] != undefined)result += "\nXMLRPC_INSTANCE_ID=( "+instanceIds[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	// Export the defined service names for pre requisite checking in other XMLRPC resources 
	XMLRPCconnector.names = names.slice();
	
	if(XMLRPCconnector.check != "")result = XMLRPCconnector.check;

	return result;
};

// =============================
// XMLRPC Services
// =============================
var XMLRPCService = new vnfResource("XMLRPCService", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'Name', type:'text', width:'90px'},
	{name:'Type', type:'choice', width:'60px', choices:['UCIP', 'ACIP', 'VSIP', 'CAX']}, 
	{name:'Schema', type:'text', width:'350px'},
	{name:'Probe timeout', type:'text', width:'60px'},
	{name:'Retry timeout', type:'text', width:'60px'},
	{name:'Max connections', type:'text', width:'60px'},
	{name:'Probe operation', type:'text', width:'150px'},
	{name:'Probe origin type', type:'text', width:'60px'},
	{name:'Probe origin host', type:'text', width:'60px'},
	{name:'Probe origin transaction ID', type:'text', width:'60px'},
	{name:'Probe origin timestamp', type:'text', width:'150px'},
	{name:'Probe subscriber number', type:'text'},
	{name:'Probe serial number', type:'text'},
	{name:'Probe SOB', type:'text', width:'60px'}
	]
	);
	
XMLRPCService.help = function(){
	return "XMLRPC Service: profile used to configure parameters for accessing XMLRPC servers. A service is attached to an XMLRPC Connector"+
	"\nName: name of the XMLRPC service" +
	"\nType: type of message set."+
	"\nSchema: Location of the XSD description of this service."+
	"\n\tExample: /opt/OC/share/hpoc-nivr-xmlrpc/messagesets/UCIP.xsd"+
	"\nProbe timeout: With High Availability enabled, this optional timeout defines how long the HPE SEE UCIP Connector must wait for the probe response to be received from the AIR server."+
	"\n\tThe AIR server is considered inactive if it does not answer before this timer expires. The default value is 10 seconds."+
	"\nRetry timeout: With High Availability enabled, this optional timeout defines how long the HPE SEE UCIP Connector must probe the connection status of the AIR server."+
	"\n\tIf the timer expires, the probing is stopped. The default value is 30 seconds."+
	"\nMax connections: maximum number of connections that can be established to each back-end AIR server; 0 disables the limitation. Default value is 0."+
	"\n\nProbing: required for high availability, to let XMLRPC connector check connectivity with end servers."+
	"\n\tOperation: example GetBalanceAndDate"+
	"\n\tOrigin type: example EXT"+
	"\n\tOrigin host: example IVR"+
	"\n\tOrigin transaction ID: example 1000"+
	"\n\tOrigin timestamp: example 20050817T02:30:00+0000"+
	"\n\tSubscriber number: example 118262464"
	;
}

XMLRPCService.build = function(){
	var nameIndexes = XMLRPCService.nameIndexes;
	var currentVNFC = "";

	XMLRPCService.check = "";
	var result = "\n";
	var table = document.getElementById("XMLRPCService");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var names = new Array();
	var types = new Array();
	var schemas = new Array();
	var probeTOs = new Array();
	var retryTOs = new Array();
	var maxconnections = new Array();
	var probeOperations = new Array();
	var probeTypes = new Array();
	var probeHosts = new Array();
	var probeTransactions = new Array();
	var probeTimestamps = new Array();
	var probeSubscribers = new Array();
	var probeSerialNumbers = new Array();
	var probeSOBs = new Array();
	
	var defaultSchema = new Array();
	defaultSchema['UCIP'] = "/opt/OC/share/hpoc-nivr-xmlrpc/messagesets/ucip/UCIP5.0.xsd"; 
	defaultSchema['ACIP'] = "/opt/OC/share/hpoc-nivr-xmlrpc/messagesets/acip/ACIP5.0.xsd";
	defaultSchema['VSIP'] = "/opt/OC/share/hpoc-nivr-xmlrpc/messagesets/vsip/VSIP2.5.xsd";
	defaultSchema['CAX']  = "/opt/OC/share/hpoc-nivr-xmlrpc/messagesets/cax/CAX.xsd";
	
	result += "\n# ----------------- #";
	result += "\n# XMLRPC Services   #";
	result += "\n# ----------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = XMLRPCService.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			XMLRPCService.check += "\nXMLRPCService vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		var type=XMLRPCService.getAndSetSelection(row, nameIndexes, 'Type', 0);
		var name=XMLRPCService.getAndSetValue(row, nameIndexes, 'Name', type+'-'+i);
		var schema=XMLRPCService.getAndSetValue(row, nameIndexes, 'Schema', defaultSchema[type]);
		var probeTO=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe timeout');
		var retryTO=XMLRPCService.getAndSetValue(row, nameIndexes, 'Retry timeout');
		var maxconnection=XMLRPCService.getAndSetValue(row, nameIndexes, 'Max connections');
		var probeOperation=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe operation');
		var probeType=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe origin type');
		var probeHost=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe origin host');
		var probeTransaction=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe origin transaction ID');
		var probeTimestamp=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe origin timestamp');
		var probeSubscriber=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe subscriber number');
		var probeSerialNumber=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe serial number');
		var probeSOB=XMLRPCService.getAndSetValue(row, nameIndexes, 'Probe SOB');
		
		if(name == ""){
			XMLRPCService.check += "\nXMLRPCService section: name cannot be blank";
			continue;
		}
		if(type == ""){
			XMLRPCService.check += "\nXMLRPCService section: type cannot be blank";
			continue;
		}
		if(schema == ""){
			XMLRPCService.check += "\nXMLRPCService section: schema location cannot be blank";
			continue;
		}
		
		if(XMLRPCconnector.names == undefined || XMLRPCconnector.names[VNFCindex] == undefined || XMLRPCconnector.names[VNFCindex].length < 1){
			XMLRPCService.check += "\nXMLRPCService vs XMLRPCconnector sections: no XMLRPC connector defined on "+VNFdisplayName;
			continue;
		}

		if(names[VNFCindex] == undefined)names[VNFCindex] = new Array();
		if(names[VNFCindex].indexOf(name) != -1){
			XMLRPCService.check += "\nXMLRPCService section: " + name + " name is duplicated";
			continue;
		}
		names[VNFCindex].push(name);
		if(types[VNFCindex] == undefined)types[VNFCindex] = new Array();
		types[VNFCindex].push(type);
		if(schemas[VNFCindex] == undefined)schemas[VNFCindex] = new Array();
		schemas[VNFCindex].push(schema);
		// New elements should be pushed at index names.length -1 to match this service resource definition
		var nameIndex = names[VNFCindex].length -1;
		if(probeTO != ""){
			if(probeTOs[VNFCindex] == undefined)probeTOs[VNFCindex] = new Array();
			probeTOs[VNFCindex][nameIndex]=probeTO;
		}
		if(retryTO != ""){
			if(retryTOs[VNFCindex] == undefined)retryTOs[VNFCindex] = new Array();
			retryTOs[VNFCindex][nameIndex]=retryTO;
		}
		if(maxconnection != ""){
			if(maxconnections[VNFCindex] == undefined)maxconnections[VNFCindex] = new Array();
			maxconnections[VNFCindex][nameIndex]=maxconnection;
		}
		
		if(probeOperation != ""){
			if(probeOperations[VNFCindex] == undefined)probeOperations[VNFCindex] = new Array();
			probeOperations[VNFCindex][nameIndex]=probeOperation;
			XMLRPCService.check += checkDependency(type == 'VSIP', [probeSerialNumber != ""], "XMLRPCService section: ", "SerialNumber probe argument is mandatory for VSIP "+name+" service" ); 
			XMLRPCService.check += checkDependency(type == 'CAX', [probeSOB != ""], "XMLRPCService section: ", "SOB probe argument is mandatory for CAX "+name+" service" );
		}
		if(probeType != ""){
			if(probeTypes[VNFCindex] == undefined)probeTypes[VNFCindex] = new Array();
			probeTypes[VNFCindex][nameIndex]=probeType;
		}
		if(probeHost != ""){
			if(probeHosts[VNFCindex] == undefined)probeHosts[VNFCindex] = new Array();
			probeHosts[VNFCindex][nameIndex]=probeHost;
		}
		if(probeTransaction != ""){
			if(probeTransactions[VNFCindex] == undefined)probeTransactions[VNFCindex] = new Array();
			probeTransactions[VNFCindex][nameIndex]=probeTransaction;
		}
		if(probeTimestamp != ""){
			if(probeTimestamps[VNFCindex] == undefined)probeTimestamps[VNFCindex] = new Array();
			probeTimestamps[VNFCindex][nameIndex]=probeTimestamp;
		}
		if(probeSubscriber != ""){
			if(probeSubscribers[VNFCindex] == undefined)probeSubscribers[VNFCindex] = new Array();
			probeSubscribers[VNFCindex][nameIndex]=probeSubscriber;
		}
		if(probeSerialNumber != ""){
			if(probeSerialNumbers[VNFCindex] == undefined)probeSerialNumbers[VNFCindex] = new Array();
			probeSerialNumbers[VNFCindex][nameIndex]=probeSerialNumber;
		}
		if(probeSOB != ""){
			if(probeSOBs[VNFCindex] == undefined)probeSOBs[VNFCindex] = new Array();
			probeSOBs[VNFCindex][nameIndex]=probeSOB;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(names[i] == undefined || names[i].length == 0)return;
		fillArrays(types[i]);
		fillArrays(schemas[i]);
		fillArrays(probeTOs[i]);
		fillArrays(retryTOs[i]);
		fillArrays(maxconnections[i]);
		fillArrays(probeOperations[i]);
		fillArrays(probeTypes[i]);
		fillArrays(probeHosts[i]);
		fillArrays(probeTransactions[i]);
		fillArrays(probeTimestamps[i]);
		fillArrays(probeSubscribers[i]);
		fillArrays(probeSerialNumbers[i]);
		fillArrays(probeSOBs[i]);
		result += ifVNFCopen(e,i);
		result += "\nXMLRPC_SERVICE=( "+names[i].join(" ")+" )";
		if(types[i] != undefined)result += "\nXMLRPC_SERVICE_TYPE=( "+types[i].join(" ")+" )";
		if(schemas[i] != undefined)result += "\nXMLRPC_SERVICE_SCHEMA_LOCATION=( "+schemas[i].join(" ")+" )";
		if(probeTOs[i] != undefined)result += "\nXMLRPC_SERVICE_PROBETIMEOUT=( "+probeTOs[i].join(" ")+" )";
		if(retryTOs[i] != undefined)result += "\nXMLRPC_SERVICE_RETRYTIMEOUT=( "+retryTOs[i].join(" ")+" )";
		if(maxconnections[i] != undefined)result += "\nXMLRPC_SERVICE_MAXCONNECTIONS=( "+maxconnections[i].join(" ")+" )";
		if(probeOperations[i] != undefined)result += "\nXMLRPC_SERVICE_OPERATION=( "+probeOperations[i].join(" ")+" )";
		if(probeTypes[i] != undefined)result += "\nXMLRPC_SERVICE_ORIGINE_NODE_TYPE=( "+probeTypes[i].join(" ")+" )";
		if(probeHosts[i] != undefined)result += "\nXMLRPC_SERVICE_ORIGINE_HOST_NAME=( "+probeHosts[i].join(" ")+" )";
		if(probeTransactions[i] != undefined)result += "\nXMLRPC_SERVICE_ORIGINE_TRANSACTION_ID=( "+probeTransactions[i].join(" ")+" )";
		if(probeTimestamps[i] != undefined)result += "\nXMLRPC_SERVICE_ORIGINE_TIME_STAMP=( '"+probeTimestamps[i].join("' '")+"' )";
		if(probeSubscribers[i] != undefined)result += "\nXMLRPC_SERVICE_SUBSCRIBER_NUMBER=( "+probeSubscribers[i].join(" ")+" )";
		if(probeSerialNumbers[i] != undefined)result += "\nXMLRPC_SERVICE_SERIAL_NUMBER=( "+probeSerialNumbers[i].join(" ")+" )";
		if(probeSOBs[i] != undefined)result += "\nXMLRPC_SERVICE_SOB=( "+probeSOBs[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	XMLRPCService.names = names.slice();
	
	if(XMLRPCService.check != "")result = XMLRPCService.check;

	return result;
};

// =============================
// XMLRPC Servers
// =============================
var XMLRPCServer = new vnfResource("XMLRPCServer", [
	{name:'VNFC', type:'text', value:''},
	{name:'Service', type:'text', width:'90px'}, 
	{name:'Connection', type:'choice', width:'90px', choices:['http']}, 
	{name:'Address', type:'text', width:'90px'},
	{name:'Port', type:'text', width:'90px'},
	{name:'Usename', type:'text'},
	{name:'Password', type:'text'},
	{name:'Agent', type:'text', width:'150px'},
	{name:'Node type', type:'text'},
	{name:'Servlet', type:'text'}
	]
	);
	
XMLRPCServer.help = function(){
	return "XMLRPC Server: profile used to declare which resource (Hardware/Machine) hosts a service and to configure connection parameters to access this resource. An XMLRPC Server is attached to an XMLRPC Service."+
	"\nService: Name of the service to which this server is to be attached. It must be declared in the XMLRPCService section " +
	"\nConnection: protocol used to reach the server" +
	"\nAddress: address of the XMLRPC server, either fully qualifed domain name or IP address."+
	"\nPort: listening port on the XMLRPC server."+
	"\nUsername: The string used as the user login name to the XMLRPC header. It must be consistent with the AIR server configuration."+
	"\nPassword: The string used as the password in the XMLRPC header. It must be consistent with the AIR server configuration."+
	"\nAgent: Optional parameter. The string used in the HTTP user-agent field in the XMLRPC requests to the AIR server."+
	"\n\tUsual format is <client_name>/<protocol-version>/<client_version> ; Default: UGw Server/3.1/1.1."+
	"\nNode type: Optional parameter. The string used in the node type parameter of the HTTP header. Default: IVR."+
	"\nServlet: the name of the servlet acting as wrapper for the RMI interface. Example: RPC2";
}

XMLRPCServer.build = function(){
	var nameIndexes = XMLRPCServer.nameIndexes;
	var currentVNFC = "";

	XMLRPCServer.check = "";
	var result = "\n";
	var table = document.getElementById("XMLRPCServer");
	var rowCount = table.rows.length;
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	
	var services = new Array();
	var connections = new Array();
	var addresses = new Array();
	var ports = new Array();
	var usernames = new Array();
	var passwords = new Array();
	var agents = new Array();
	var nodeTypes = new Array();
	var servlets = new Array();
	
	result += "\n# ----------------- #";
	result += "\n# XMLRPC Servers    #";
	result += "\n# ----------------- #";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = XMLRPCServer.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		if(VNFCindex == -1){
			XMLRPCServer.check += "\nXMLRPCServer vs nodes sections: VNFC "+VNFCName+" is undefined in the nodes table";
			continue;
		}
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";

		// Use the first defined XMLRPC Service on this VNFC as the default service for all servers, or nothing
		var defaultService = XMLRPCService.names != undefined && XMLRPCService.names[VNFCindex] != undefined && XMLRPCService.names[VNFCindex].length > 0 ? XMLRPCService.names[VNFCindex][0] : ''; 
		var service=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Service', defaultService);
		var connection=XMLRPCServer.getAndSetSelection(row, nameIndexes, 'Connection', 0);
		var address=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Address', '192.168.0.'+i);
		var port=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Port', '9084');
		var username=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Usename', 'xmlrpc');
		var password=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Password', 'xmlrpc');
		var agent=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Agent');
		var nodeType=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Node type');
		var servlet=XMLRPCServer.getAndSetValue(row, nameIndexes, 'Servlet', 'RPC2');
		
		if(service == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: service cannot be blank";
			continue;
		}
		if(connection == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: connection cannot be blank";
			continue;
		}
		if(address == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: address cannot be blank";
			continue;
		}
		if(port == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: port cannot be blank";
			continue;
		}
		if(username == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: username cannot be blank";
			continue;
		}
		if(password == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: password cannot be blank";
			continue;
		}
		if(servlet == ""){
			XMLRPCServer.check += "\nXMLRPCServer section: servlet cannot be blank";
			continue;
		}
		
		if(XMLRPCService.names == undefined || XMLRPCService.names[VNFCindex] == undefined || XMLRPCService.names[VNFCindex].indexOf(service) < 0){
			XMLRPCServer.check += "\nXMLRPCServer vs XMLRPCService sections: the service "+service+" is undefined on "+VNFdisplayName;
			continue;
		}

		if(services[VNFCindex] == undefined)services[VNFCindex] = new Array();
		services[VNFCindex].push(service);
		if(connections[VNFCindex] == undefined)connections[VNFCindex] = new Array();
		connections[VNFCindex].push(connection);
		if(addresses[VNFCindex] == undefined)addresses[VNFCindex] = new Array();
		addresses[VNFCindex].push(address);
		if(ports[VNFCindex] == undefined)ports[VNFCindex] = new Array();
		ports[VNFCindex].push(port);
		if(usernames[VNFCindex] == undefined)usernames[VNFCindex] = new Array();
		usernames[VNFCindex].push(username);
		if(passwords[VNFCindex] == undefined)passwords[VNFCindex] = new Array();
		passwords[VNFCindex].push(password);
		if(servlets[VNFCindex] == undefined)servlets[VNFCindex] = new Array();
		servlets[VNFCindex].push(servlet);
		// New elements should be pushed at index names.length -1 to match this server resource definition
		var serviceIndex = services[VNFCindex].length -1;
		if(agent != ""){
			if(agents[VNFCindex] == undefined)agents[VNFCindex] = new Array();
			agents[VNFCindex][serviceIndex]=agent;
		}
		if(nodeType != ""){
			if(nodeTypes[VNFCindex] == undefined)nodeTypes[VNFCindex] = new Array();
			nodeTypes[VNFCindex][serviceIndex]=nodeType;
		}
	}

	VNFCnames.forEach(function(e,i){
		if(services[i] == undefined || services[i].length == 0)return;
		fillArrays(connections[i]);
		fillArrays(addresses[i]);
		fillArrays(ports[i]);
		fillArrays(usernames[i]);
		fillArrays(passwords[i]);
		fillArrays(servlets[i]);
		fillArrays(agents[i]);
		fillArrays(nodeTypes[i]);
		result += ifVNFCopen(e,i);
		result += "\nXMLRPC_SERVER_SERVICE=( "+services[i].join(" ")+" )";
		if(connections[i] != undefined)result += "\nXMLRPC_SERVER_CONNECTION=( "+connections[i].join(" ")+" )";
		if(addresses[i] != undefined)result += "\nXMLRPC_SERVER_ADDR=( "+addresses[i].join(" ")+" )";
		if(ports[i] != undefined)result += "\nXMLRPC_SERVER_PORT=( "+ports[i].join(" ")+" )";
		if(usernames[i] != undefined)result += "\nXMLRPC_SERVER_USERNAME=( "+usernames[i].join(" ")+" )";
		if(passwords[i] != undefined)result += "\nXMLRPC_SERVER_PASSWORD=( "+passwords[i].join(" ")+" )";
		if(agents[i] != undefined)result += "\nXMLRPC_SERVER_USERAGENT=( "+agents[i].join(" ")+" )";
		if(nodeTypes[i] != undefined)result += "\nXMLRPC_SERVER_NODETYPE=( "+nodeTypes[i].join(" ")+" )";
		if(servlets[i] != undefined)result += "\nXMLRPC_SERVLET_NAME=( "+servlets[i].join(" ")+" )";
		result += ifVNFCclose(e,i);
	});

	if(XMLRPCServer.check != "")result = XMLRPCServer.check;

	return result;
};

// ===========================
// Native Applications
// ===========================
var NativeApps = new vnfResource("NativeApps", [
	{name:'VNFC', type:'text', value:''}, 
	{name:'NIVR_DB_TYPE', type:'text', width:'90px'},
	{name:'EBRS TENANTMP', type:'text', width:'90px'},
	{name:'NIVR', type:'text', width:'90px'},
	{name:'CaaS IVR', type:'text', width:'90px'}, 
	{name:'OCCP', type:'text', width:'90px'}
	
	]
	);
		
NativeApps.help = function(){
	return "Configure native applications: \n" +
	"- NIVR_DB_TYPE: database type for MSE native applications: pgsql | oracle | mysql \n" +
	"- EBRS TENANTMP: (optional) multi-tenant access control database type for the reports interface of the EBRS \n"+
	"\tThe EBRS will use for tenant access control a database of such type picked in the Nodes section instead of the NIVR_DB_TYPE instantiated in this VNFC \n"+  
	"- NIVR:  MCM, TPDM and Reporting System (disabled on pgsql database): yes | no, default: no \n" +
	"- CaaS IVR (also known as SMB apps): yes | no, default: no \n" +
	"- OCCP:  basic translation number (SNTS): yes | no, default: no \n";
};

NativeApps.build = function (){
	var nameIndexes = NativeApps.nameIndexes;
	NativeApps.check="";
	var result = "\n";
	var table = document.getElementById("NativeApps");
	var rowCount = table.rows.length;
	// only one line per VNFC supported, hence the need to check duplication
	
	// variables collecting vectors
	// How many VNFCs to manage?
	var nbVNFC = Nodes.count('VNFC');
	var localVNFCnames = new Array(nbVNFC)
	var nivrDbTypes = new Array(nbVNFC);
	var ebrsDBs = new Array(nbVNFC);
	var activateNivrs= new Array(nbVNFC);
	var activateCassivrs = new Array(nbVNFC);
	var activateOCCPs= new Array(nbVNFC);
	
	result += "\n# ------------------------------- #";
	result += "\n# Activable Native Applications   #";
	result += "\n# ------------------------------- #";
	result += "\n# NIVR database type mysql|pgsql|oracle  ";
	
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var VNFCName = NativeApps.getAndSetValue(row, nameIndexes, 'VNFC');
		var VNFCindex = VNFCnames.indexOf(VNFCName);
		var VNFdisplayName = VNFCName != "" ? "the VNFC " + VNFCName : "the composed VNF";
		if(VNFCindex == -1){
			NativeApps.check += "\nNativeApps section: VNFC "+VNFCName+" is undefined in the nodes table";
			break;
		}
		if(localVNFCnames[VNFCindex] != undefined){
			NativeApps.check += "\nNativeApps section: "+VNFdisplayName+" is duplicated";
			break;
		}
		
		var nivrDbType = NativeApps.getAndSetValue(row, nameIndexes, 'NIVR_DB_TYPE', 'pgsql');
		var ebrsDbType = NativeApps.getAndSetValue(row, nameIndexes, 'EBRS TENANTMP');
		var activateNivr = NativeApps.getAndSetValue(row, nameIndexes, 'NIVR', 'yes');
		var activateCassivr = NativeApps.getAndSetValue(row, nameIndexes, 'CaaS IVR', 'no');
		var activateOCCP = NativeApps.getAndSetValue(row, nameIndexes, 'OCCP', 'no');
		NativeApps.check += checkDependency(activateCassivr == 'yes', [activateNivr == 'yes'], "NativeApps section: ", "CaaS IVR activation requires NIVR one" );
		
		localVNFCnames[VNFCindex] = VNFCName;
		nivrDbTypes[VNFCindex] = nivrDbType;
		switch(ebrsDbType){
			case undefined: case '': break;
			case 'pgsql':
				// This VNFC requires a pgsql database for the EBRS: search locally then in the composed VNF for the first pgsql IP address
				var ebrsDB = undefined;
				[VNFCindex, 0].forEach(function(iVNFC){
					if(Nodes.pgsqlNodeIp != undefined && Nodes.pgsqlNodeIp[iVNFC] != undefined && Nodes.pgsqlNodeIp[iVNFC][0] != undefined)ebrsDB=Nodes.pgsqlNodeIp[iVNFC][0];
				});	
				if(ebrsDB == undefined){
					NativeApps.check += "Native applications vs Nodes section: EBRS TENANTMP on "+VNFdisplayName+": cannot find a pgsql database.";
				}else{
					ebrsDBs[VNFCindex] = ebrsDB;
				}
				break;
			default:
				NativeApps.check += "Native applications EBRS TENANTMP on "+VNFdisplayName+": "+ebrsDbType+ " not supported, pgsql expected.";
				break;
		}
	
		activateNivrs[VNFCindex] = activateNivr;
		activateCassivrs[VNFCindex] = activateCassivr;
		activateOCCPs[VNFCindex] = activateOCCP;

		// Native applications are candidate to http load balancing with hard coded instance Id 1: check conflict on instance ids with other candidates
		if(activateNivr == 'yes')NativeApps.check += httpLbCheckAndGetSeeInstanceIds("Native applications MCM/TPDM", VNFCindex, "1");
	}
	
	// if nothing defined for the composed VNF
	if(localVNFCnames[0] == undefined){
		// Force the default policy explicitly
		result +="\nACTIVATE_APPLI_NIVR=no";
		result +="\nACTIVATE_APPLI_CAASIVR=no";
		result +="\nACTIVATE_OCCP_SNTS=no";
	} 
	VNFCnames.forEach(function(e,i){
		if(localVNFCnames[i] != undefined)
		{
			result += ifVNFCopen(e,i);
			// Known limitation: RS_DB_TYPE should be the same 
			result += "\nNIVR_DB_TYPE="+nivrDbTypes[i];
			result += "\nRS_DB_TYPE=${NIVR_DB_TYPE}";
			if(ebrsDBs[i] != undefined && ebrsDBs[i] != '')result += "\nEBRS_TENANTMP="+ebrsDBs[i];
			result += "\nACTIVATE_APPLI_NIVR="+activateNivrs[i];
			result += "\nACTIVATE_APPLI_CAASIVR="+activateCassivrs[i];
			result += "\nACTIVATE_OCCP_SNTS="+activateOCCPs[i];
			result += ifVNFCclose(e,i);
		}
	});
	
	// Export the NIVR activation attribute for consistency check
	NativeApps.activateNivrs = activateNivrs.slice();
	// Local check
	if(NativeApps.check != "")result = NativeApps.check;
	return result;
};

// ===========================
// WebRTC
// ===========================
var WebRTC = new vnfResource("WebRTC", [
	{name:'Function', type:'choice', choices:[
		'WEBRTC_SIP_PORT', 'WEBRTC_MEDIA_EXT_START', 'WEBRTC_MEDIA_EXT_END', 
		'WEBRTC_SIPPROXY_PORT', 'WEBRTC_SIPREGISTRAR_PORT', 'WEBRTC_OCMP_TRANSCODER_PORT', 'WEBRTC_ICE'
		]},
	{name:'Value', type:'text'}
	]
	);
var WebRTCDefault = new Array();
var WebRTCComment = new Array();
WebRTCDefault.WEBRTC_SIP_PORT="5062";
WebRTCComment.WEBRTC_SIP_PORT="SIP port used on the WebRTC Back End";
WebRTCDefault.WEBRTC_OCMP_TRANSCODER_PORT="5070";
WebRTCComment.WEBRTC_OCMP_TRANSCODER_PORT="SIP port used with the transcoder OCMP";
WebRTCDefault.WEBRTC_SIPPROXY_PORT="5077";
WebRTCComment.WEBRTC_SIPPROXY_PORT="SIP port used for the SIP proxy function";
WebRTCDefault.WEBRTC_SIPREGISTRAR_PORT="5077";
WebRTCComment.WEBRTC_SIPREGISTRAR_PORT="SIP port used for the SIP registrar function";
WebRTCComment.WEBRTC_ICE="ICE server for WebRTC";
WebRTC.help = function(){
	return "WebRTC settings:"+
	"\nWEBRTC_SIP_PORT: SIP port used on the WebRTC Back End" +
	"\nWEBRTC_MEDIA_EXT_START: WebRTC external media port range start" +
	"\nWEBRTC_MEDIA_EXT_END: WebRTC external media port range end" +
	"\nWEBRTC_SIPPROXY: SIP port used for the SIP proxy and registrar function" + 
	"\nWEBRTC_OCMP_TRANSCODER_PORT: SIP port used with the transcoder OCMP" +
	"\nWEBRTC_ICE: "+WebRTCComment.WEBRTC_ICE
;
}

WebRTC.build = function(){
		var nameIndexes = WebRTC.nameIndexes;
		WebRTC.check = "";
		var result = "\n";
		var table = document.getElementById("WebRTC");
		var rowCount = table.rows.length;
		var webrtcExtStart = "";
		var webrtcExtEnd = "";
		result += "\n# ------------------------------- #";
		result += "\n# WebRTC                           #";
		result += "\n# ------------------------------- #";
		for(var i=1; i < rowCount; i++){
			var row = table.rows[i];
			var propertyName=WebRTC.getAndSetSelection(row, nameIndexes, 'Function');
			switch(propertyName){
				case 'WEBRTC_MEDIA_EXT_START':
					webrtcExtStart=WebRTC.getAndSetValue(row, nameIndexes, 'Value', '20000', 'WEBRTC_MEDIA_EXT_START');
					break;
				case 'WEBRTC_MEDIA_EXT_END':
					webrtcExtEnd=WebRTC.getAndSetValue(row, nameIndexes, 'Value', '20100', 'WEBRTC_MEDIA_EXT_END');
					break;
				default:
					result += "\n# "+WebRTCComment[propertyName];
					result += "\n"+propertyName+'="'+WebRTC.getAndSetValue(row, nameIndexes, 'Value', WebRTCDefault[propertyName], WebRTCComment[propertyName])+'"';
					break;
			}
		}
		if(webrtcExtEnd == ""){
			webrtcExtEnd = webrtcExtStart;
		}else{
			if(webrtcExtStart == "")
				webrtcExtStart = webrtcExtEnd;
		}
		if(webrtcExtStart != ""){
			if(webrtcExtEnd < webrtcExtStart)
				WebRTC.Check += "WebRTC port range start should be less than range end";
			result += "\n# WebRTC external media port range";
			result += "\nWEBRTC_MEDIA_EXT_PORT_RANGE="+webrtcExtStart+","+webrtcExtEnd;
		}
					
		return result;
	};

// ==================
// Licensing
// ==================
var Licensing = new vnfResource("Licensing", [
	{name:'Feature', type:'choice', width:'400px', choices: [
		'SEE_SIP_SERIAL', 'SEE_SIP_CODEWORD', 
		'OCMP_BRE_LIC_KEY', 'OCMP_BRE_LIC_EXPIRES', 'OCMP_BRE_LIC_DESCRIPTION', 
		'OCMP_BRE_LIC_VXML_INSTANCES', 'OCMP_BRE_LIC_ASR_INSTANCES', 'OCMP_BRE_LIC_TTS_INSTANCES',
		'OCMP_BRE_LIC_FEATURE_NAME', 'OCMP_BRE_LIC_FEATURE_INSTANCES'
		]}, 
	{name:'Value', type:'text', width:'400px'}
	]
	);
	
var LicensingComment = new Array();
LicensingComment.SEE_SIP_SERIAL="SIP stack licensing serial number for SEE and OCMP";
LicensingComment.SEE_SIP_CODEWORD="SIP stack licensing codeword for SEE and OCMP";
LicensingComment.OCMP_BRE_LIC_KEY="OCMP BRE license key";
LicensingComment.OCMP_BRE_LIC_EXPIRES="OCMP BRE license expiration date";
LicensingComment.OCMP_BRE_LIC_DESCRIPTION="OCMP BRE license description";
LicensingComment.OCMP_BRE_LIC_VXML_INSTANCES="OCMP BRE license number of Vxml instances";
LicensingComment.OCMP_BRE_LIC_ASR_INSTANCES="OCMP BRE license number of automatic speech recognition instances";
LicensingComment.OCMP_BRE_LIC_TTS_INSTANCES="OCMP BRE license number of text to speech instances";
LicensingComment.OCMP_BRE_LIC_FEATURE_NAME="OCMP BRE license feature name";
LicensingComment.OCMP_BRE_LIC_FEATURE_INSTANCES="OCMP BRE license number of feature instances";

var LicensingDefault = new Array();
LicensingDefault.SEE_SIP_SERIAL="0BCN04-z8jWFC-VWXYAA-VVVVAA-VUzVAD-VQNVEB";
LicensingDefault.SEE_SIP_CODEWORD="0Emw03-z9pMFE-CDEF55-CCCC55-CDkC52-D2CC55-CeCC15";
LicensingDefault.OCMP_BRE_LIC_KEY="1925g18";
LicensingDefault.OCMP_BRE_LIC_EXPIRES="1533073813834";
LicensingDefault.OCMP_BRE_LIC_DESCRIPTION="ExpiresJuly2018";
LicensingDefault.OCMP_BRE_LIC_VXML_INSTANCES="20";
LicensingDefault.OCMP_BRE_LIC_ASR_INSTANCES="20";
LicensingDefault.OCMP_BRE_LIC_TTS_INSTANCES="20";
LicensingDefault.OCMP_BRE_LIC_FEATURE_NAME="CertificateID.HPEInternal";
LicensingDefault.OCMP_BRE_LIC_FEATURE_INSTANCES="unlimited";

Licensing.help = function(){
	return "Licensing data" + 
	"\nSEE_SIP_SERIAL: "+LicensingComment.SEE_SIP_SERIAL+
	"\nSIP_CODEWORD: "+ LicensingComment.SEE_SIP_CODEWORD+
	"\nOCMP_BRE_LIC_KEY: "+ LicensingComment.OCMP_BRE_LIC_KEY+
	"\nOCMP_BRE_LIC_EXPIRES: "+ LicensingComment.OCMP_BRE_LIC_EXPIRES+
	"\nOCMP_BRE_LIC_DESCRIPTION: "+ LicensingComment.OCMP_BRE_LIC_DESCRIPTION+
	"\nOCMP_BRE_LIC_VXML_INSTANCES: "+ LicensingComment.OCMP_BRE_LIC_VXML_INSTANCES+
	"\nOCMP_BRE_LIC_ASR_INSTANCES: "+ LicensingComment.OCMP_BRE_LIC_ASR_INSTANCES+
	"\nOCMP_BRE_LIC_TTS_INSTANCES: "+ LicensingComment.OCMP_BRE_LIC_TTS_INSTANCES+
	"\nOCMP_BRE_LIC_FEATURE_NAME: "+ LicensingComment.OCMP_BRE_LIC_FEATURE_NAME+
	"\nOCMP_BRE_LIC_FEATURE_INSTANCES: "+ LicensingComment.OCMP_BRE_LIC_FEATURE_INSTANCES;
}
	
Licensing.build = function(){
	var nameIndexes = Licensing.nameIndexes;
	var result = '\n';
	Licensing.check = "";
	var table = document.getElementById('Licensing');
	var rowCount = table.rows.length;
	result += "\n# ----------------- #";
	result += "\n# Licensing         #";
	result += "\n# ------------------#";
	for(var i=1; i < rowCount; i++){
		var row = table.rows[i];
		var featureName=Licensing.getAndSetSelection(row, nameIndexes, 'Feature');
		result += "\n# "+LicensingComment[featureName];
		result += "\n"+featureName+'="'+Licensing.getAndSetValue(row, nameIndexes, 'Value', LicensingDefault[featureName], LicensingComment[featureName])+'"';
	}
	result += '\n# SIP stack licensing codeword for OCMP same as SEE';
	result += '\nOCMP_SIPLIC_SERIAL=${SEE_SIP_SERIAL}';
	result += '\nOCMP_SIPLIC_CODEWORD=${SEE_SIP_CODEWORD}';
	result += "\n";
	return result;
}

// Display only used sections
vnfResources.forEach(function(e,i,t){e.display(!e.isEmpty())});

// ===========================
// MSE Descriptor build
// ===========================
// If no target is specified, publish the descriptor in the user output area (or errors)
// Otherwise, just return the same to the caller
var endOfDescriptor="# +++ EOF +++ # Do not delete this line";
function buildVNFDescriptor(target){
	var quickDescription = document.getElementById("quickDescription");
	quickDescription.setAttribute("value", quickDescription.value);
	document.title = "MSE VNF "+ quickDescription.value;
	
	consistency.init();
	var warnings = "";
	
	var desc = "# -------------------------------------------------------------";
	desc += "\n# "+quickDescription.value;
	desc += "\n# MSE Descriptor generated by the builder "+document.getElementById("vnfDescriptorWizardVersion").innerHTML;
	desc += "\n# Build date: "+Date();
	desc += "\n# PRE REQUISISTES ON THE NODE RUNNING THE UNATTENDED NIVR SETUP";
	desc += "\n# 1. The management network is up and running";
	desc += "\n# 2.1 The command 'hostname' returns a fully qualified domain name used for node identification within the cluster";
	desc += "\n# 2.2 The command 'hostname -i' returns the node IPV4 address on the MGMT network";
	desc += "\n# OR";
	desc += "\n# 2. /etc/sysconfig/network has a fully qualified domain name at the HOSTNAME entry";
	desc += "\n# 3. MSE bits are available as:";
	desc += "\n# 3.1 ISOs images on the file system in /var/opt/OC/iso or ";
	desc += "\n# 3.2 YUM repositories listed in YUM_REPO_LIST and IS_YUM_REPO=yes";
	desc += "\n# -------------------------------------------------------------";
	desc += "\n";

	vnfResources.forEach(function(e,i,t){
		desc += e.build(target);
		warnings += e.check;
	});
	warnings += consistency.check();
	desc += "\n"
	if(warnings != ""){
		userOutput(warnings);
		return;
	}

	
	// Immutable section
	desc += "\n# --------------------------------------------------- #";
	desc += "\n# Node receiving outgoing calls from SMB WebRTC client";
	desc += "\n# Default: the NFV installed SIP load balancer VIP ";
	desc += "\n# --------------------------------------------------- #";
	desc += getNameIpAddr("WEBRTC_CALLEE", "", "${VSIP_NAME}", "${VSIP_IP_ADDR}");
	desc += "\n"
	desc += "\n# Optional list of RPM packages providing specific prompts";
	desc += '\nAPP_PROMPTS="/var/opt/OC/iso/hpoc-smb-demo-prompts*.rpm"';
	desc += "\n";
	desc += "\n# ------------------------------- #";
	desc += "\n# Various database passwords ";
	desc += "\n# ------------------------------- #";
	desc += '\n# pgsql';
	desc += '\nNIVRDB_OCDBROOT_PASSWORD=ocdbroot';
	desc += '\nNIVRDB_OCDBREP_PASSWORD=ocdbrep';
	desc += '\nNIVRDB_OCDBADMIN_PASSWORD=ocdbadmin';
	desc += '\nNIVRDB_OCDBACCESS_PASSWORD=ocdbaccess';
	desc += '\nNIVRDB_APPADMIN_PASSWORD=appadmin';
	desc += '\nNIVRDB_APPACCESS_PASSWORD=appaccess';
	desc += "\n";
	desc += '\n# mysql: force strong passwords';
	desc += '\nif [[ "$NIVR_DB_TYPE" == "mysql" ]] ; then';
	desc += '\nNIVRDB_ROOT_PASSWORD=HP1nvent!';
	desc += '\nNIVRDB_OCDBACCESS_PASSWORD=${NIVRDB_ROOT_PASSWORD}';
	desc += '\nNIVRDB_OCDBREP_PASSWORD=${NIVRDB_ROOT_PASSWORD}';
	desc += "\nfi";
	desc += "\n";
	desc += "\n";
	desc += '\n# oracle';
	desc += "\nTPDM_TABLESPACE=NFVTPDM_TS";
	desc += "\nAAA_TABLESPACE=NFVAAA_TS";
	desc += "\nMCM_TABLESPACE=NFVMCM_TS";
	desc += "\nMCS_TABLESPACE=NFVMCS_TS";
	desc += "\nSMB_TABLESPACE=NFVSMB_TS";
	desc += "\n";
	desc += '\n# Reporting System ';
	desc += '\nNIVRDB_CCPS_DS_PASSWORD=CCPS_DS';
	desc += '\nNIVRDB_CCPS_PASSWORD=CCPS';
	desc += '\nNIVRDB_CCXML_PASSWORD=CCXML';
	desc += '\nNIVRDB_EBRS_DS_PASSWORD=EBRS_DS';
	desc += '\nNIVRDB_EBRS_QRTZ_PASSWORD=EBRS_QRTZ';
	desc += '\nNIVRDB_EBRS_QRTZ_DS_PASSWORD=EBRS_QRTZ_DS';
	desc += '\nNIVRDB_EBRS_PASSWORD=EBRS';
	desc += '\nNIVRDB_JBOSS_JMS_PASSWORD=JBOSS_JMS';
	desc += '\nNIVRDB_MSCML_PASSWORD=MSCML';
	desc += '\nNIVRDB_REPORT_USER_PASSWORD=REPORT_USER';
	desc += '\nNIVRDB_VXML_PASSWORD=CRYSTAL';
	desc += '\nNIVRDB_QRTZ_DS_PASSWORD=QRTZ_DS';
	desc += '\nNIVRDB_QRTZ_PASSWORD=QRTZ';
	desc += "\n";
	desc += '\n# ----------------------';
	desc += '\n# USPM ISO image Details';
	desc += '\n# ----------------------';
	desc += "\nUSPM_ISO_PATH=$(ls /var/opt/OC/iso/USPM*.iso 2> /dev/null)";
	desc += "\n";
	desc += "\n# Enable refresh by not deleting root ssh keys at the end of installation";
	desc += "\nRETAIN_SSH_KEYS_ROOT=YES";
	desc += "\n";
	desc += "\n#-------------------------------------------";
	desc += "\n# Legacy management based on MSE connectors ";
	desc += "\n# Used to enable/disable features           ";
	desc += "\n#-------------------------------------------";
	desc += "\n_legacySEE() {  command -v install-mse-connectors.sh install-mse_connectors.sh > /dev/null || test -f /var/opt/OC/iso/OpenCall-SEE*.iso && return 0 || return 1 ; }";
	desc += "\n# NIVR and CaaS IVR: activate on SEE3 only";
	desc += "\n# Messaging Framework, redis and all emscli resources: disable on SEE3";
	desc += "\nif _legacySEE ; then";
	desc += "\nMESSAGING_FRAMEWORK_SERVICE_COMPONENT_NAME=";
	desc += "\nMESSAGING_GATEWAY_SERVICE_COMPONENT_NAME=";
	desc += "\nACTIVATE_APPLI_MESSAGING_FRAMEWORK=no";
	desc += "\nACTIVATE_APPLI_MESSAGING_GATEWAY=no";
	desc += "\nTCAP_PROVIDER_NAME=()";
	desc += "\nDIAMETER_SERVICE_COMPONENT_NAME=()";
	desc += "\nUCP_PROVIDER_NAME=()";
	desc += "\nSMPP_PROVIDER_NAME=()";
	desc += "\nMRF_ADAPTER_SERVICE_COMPONENT_NAME=()";
	desc += "\nDATASOURCE_NAME=()";
	desc += "\nLDAP_PROFILE_NAME=()";
	desc += "\nSOAP_SERVICE_COMPONENT_NAME=()";
	desc += "\nSOAP_WSS_NAME=()";
	desc += "\nSOAP_SECURITY_NAME=()";
	desc += "\nSOAP_WS_NAME=()";
	desc += "\nREDIS_HOST=()";
	desc += "\nREDIS_IP_ADDR=()";
	desc += "\nREDIS_INSTANCE_ID=()";
	desc += "\nREDIS_PORT=()";
	desc += "\nOCCP_SWITCHING_POINT=()";
	desc += "\nOCCP_MEDIA_SERVER=()";
	desc += "\nXMLRPC_SERVICE_COMPONENT_NAME=()";
	desc += "\nXMLRPC_SERVICE=()";
	desc += "\nXMLRPC_SERVER_ADDR=()";
	desc += "\nelse";
	desc += "\n# NIVR native applications supported only on PostgreSQL database without WebRTC on SEE > 3";
	desc += "\nACTIVATE_APPLI_NIVR=$([[ $WEBRTC_SIGNALING_IP_ADDR == '' ]] && [[ $NIVR_DB_TYPE == 'pgsql' ]] && echo $ACTIVATE_APPLI_NIVR || echo no)";
	desc += "\nACTIVATE_APPLI_CAASIVR=no";
	desc += "\nACTIVATE_OCCP_SNTS=no";
	desc += "\nfi";
	desc += "\n";
	desc += "\n"+endOfDescriptor;
	
	if(target == undefined){
		userOutput(desc);	
		
		var blobDesc = new Blob([desc], {type: "text/plain;charset=utf-8"});
		var a = document.createElement('a');
		a.href = window.URL.createObjectURL(blobDesc);
	    a.download = "nivr-cluster-nfv.properties";
	    document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
	}
	return desc;
}

function saveSession(){
	var blobPage = new Blob([document.documentElement.innerHTML], {type: "text/plain;charset=utf-8"});
	var a = document.createElement('a');
	a.href = window.URL.createObjectURL(blobPage);
    a.download = "nivr-cluster-nfv.html";
    document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
}

function importSession(){
	var importFromFile = document.getElementById("importSession").files.item(0).name;
	var importedWindow = window.open(importFromFile, "importedDocument");
	var summary = "Import summary";
	// To do: add a listner on page loaded; in the meantime, wait one second before working on this page
	setTimeout(function(){
		try { 
			var importedQuickDescription = importedWindow.document.getElementById("quickDescription").value;
			if(importedQuickDescription != ""){
				summary += "\nVNF description: " + importedQuickDescription;
				var quickDescription = document.getElementById("quickDescription");
				quickDescription.value += importedQuickDescription;
				quickDescription.setAttribute("value", quickDescription);
			}
			vnfResources.forEach(function(e,i,t){summary += e.import(importedWindow.document);});
			userOutput(summary);
			// Display populated sections
			vnfResources.forEach(function(e,i,t){e.display(!e.isEmpty())});
		} catch(e){
			alert("Session import not supported by this browser, try Firefox or Internet Explorer\n" + e.message);
		}
		}, 1000);
}

function setUspmAuxDescInput(event){
	var input = event.target;
	var reader = new FileReader();
    reader.onload = function(){
    	// Store the USPM descriptor 
    	Misc.heatUspmAuxDesc = reader.result;
    	// Display for control
    	userOutput(reader.result);
    	};
    reader.readAsText(input.files[0]);
}
function clearUspmAuxDescInput(){Misc.heatUspmAuxDesc=undefined; userOutput(''); document.getElementById("uspmAuxDescInput").value= null;}
function viewUspmAuxDescInput(){userOutput(Misc.heatUspmAuxDesc);}
function setSmscAuxDescInput(event){
	var input = event.target;
	var reader = new FileReader();
    reader.onload = function(){
    	// Store the SMSC descriptor 
    	MessagingFrameworkApplication.heatSmscAuxDesc = reader.result;
    	// Display for control
    	userOutput(reader.result);
    };
    reader.readAsText(input.files[0]);
}
function clearSmscAuxDescInput(){MessagingFrameworkApplication.heatSmscAuxDesc=undefined; userOutput('');document.getElementById("smscAuxDescInput").value= null;}
function viewSmscAuxDescInput(){userOutput(MessagingFrameworkApplication.heatSmscAuxDesc);}
function useHeatVolumesHelp(){userOutput(
"Heat storage allocation policy: three options are available:"+
"\n\t- from image: create one volume per instance from a qcow2 image which name is passed as parameter Image"+
"\n\t- from master: create one volume per instance from a master volume which id is passed as parameter Image"+
"\n\t- none: use local storage on compute node, no volume creation" 
);}
// ===========================
// MSE Heat template build
// ===========================
function buildHeatTemplate(){
	// Check if Heat volume are to be used and from which source (image or volume)
	var useHeatVolumes = document.getElementById("useHeatVolumes").value;
	
	var n0="\n";
	var n1="\n\t";
	var n2="\n\t\t";
	var quickDescription = document.getElementById("quickDescription");
	var heat="heat_template_version: 2013-05-23"
	heat+=n0+"description: '"+quickDescription.value+"'";
	heat+=n0+"parameters:";
	heat+=n0+"  NetworkRoot:";
    heat+=n0+"    type: string";
    heat+=n0+"    label: Private network";
    heat+=n0+"    description: 3 dot separated bytes defining the 24 first bits of the internal networks, e.g. 192.168.100";
    heat+=n0+"    default: 192.168.100";
	heat+=n0+"  Image:";
    heat+=n0+"    type: string";
    switch(useHeatVolumes){
    	case 'none':    	heat+=n0+"    description: The name of the image used to instantiate storage on MSE nodes"; break;
    	case 'from image':	heat+=n0+"    description: The name of the image used to instantiate MSE volumes"; break;
    	case 'from master':	heat+=n0+"    description: The id of the master volume used to instantiate MSE volumes"; break;
    }
    heat+=n0+"    default: MSE243.qcow2";
	heat+=n0+"  ExternalNetwork:";
    heat+=n0+"    type: string";
    heat+=n0+"    description: The name of the external public network used to connect floating IPs";
    heat+=n0+"    default: ext-net";
    heat+=n0+"  AvailabilityZone:";
    heat+=n0+"    type: string";
    heat+=n0+"    label: Availability zone";
    heat+=n0+"    description: The name of the zone hosting the MSE nodes";
    heat+=n0+"    default: nova";
	heat+=n0+"  flavorStandard:";
    heat+=n0+"    type: string";
    heat+=n0+"    description: The name of the openstack flavor used to build the SEE Application nodes";
    heat+=n0+"    default: v2.m8";
	heat+=n0+"  flavorPerformance:";
    heat+=n0+"    type: string";
    heat+=n0+"    description: The name of the openstack flavor used to build the OCMP nodes";
    heat+=n0+"    default: v2.m8";
	heat+=n0+"  flavorSmall:";
    heat+=n0+"    type: string";
    heat+=n0+"    description: The name of the openstack flavor used to build the other nodes";
    heat+=n0+"    default: v2.m2";
    if(useHeatVolumes != 'none'){
	heat+=n0+"  VolumeSize:";
    heat+=n0+"    type: number";
    heat+=n0+"    description: The size in Gb of the volumes attached to the nodes.";
    heat+=n0+"    default: 20";
	}
	heat+=n0;
	heat+=n0+"resources:";
	
	// Build the descriptor for Heat (or get the errors) and do not publish
	// Required soon enough to get Heat specific variables properly setup
    var desc = buildVNFDescriptor('Heat');
    
    // if the enf of descriptor is not found, show the error and quit
    if(desc.indexOf(endOfDescriptor) == -1){
    	userOutput(desc);
    	return; 
    }
	
	// Create networks from Networks.heatNetworks array: 
	// The networks are to be created in the interface number order to ensure that ethX is actually connected to interface X
	// One common router
	heat+=n0+"  Router:";
    heat+=n0+"    type: OS::Neutron::Router";
    heat+=n0+"    properties:";
    heat+=n0+"      admin_state_up: True";
    heat+=n0+"      name: { get_param : 'OS::stack_name' }";
	heat+=n0+"  Gateway:";
    heat+=n0+"    type: OS::Neutron::RouterGateway";
    heat+=n0+"    properties:";
    heat+=n0+"      network: { get_param: ExternalNetwork }";
    heat+=n0+"      router_id: { get_resource: Router }";

	var networkPrefix = 'Eth';
	var mgmtName = networkPrefix + Networks.heatNetworks['MGMT']; 
    
    for(var i = 0; i <= Networks.heatMaxNetwork; i++){
	var interfaceName = networkPrefix+i;	// network name, Networks.heatMaxNodes addresses large
	var cidr = Networks.heatMaxNodes*i;		// first address in this network
	var gateway = cidr + 1;	// gateway IP for this network
	heat+=n0+"  "+interfaceName+":";
    heat+=n0+"    type: OS::Neutron::Net";
    heat+=n0+"    properties:";
	heat+=n0+"      name: {list_join: [ '-', ['"+interfaceName+"', { get_param : 'OS::stack_name' }]]}";
	heat+=n0+"  "+interfaceName+"-subnet:";
    heat+=n0+"    type: OS::Neutron::Subnet";
    heat+=n0+"    properties:";
    heat+=n0+"      name: {list_join: [ '-', ['"+interfaceName+"', { get_param : 'OS::stack_name' }]]}";
    heat+=n0+"      enable_dhcp: True";
    heat+=n0+"      network: { get_resource: "+interfaceName+" }";
    heat+=n0+"      cidr: { list_join: [ '.', [{ get_param : NetworkRoot}, '"+cidr+"/"+Networks.heatCidrLength+"']]}";
    heat+=n0+"      gateway_ip: { list_join: [ '.', [{ get_param : NetworkRoot}, '"+gateway+"']]}";
    }

	// Connect the management network to the router for floating IPs  
	heat+=n0+"  Router-gw-int:";
    heat+=n0+"    type: OS::Neutron::RouterInterface";
    heat+=n0+"    properties:";
    heat+=n0+"      router_id: { get_resource: Router }";
    heat+=n0+"      subnet_id: { get_resource: "+mgmtName+"-subnet }";
    
    // addr will resolve all ip addresses parameters as a reference to their relative port
    var addr=""; 
    
    // Nodes dependency to EMS: to ensure all nodes readiness when the EMS starts, so that descriptor push succeeds, make the EMS depending on all other nodes
    var nodesNames = Nodes.heatNodes.map(function(e){return e.name;});
    // The EMS is the last node in Nodes.heatNodes: remove it to build the list of non EMS nodes,then filter the nodes playing a VIP role
    var nonEmsNodesNames = Nodes.heatNodes.slice(0, Nodes.heatNodes.length - 1).filter(function(e){return !e.isVIP;}).map(function(e){return e.name;});  
    
    // For each node: create the ports and optional associated floating IP on all networks, the volume and the instance
    nodesNames.forEach(function(name, indexNode){
    	// Create one port on every network to ensure proper interface numbering, but connect only used interfaces
    	// Prepare the ports declared in the instance as yaml instructions in this variable: port
    	var port=""
    	for(var i = 0; i <= Networks.heatMaxNetwork; i++){
			// VIP processing in Heat/OpenStack: 
			// - a VIP is instantiated as a port
			// - a VIP is declared as allowed_address_pairs on the load balancer nodes
	    	
	    	var interfaceName = networkPrefix+i;	// network name, Networks.heatMaxNodes addresses large
	    	var interfaceUp = "True";
	    	if(Nodes.heatNodes[indexNode].interfaces.indexOf(i) == -1)interfaceUp = "False";
	    	heat+=n0+"  "+name+"-"+interfaceName+"-port:";
	    	heat+=n0+"    type: OS::Neutron::Port";
	    	heat+=n0+"    properties:";
	      	heat+=n0+"      admin_state_up : "+ interfaceUp;
	      	heat+=n0+"      network: { get_resource: "+interfaceName+" }";
	      	
	      	// if this node has VIPs, add allowed_address_pairs accordingly
	      	if(Nodes.heatNodes[indexNode].hasVIP){
	      		heat+=n0+"      allowed_address_pairs:";
	      		// Search for VIPs on this interface on all nodes
	      		nodesNames.forEach(function(nameVIP, indexVIP){
	      			// if this node is a VIP
	      			if(Nodes.heatNodes[indexVIP].isVIP){
	      				// This node is a VIP: add an allowed address for all concerned interfaces
	      				for(var iVIP = 0; iVIP <= Networks.heatMaxNetwork; iVIP++){
	      					// if this VIP is not defined on this interface, continue
	      					if(Nodes.heatNodes[indexVIP].interfaces.indexOf(iVIP) == -1)continue;
	      					// Enable this address in the firewall 
	      					heat+=n0+"        - ip_address: {get_attr: ["+nameVIP+"-"+networkPrefix+iVIP+"-port, fixed_ips, 0, ip_address]}";
	      				} // add an allowed address for all concerned interfaces
	      			} // if this node is a VIP
	      		}); // Search for VIPs on this interface
	      	}// if this node has VIPs
	      	
	      	port+=n0+"        -";
	      	port+=n0+"          port: { get_resource: "+name+"-"+interfaceName+"-port}";
	      	
	      	// Resolve ip address for this port on this node
	      	if(Networks.heatNetworks['MGMT'] == i)	addr+=n0+"~"+name+"_mgmt~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['APP'] == i)	addr+=n0+"~"+name+"_app~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['SIP'] == i)	addr+=n0+"~"+name+"_sip~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['LBNAT'] == i)	addr+=n0+"~"+name+"_nat~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['HA'] == i)	addr+=n0+"~"+name+"_ha~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['DATA'] == i)	addr+=n0+"~"+name+"_data~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['M3UA1'] == i)	addr+=n0+"~"+name+"_m3ua1~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
	      	if(Networks.heatNetworks['M3UA2'] == i)	addr+=n0+"~"+name+"_m3ua2~: {get_attr: ["+name+"-"+interfaceName+"-port, fixed_ips, 0, ip_address]}";
      	}
      	if(Nodes.heatNodes[indexNode].interfaces.indexOf(heatPublicInterface) != -1){
	   		heat+=n0+"  "+name+"-"+mgmtName+"-floatingIP:";
	    	heat+=n0+"    type: OS::Neutron::FloatingIP";
	    	heat+=n0+"    properties:";
	      	heat+=n0+"      floating_network: { get_param: ExternalNetwork }";
	      	heat+=n0+"  "+name+"-"+mgmtName+"-floatingIPassociation:";
	    	heat+=n0+"    type: OS::Neutron::FloatingIPAssociation";
	    	heat+=n0+"    properties:";
	      	heat+=n0+"      port_id: { get_resource: "+name+"-"+mgmtName+"-port }";
	      	heat+=n0+"      floatingip_id: { get_resource: "+name+"-"+mgmtName+"-floatingIP }";
	      	// Resolve public ip addresses for this node
	      	addr+=n0+"~"+name+"_pub~: {get_attr: ["+name+"-"+mgmtName+"-floatingIP, floating_ip_address]}";
      	}
      	
      	// if this node is a VIP, neither volume nor instance are needed
      	// Volumes can be instantiated from image or master volume: in the latter case, a volume id is expected in the Image parameter
      	if(!Nodes.heatNodes[indexNode].isVIP){
      	// if volume usage is enabled
      	if(useHeatVolumes != 'none'){
      	heat+=n0+"  "+name+"-Volume:";
    	heat+=n0+"    type: OS::Cinder::Volume";
    	heat+=n0+"    properties: ";
      	if(useHeatVolumes == 'from image'){
      	heat+=n0+"      image: { get_param: Image }";
      	}else{ 
      	heat+=n0+"      source_volid: { get_param: Image }";
      	}
      	heat+=n0+"      name: {list_join: [ '-', ['"+name+"', { get_param : 'OS::stack_name' }]]}";
      	heat+=n0+"      size: { get_param: VolumeSize }";
      	}
      	heat+=n0+"  "+name+":";
    	heat+=n0+"    type: OS::Nova::Server";
      	if(nonEmsNodesNames.indexOf(name) == -1){
      	heat+=n0+"    depends_on: [ Router-gw-int, "+nonEmsNodesNames.join(', ')+" ]";
      	}
    	heat+=n0+"    properties:";
      	heat+=n0+"      name: "+name;
      	if(useHeatVolumes != 'none'){
      	heat+=n0+"      block_device_mapping: [{ device_name: 'vda', volume_id : { get_resource: "+name+"-Volume } }]";
      	}else{
      	heat+=n0+"      image: { get_param: Image }"; 
      	}
      	heat+=n0+"      flavor: { get_param: "+Nodes.heatNodes[indexNode].flavor+" }";
      	heat+=n0+"      availability_zone: { get_param: AvailabilityZone }";
      	heat+=n0+"      networks:";
      	heat+=port;
      	heat+=n0+"      config_drive: True";
      	heat+=n0+"      user_data_format: 'RAW'";
      	}  	// if this node is a VIP, neither volume nor instance are needed
    }); // For each node: create the resources

  	// Last node is the EMS: pass the Descriptor as raw data on this node
	heat+=n0+"      user_data:";
	heat+=n0+"        str_replace:";
  	heat+=n0+"          template: |";
    heat+=n0+"            #!/bin/bash";
    heat+=n0+"            cat > /etc/opt/OC/hpoc-nivr-nfv/nivr-cluster-nfv.properties << 'EOFILE'";
	heat+=n0+"            "+desc.replace(/\n/g, "\n"+  
		     "            ");	// fix the descriptor indentation as expected by Heat
	heat+=n0+"            EOFILE";

    // If a USPM descriptor is defined, push its auxiliary descriptor
    if(Misc.heatUspmAuxDesc != undefined){
   	heat+=n0+"            cat > "+Misc.heatUspmAuxDescPath+" << 'EOFILE'";
    heat+=n0+"            "+Misc.heatUspmAuxDesc.replace(/\n/g, "\n"+  
		     "            ");	// fix the descriptor indentation as expected by Heat
	heat+=n0+"            EOFILE";
    }
	if(MessagingFrameworkApplication.heatSmscAuxDescPath != undefined){
   	heat+=n0+"            cat > "+MessagingFrameworkApplication.heatSmscAuxDescPath+" << 'EOFILE'";
    heat+=n0+"            "+MessagingFrameworkApplication.heatSmscAuxDesc.replace(/\n/g, "\n"+  
		     "            ");	// fix the descriptor indentation as expected by Heat
	heat+=n0+"            EOFILE";
    }
    heat+=n0+"            exit 0   # required by openstack to properly execute this script";
	
    // Resolve ip addresses parameters 
    heat+=n0+"          params:"+addr.replace(/\n/g, "\n"+  
		     "            ");	// fix the descriptor indentation as expected by Heat;;
    // Resolve default gateway IP address to the MGMT subnet holding floating IPs
    heat+=n0+"            ~pub_gateway~: {get_attr: ["+mgmtName+"-subnet, gateway_ip]}";
	
    // Add outputs:
    heat+=n0+"outputs:";
    // Public names resolution
    heat+=n0+"  PublicNameResolution:";
    heat+=n0+"    description: The public hosts names resolution list";
    heat+=n0+"    value:";
	heat+=n0+"      Fn::Join:"; 
    heat+=n0+"        - '; '";
    heat+=n0+"        - ";
	nodesNames.forEach(function(name, indexNode){ if(Nodes.heatNodes[indexNode].interfaces.indexOf(heatPublicInterface) == -1)return;
	heat+=n0+"          - ";
	heat+=n0+"            Fn::Join:"; 
	heat+=n0+"              - ' '";
	heat+=n0+"              - ";
	heat+=n0+"                - {get_attr: ["+name+"-"+mgmtName+"-floatingIP, floating_ip_address]}";
    heat+=n0+"                - "+name;
    });
    
    // Show to the user and save to nivr-cluster-nfv.yaml
    userOutput(heat);
	
	var blobHeat = new Blob([heat], {type: "text/plain;charset=utf-8"});
	var a = document.createElement('a');
	a.href = window.URL.createObjectURL(blobHeat);
    a.download = "nivr-cluster-nfv.yaml";
    document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
}

window.onbeforeunload = function() {
  return "Unsaved session data will be lost if you leave the page, are you sure?";
};

// if a is true, check that at least one element of x is true
// Otherwise, return a dependency message for roles
function checkDependency(a, x, roles, message){
	if(message == undefined)message = " are required on the same node";
	if( a && ! x.some(function(e, i, t){return e;} ))
		return "\n" + roles + message;
	return "";
}

// Check if only one element of x is true
// Otherwise, return a mutual exclusive message for roles
function checkUnicity(x, roles, message){
	var xTrue = x.filter(
		function(e, i, t){return e;}
	);
	if(message == undefined)message = " are mutually exclusive";
	if(xTrue.length > 1)return "\n" + roles + message;
	return "";
}

// Check if all or none element(s) of x is true
// Otherwise, return a group inconsistency message for roles
function checkGroupConsistency(x, roles, message){
	var xConsistent = ! x.some(
		function(e, i, t){return e;}
	) || x.every(
		function(e, i, t){return e;}
	);
	if(xConsistent)	return "";
	if(message == undefined)message = " group is not consistent (none or all should be true)";
	return "\n" + roles + message;
}

// Build a triple NAME/IP_ADDR/IP_NAT_ADDR of definitions for the role and device, using name and ip addr
// if name or ip addr are undefined, return an empty string
// if they are arrays with non empty elements, output a bash vector, ie space separated list enclosed in parenthesis
function getNameIpAddr(role, device, name, ipAddr, ipNatAddr){
	var result = "";
	var prefix = "";
	var suffix = "";
	var theName = name;
	if(name instanceof Array){
		if(name.join("").trim() != ""){
			theName = name.join(" ");
			prefix = "( ";
			suffix = " )";
		}else{
			theName = "";
		}
	}
	if(theName != undefined && theName != "")result += "\n" + role + "_NAME" + device + "=" + prefix+theName+suffix;
	prefix = suffix = "";
	var theIpAddr = ipAddr;
	if(ipAddr instanceof Array){
		if(ipAddr.join("").trim() != ""){
			theIpAddr = ipAddr.join(" ");
			prefix = "( ";
			suffix = " )";
		}else{
			theIpAddr = "";
		}
	}
	if(theIpAddr != undefined && theIpAddr != "")result += "\n" + role + "_IP_ADDR" + device + "=" + prefix+theIpAddr+suffix;
	prefix = suffix = "";
	var theIpNatAddr = ipNatAddr;
	if(ipNatAddr instanceof Array){
		if(ipNatAddr.join("").trim() != ""){
			theIpNatAddr = ipNatAddr.join(" ");
			prefix = "( ";
			suffix = " )";
		}else{
			theIpNatAddr = "";
		}
	}
	if(theIpNatAddr != undefined && theIpNatAddr != "")result += "\n" + role + "_IP_NAT_ADDR" + device + "=" + prefix+theIpNatAddr+suffix;
	return result;
}

// Useful 'contains' method for String is not available everywhere
if(!('contains' in String.prototype)){
	String.prototype.contains = function(str, startIndex){
		return -1 !== this.indexOf(str, startIndex);
	}
}

// In a list of arrays 'a', for all empty elements from index 0 to the last existing array, create an array and insert a 'defaultString'
function fillArrays(a, defaultString){
	if(a == undefined)return;
	if(defaultString == undefined)defaultString=new String('""');
	var fillArray = false;
	for(var i = a.length - 1; i>=0; i--){
		if(a[i] == undefined){
			if(fillArray){
				a[i] = new Array();
				a[i].push(defaultString);
			}
			else {
				a.pop();	// remove the useless undefined last element
			}
		}
		else{
			fillArray = true;
		}
	}
}

</script>


</body>